[{"categories":["Linux"],"content":"Linux命令有很多，功能十分强大，掌握Linux的基础命令是一个程序员的基本要求。本文概括Linux下的常用命令，包括文件处理、用户权限、系统资源、网络等。 比较常见的如man、ls、cd等本文就不做介绍了，主要介绍一些功能强大的，参数又多的命令，后续将会陆续补充。 ","date":"2023-02-27","objectID":"/commands_in_linux/:0:0","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"系统资源查看 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:0","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"top Top命令用于实时查看Linux下的各个进程占用的系统资源，包括CPU占用率、内存占用率和进程号等 各个参数含义比较容易理解，就是英文缩写，不会的再查手册就好了 下面是主要的交互指令 Ctrl+L 擦除并且重写屏幕。 h或者? 显示帮助画面，给出一些简短的命令总结说明。 k 终止一个进程。 系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 i 忽略闲置和僵死进程。这是一个开关式命令。 q 退出程序。 r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 S 切换到累计模式。 s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 f或者F 从当前显示中添加或者删除项目。 o或者O 改变显示项目的顺序。 l 切换显示平均负载和启动时间信息。 m 切换显示内存信息。 t 切换显示进程和CPU状态信息。 c 切换显示命令名称和完整命令行。 M 根据驻留内存大小进行排序。 P 根据CPU使用百分比大小进行排序。 T 根据时间/累计时间进行排序。 W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:1","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"df Linux df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。 常用组合：df -h ","date":"2023-02-27","objectID":"/commands_in_linux/:1:2","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"ps 常用组合：ps aux 或者 ps -aux 或 ps -ef ","date":"2023-02-27","objectID":"/commands_in_linux/:1:3","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"pstree 查看进程树 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:4","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"pgrep pgrep命令用来查找进程的信息，通常会和kill命令来连用，在指定条件下kill问题进程。 pgrep 参数是进程的名字中的子串 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:5","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"ipcs 用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:6","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"strace 用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:7","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"vmstat 虚拟内存统计。 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:8","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"mpstat 显示各个可用 CPU 的状态统计。 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:9","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"iostat 统计系统 IO。 ","date":"2023-02-27","objectID":"/commands_in_linux/:1:10","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"网络命令 ","date":"2023-02-27","objectID":"/commands_in_linux/:2:0","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"netstat Linux netstat 命令用于显示网络状态。 利用 netstat 指令可让你得知整个 Linux 系统的网络情况。 netstat [-acCeFghilMnNoprstuvVwx][-A\u003c网络类型\u003e][--ip] netstat -a : 列出所有连接 上述命令列出 tcp, udp 和 unix 协议下所有套接字的所有连接。然而这些信息还不够详细，管理员往往需要查看某个协议或端口的具体连接情况。 netstat -at : 使用 -t 选项列出 TCP 协议的连接 netstat -au : 使用 -u 选项列出 UDP 协议的连接 netstat -an: 使用 -n 选项拒绝显示别名，能显示数字的全部转化为数字`` netstat -al : 使用 -l 仅列出在Listen(监听)的服务状态 netstat -ap: 使用 -p 显示建立相关链接的程序名 因此 netstat -tunlp | grep 端口号 可以查看端口情况 ","date":"2023-02-27","objectID":"/commands_in_linux/:2:1","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"ifconfig ","date":"2023-02-27","objectID":"/commands_in_linux/:2:2","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"route ","date":"2023-02-27","objectID":"/commands_in_linux/:2:3","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"nslookup nslookup用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题。nslookup是一个程序的名字，这个程序让因特网服务器管理员或任何的计算机用户输入一个主机名（举例来说，“www.baidu.com”）并发现相应的IP地址。它也会相反的名字查找为一个你指定的 IP 住址找出主机名。 ","date":"2023-02-27","objectID":"/commands_in_linux/:2:4","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"host host也可以用来查看DNS解析结果 ","date":"2023-02-27","objectID":"/commands_in_linux/:2:5","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"lsof list open files 列举打开的文件列表 lsof -i : 端口号 可以查看端口占用情况 ","date":"2023-02-27","objectID":"/commands_in_linux/:2:6","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"文件处理 ","date":"2023-02-27","objectID":"/commands_in_linux/:3:0","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"tar Linux tar（英文全拼：tape archive ）命令用于备份文件。 tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 参数含义: c 表示 create， z 表示使用 gzip， v 表示 view 查看过程， f 指定备份文件， -C 指定要解压的目录, x 表示 extract 解压。t 表示list 列出压缩文件内容 压缩文件 非打包: # touch a.c # tar -czvf test.tar.gz a.c //压缩 a.c文件为test.tar.gz a.c 列出压缩文件内容 # tar -tzvf test.tar.gz -rw-r--r-- root/root 0 2010-05-24 16:51:59 a.c 解压文件 # tar -xzvf test.tar.gz a.c ","date":"2023-02-27","objectID":"/commands_in_linux/:3:1","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"cat cat 是 concatenate的意思 （用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用） cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 cat -n file1 标示文件的行数 more file1 查看一个长文件的内容 head -n 2 file1 查看一个文件的前两行 tail -n 2 file1 查看一个文件的最后两行 tail -n +1000 file1 从1000行开始显示，显示1000行以后的 cat filename | head -n 3000 | tail -n +1000 显示1000行到3000行 cat filename | tail -n +3000 | head -n 1000 从第3000行开始，显示1000(即显示3000~3999行) ","date":"2023-02-27","objectID":"/commands_in_linux/:3:2","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"find find / -name file1 从 ‘/’ 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 ‘user1’ 的文件和目录 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 ","date":"2023-02-27","objectID":"/commands_in_linux/:3:3","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["Linux"],"content":"grep （分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等） grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词\"Aug\" grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以\"Aug\"开始的词汇 grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串\"Aug\" sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 “string1” 替换成 “string2” sed '/^$/d' example.txt 从example.txt文件中删除所有空白行 ","date":"2023-02-27","objectID":"/commands_in_linux/:3:4","tags":["Commands"],"title":"Linux下常用命令","uri":"/commands_in_linux/"},{"categories":["C/C++"],"content":"C++智能指针原理 智能指针在C++11种被真正引入标准库，其实现依赖于以下原理： ","date":"2023-02-10","objectID":"/smart_pointer/:1:0","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"面向对象封装 将指针包装为类，获取资源在构造函数种完成，释放资源在析构函数种完成，保证了资源获取即初始化（RAII）。在离开作用域时，智能指针对象的析构函数自动调用释放资源，无需手动释放。 ","date":"2023-02-10","objectID":"/smart_pointer/:1:1","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"引用计数 维护一个计数器用于追踪指向资源的被引用数，当资源被引用时，计数加一，资源被解引用时，计数减一。只在shared_ptr里使用 ","date":"2023-02-10","objectID":"/smart_pointer/:1:2","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"操作符重载 将指针的引用与解引用运算符重载，使得智能指针表现的行为与普通指针一致。weak_ptr没有重载，不能直接使用 ","date":"2023-02-10","objectID":"/smart_pointer/:1:3","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"为什么需要智能指针？ 智能指针主要可以解决以下场景下的内存管理问题 ","date":"2023-02-10","objectID":"/smart_pointer/:2:0","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"内存泄漏 C++在堆上申请内存后，需要手动对内存进行释放。代码的初创者可能会注意内存的释放，但随着代码协作者加入，或者随着代码日趋复杂，很难保证内存都被正确释放。 尤其是一些代码分支在开发中没有被完全测试覆盖的时候，就算是内存泄漏检查工具也不一定能检查到内存泄漏。 void test_memory_leak(bool open) { A *a = new A(); if(open) { // 代码变复杂过程中，很可能漏了 delete(a); return; } delete(a); return; } ","date":"2023-02-10","objectID":"/smart_pointer/:2:1","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"多线程下对象的析构问题 多线程遇上对象析构，是一个很难的问题，稍有不慎就会导致程序崩溃。因此在对于 C++开发者而言，经常会使用静态单例来使得对象常驻内存，避免析构带来的问题。这势必会造成内存泄露，当单例对象比较大，或者程序对内存非常敏感的时候，就必须面对这个问题了。 先以一个常见的 C++多线程问题为例，介绍多线程下的对象析构问题。 比如我们在开发过程中，经常会在一个 Class 中创建一个线程，这个线程读取外部对象的成员变量。 // 日志上报Class class ReportClass { private: ReportClass() {} ReportClass(const ReportClass\u0026) = delete; ReportClass\u0026 operator=(const ReportClass\u0026) = delete; ReportClass(const ReportClass\u0026\u0026) = delete; ReportClass\u0026 operator=(const ReportClass\u0026\u0026) = delete; private: std::mutex mutex_; int count_ = 0; void addWorkThread(); public: void pushEvent(std::string event); private: static void workThread(ReportClass *report); private: static ReportClass* instance_; static std::mutex static_mutex_; public: static ReportClass* GetInstance(); static void ReleaseInstance(); }; std::mutex ReportClass::static_mutex_; ReportClass* ReportClass::instance_; ReportClass* ReportClass::GetInstance() { // 单例简单实现，非本文重点 std::lock_guard\u003cstd::mutex\u003e lock(static_mutex_); if (instance_ == nullptr) { instance_ = new ReportClass(); instance_-\u003eaddWorkThread(); } return instance_; } void ReportClass::ReleaseInstance() { std::lock_guard\u003cstd::mutex\u003e lock(static_mutex_); if(instance_ != nullptr) { delete instance_; instance_ = nullptr; } } // 轮询上报线程 void ReportClass::workThread(ReportClass *report) { while(true) { // 线程运行过程中，report可能已经被销毁了 std::unique_lock\u003cstd::mutex\u003e lock(report-\u003emutex_); if(report-\u003ecount_ \u003e 0) { report-\u003ecount_--; } usleep(1000*1000); } } // 创建任务线程 void ReportClass::addWorkThread() { std::thread new_thread(workThread, this); new_thread.detach(); } // 外部调用 void ReportClass::pushEvent(std::string event) { std::unique_lock\u003cstd::mutex\u003e lock(mutex_); this-\u003ecount_++; } 使用 ReportClass 的代码如下： ReportClass::GetInstance()-\u003epushEvent(\"test\"); 但当这个外部对象（即ReportClass）析构时，对象创建的线程还在执行。此时线程引用的对象指针为野指针，程序必然会发生异常。 解决这个问题的思路是在对象析构的时候，对线程进行join。 // 日志上报Class class ReportClass { private: //... ~ReportClass(); private: //... bool stop_ = false; std::thread *work_thread_; //... }; // 轮询上报线程 void ReportClass::workThread(ReportClass *report) { while(true) { std::unique_lock\u003cstd::mutex\u003e lock(report-\u003emutex_); // 如果上报停止，不再轮询上报 if(report-\u003estop_) { break; } if(report-\u003ecount_ \u003e 0) { report-\u003ecount_--; } usleep(1000*1000); } } // 创建任务线程 void ReportClass::addWorkThread() { // 保存线程指针，不再使用分离线程 work_thread_ = new std::thread(workThread, this); } ReportClass::~ReportClass() { // 通过join来停止内部线程 stop_ = true; work_thread_-\u003ejoin(); delete work_thread_; work_thread_ = nullptr; } 这种方式看起来没问题了，但是由于这个对象一般是被多个线程使用。假如某个线程想要释放这个对象，但另外一个线程还在使用这个对象，可能会出现野指针问题。就算释放对象的线程将对象释放后将指针置为nullptr，但仍然可能在多线程下在指针置空前被另外一个线程取得地址并使用。 线程A 线程B ReportClass::GetInstance()-\u003eReleaseInstance() ReportClass* report = ReportClass::GetInstance();if (report) { // 此时切换到线程A report-\u003epushEcvent(“test”);} 此种场景下，锁机制已经很难解决这个问题。对于多线程下的对象析构问题，智能指针可谓是神器。接下来我们先对智能指针的基本用法进行说明。 ","date":"2023-02-10","objectID":"/smart_pointer/:2:2","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"智能指针用法 智能指针设计的初衷就是可以帮助我们管理堆上申请的内存，可以理解为开发者只需要申请，而释放交给智能指针。 目前 C++11 主要支持的智能指针为以下几种 unique_ptr shared_ptr weak_ptr 包含在头文件\u003cmemory\u003e中 ","date":"2023-02-10","objectID":"/smart_pointer/:3:0","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"unique_ptr unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr由于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。 概括就是以下两点： 1、unique_ptr不能被复制到另外一个unique_ptr 2、unique_ptr所持有的对象只能通过转移语义将所有权转移到另外一个unique_ptr 如下代码所示： std::unique_ptr\u003cA\u003e a1(new A()); std::unique_ptr\u003cA\u003e a2 = a1;v // 编译报错，不允许复制 std::unique_ptr\u003cA\u003e a3 = std::move(a1); // 可以转移所有权，所有权转义后a1不再拥有任何指针 使用场景如下： class A { public: void do_something() {} }; void test_unique_ptr(bool open) { std::unique_ptr\u003cA\u003e a(new A()); a-\u003edo_something(); if(open) { // 不再需要手动释放内存 return; } // 不再需要手动释放内存 return; } unique_ptr本身拥有的方法主要包括： 1、get() 获取其保存的原生指针，尽量不要使用 2、bool() 判断是否拥有指针 3、release() 释放所管理指针的所有权，返回原生指针。但并不销毁原生指针。 4、reset() 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针 std::unique_ptr\u003cA\u003e a1(new A()); A *origin_a = a1.get(); // 尽量不要暴露原生指针 if(a1) { // a1 拥有指针 } std::unique_ptr\u003cA\u003e a2(a1.release()); // 常见用法，转义拥有权 a2.reset(new A()); // 释放并销毁原有对象，持有一个新对象 a2.reset(); // 释放并销毁原有对象，等同于下面的写法 a2 = nullptr; // 释放并销毁原有对象 ","date":"2023-02-10","objectID":"/smart_pointer/:3:1","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"shared_ptr shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr\u003cint\u003e p4 = new int(1);的写法是错误的 拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。 get函数获取原始指针 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存 注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍 shared_ptr本身拥有的方法主要包括： 1、get() 获取其保存的原生指针，尽量不要使用 2、bool() 判断是否拥有指针 3、reset() 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针 4、unique() 如果引用计数为 1，则返回 true，否则返回 false 5、use_count() 返回引用计数的大小 #include \u003ciostream\u003e#include \u003cmemory\u003e int main() { { std::unique_ptr\u003cint\u003e uptr(new int(10)); // 绑定动态对象 //std::unique_ptr\u003cint\u003e uptr2 = uptr; // 不能赋值 //std::unique_ptr\u003cint\u003e uptr2(uptr); // 不能拷贝 std::unique_ptr\u003cint\u003e uptr2 = std::move(uptr); // 转换所有权 uptr2.release(); // 释放所有权 } // 超出uptr的作用域，内存释放 } ","date":"2023-02-10","objectID":"/smart_pointer/:3:2","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"weak_ptr weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-\u003e,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock() 从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。 由于shared_ptr是通过引用计数来管理原生指针的，那么最大的问题就是循环引用（比如 a 对象持有 b 对象，b 对象持有 a 对象），这样必然会导致内存泄露。而weak_ptr不会增加引用计数，因此将循环引用的一方修改为弱引用，可以避免内存泄露。 weak_ptr可以通过一个shared_ptr创建。 std::shared_ptr\u003cA\u003e a1(new A()); std::weak_ptr\u003cA\u003e weak_a1 = a1; //不增加引用计数 weak_ptr本身拥有的方法主要包括： 1、expired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false 2、use_count() 返回原生指针的引用计数 3、lock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr 4、reset() 将本身置空  std::shared_ptr\u003cA\u003e a1(new A()); std::weak_ptr\u003cA\u003e weak_a1 = a1;//不增加引用计数 if(weak_a1.expired()) { // 如果为true，weak_a1对应的原生指针已经被释放了 } long a1_use_count = weak_a1.use_count(); // 引用计数数量 if(std::shared_ptr\u003cA\u003e shared_a = weak_a1.lock()) { // 此时可以通过shared_a进行原生指针的方法调用 } weak_a1.reset();// 将weak_a1置空 ","date":"2023-02-10","objectID":"/smart_pointer/:3:3","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"智能指针最佳实践 ","date":"2023-02-10","objectID":"/smart_pointer/:4:0","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"智能指针如何选择 在介绍指针如何选择之前，我们先回顾一下这几个指针的特点 1、unique_ptr独占对象的所有权，由于没有引用计数，因此性能较好 2、shared_ptr共享对象的所有权，但性能略差 3、weak_ptr配合shared_ptr，解决循环引用的问题 由于性能问题，那么可以粗暴的理解：优先使用unique_ptr。但由于unique_ptr不能进行复制，因此部分场景下不能使用的。 unique_ptr 的使用场景 unique_ptr一般在不需要多个指向同一个对象的指针时使用。但这个条件本身就很难判断，在我看来可以简单的理解：这个对象在对象或方法内部使用时优先使用unique_ptr。 1、对象内部使用 class TestUnique { private: std::unique_ptr\u003cA\u003e a_ = std::unique_ptr\u003cA\u003e(new A()); public: void process1() { a_-\u003edo_something(); } void process2() { a_-\u003edo_something(); } ~TestUnique() { // 此处不再需要手动删除a_ } }; 2、方法内部使用 void test_unique_ptr() { std::unique_ptr\u003cA\u003e a(new A()); a-\u003edo_something(); } shared_ptr 的使用场景及最佳实践 shared_ptr一般在需要多个执行同一个对象的指针使用。在我看来可以简单的理解：这个对象需要被多个 Class 同时使用的时候。 class B { private: std::shared_ptr\u003cA\u003e a_; public: B(std::shared_ptr\u003cA\u003e\u0026 a): a_(a) {} }; class C { private: std::shared_ptr\u003cA\u003e a_; public: C(std::shared_ptr\u003cA\u003e\u0026 a): a_(a) {} }; std::shared_ptr\u003cB\u003e b_; std::shared_ptr\u003cC\u003e c_; void test_A_B_C() { std::shared_ptr\u003cA\u003e a = std::make_shared\u003cA\u003e(); b_ = std::make_shared\u003cB\u003e(a); c_ = std::make_shared\u003cC\u003e(a); } 在上面的代码中需要注意，我们使用std::make_shared代替new的方式创建shared_ptr。 因为使用new的方式创建shared_ptr会导致出现两次内存申请，而std::make_shared在内部实现时只会申请一个内存。因此建议后续均使用std::make_shared。 如果A想要调用B和C的方法怎么办呢？可否在A中定义B和C的shared_ptr呢？答案是不可以，这样会产生循环引用，导致内存泄露。 此时就需要weak_ptr出场了。 class A { private: std::weak_ptr\u003cB\u003e b_; std::weak_ptr\u003cC\u003e c_; public: void do_something() {} void set_B_C(const std::shared_ptr\u003cB\u003e\u0026 b, const std::shared_ptr\u003cC\u003e\u0026 c) { b_ = b; c_ = c; } }; a-\u003eset_B_C(b_, c_); 如果想要在A内部将当前对象的指针共享给其他对象，需要怎么处理呢？ class D { private: std::shared_ptr\u003cA\u003e a_; public: std::shared_ptr\u003cA\u003e\u0026 a): a_(a) {} }; class A { // 上述代码省略 public: void new_D() { // 错误方式，用this指针重新构造shared_ptr，将导致二次释放当前对象 std::shared_ptr\u003cA\u003e this_shared_ptr1(this); std::unique_ptr\u003cD\u003e d1(new D(this_shared_ptr1)); } }; 如果采用this指针重新构造shared_ptr是肯定不行的，因为重新创建的shared_ptr与当前对象的shared_ptr没有关系，没有增加当前对象的引用计数。这将导致任何一个shared_ptr计数为 0 时提前释放了对象，后续操作这个释放的对象都会导致程序异常。 此时就需要引入shared_from_this。对象继承了enable_shared_from_this后，可以通过shared_from_this()获取当前对象的shared_ptr指针。 class A: public std::enable_shared_from_this\u003cA\u003e { // 上述代码省略 public: void new_D() { // 错误方式，用this指针重新构造shared_ptr，将导致二次释放当前对象 std::shared_ptr\u003cA\u003e this_shared_ptr1(this); std::unique_ptr\u003cD\u003e d1(new D(this_shared_ptr1)); // 正确方式 std::shared_ptr\u003cA\u003e this_shared_ptr2 = shared_from_this(); std::unique_ptr\u003cD\u003e d2(new D(this_shared_ptr2)); } }; ","date":"2023-02-10","objectID":"/smart_pointer/:4:1","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"智能指针的错误使用方法 1、使用智能指针托管的对象，尽量不要再使用原生指针 很多开发同学在最开始使用智能指针的时候，对同一个对象会混用智能指针和原生指针，导致程序异常。 void incorrect_smart_pointer1() { A*a = new A(); std::unique_ptr\u003cA\u003e unique_ptr_a(a); // 此处将导致对象的二次释放 delete a; } 2、不要把一个原生指针交给多个智能指针管理 如果将一个原生指针交个多个智能指针，这些智能指针释放对象时会产生对象的多次销毁 void incorrect_smart_pointer2() { A* a = new A(); std::unique_ptr\u003cA\u003e unique_ptr_a1(a); std::unique_ptr\u003cA\u003e unique_ptr_a2(a); // 此处将导致对象的二次释放 } 3、尽量不要使用 get()获取原生指针 void incorrect_smart_pointer3() { std::shared_ptr\u003cA\u003e shared_ptr_a1 = std::make_shared\u003cA\u003e(); A *a= shared_ptr_a1.get(); std::shared_ptr\u003cA\u003e shared_ptr_a2(a); // 此处将导致对象的二次释放 delete a; // 此处也将导致对象的二次释放 } 4、不要将 this 指针直接托管智能指针 class E { void use_this() { //错误方式，用this指针重新构造shared_ptr，将导致二次释放当前对象 std::shared_ptr\u003cE\u003e this_shared_ptr1(this); } }; std::shared_ptr\u003cE\u003e e = std::make_shared\u003cE\u003e(); 5、智能指针只能管理堆对象，不能管理栈上对象 栈上对象本身在出栈时就会被自动销毁，如果将其指针交给智能指针，会造成对象的二次销毁 void incorrect_smart_pointer5() { int int_num = 3; std::unique_ptr\u003cint\u003e int_unique_ptr(\u0026int_num); } ","date":"2023-02-10","objectID":"/smart_pointer/:4:2","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"解决多线程下对象析构的问题 有了智能指针之后，我们就可以使用智能指针解决多线程下的对象析构问题。 我们使用shared_ptr管理ReportClass。并将 weak_ptr传给子线程，子线程会判断外部的ReportClass是否已经被销毁，如果没有被销毁会通过weak_ptr换取shared_ptr，否则线程退出。解决了外部对象销毁，内部线程使用外部对象的野指针的问题。 // 日志上报Class class ReportClass: public std::enable_shared_from_this\u003cReportClass\u003e { //... private: static void workThread(std::weak_ptr\u003cReportClass\u003e weak_report_ptr); private: static std::shared_ptr\u003cReportClass\u003e instance_; static std::mutex static_mutex_; public: static std::shared_ptr\u003cReportClass\u003e GetInstance(); static void ReleaseInstance(); }; std::mutex ReportClass::static_mutex_; std::shared_ptr\u003cReportClass\u003e ReportClass::instance_; std::shared_ptr\u003cReportClass\u003e ReportClass::GetInstance() { // 单例简单实现，非本文重点 std::lock_guard\u003cstd::mutex\u003e lock(static_mutex_); if (!instance_) { instance_ = std::shared_ptr\u003cReportClass\u003e(new ReportClass()); instance_-\u003eaddWorkThread(); } return instance_; } void ReportClass::ReleaseInstance() { std::lock_guard\u003cstd::mutex\u003e lock(static_mutex_); if(instance_) { instance_.reset(); } } // 轮询上报线程 void ReportClass::workThread(std::weak_ptr\u003cReportClass\u003e weak_report_ptr) { while(true) { std::shared_ptr\u003cReportClass\u003e shared_report_ptr = weak_report_ptr.lock(); if(!shared_report_ptr) { return; } std::unique_lock\u003cstd::mutex\u003e(shared_report_ptr-\u003emutex_); if(shared_report_ptr-\u003ecount_ \u003e 0) { shared_report_ptr-\u003ecount_--; } usleep(1000*1000); } } // 创建任务线程 void ReportClass::addWorkThread() { std::weak_ptr\u003cReportClass\u003e weak_report_ptr = shared_from_this(); std::thread work_thread(workThread, weak_report_ptr); work_thread.detach(); } // 外部调用 void ReportClass::pushEvent(std::string event) { std::unique_lock\u003cstd::mutex\u003e lock(mutex_); this-\u003ecount_++; } 并且在多个线程使用的时候，由于采用shared_ptr管理，因此只要有shared_ptr持有对象，就不会销毁对象，因此不会出现多个线程使用时对象被析构的情况。只有该对象的所有shared_ptr都被销毁的时候，对象的内存才会被释放，保证的对象析构的安全。 ","date":"2023-02-10","objectID":"/smart_pointer/:4:3","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"智能指针设计与实现 　下面是一个简单智能指针的demo。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类。所有的智能指针都会重载 -\u003e 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。 #include \u003ciostream\u003e#include \u003cmemory\u003e template\u003ctypename T\u003e class SmartPointer { private: T* _ptr; size_t* _count; public: SmartPointer(T* ptr = nullptr) : _ptr(ptr) { if (_ptr) { _count = new size_t(1); } else { _count = new size_t(0); } } SmartPointer(const SmartPointer\u0026 ptr) { if (this != \u0026ptr) { this-\u003e_ptr = ptr._ptr; this-\u003e_count = ptr._count; (*this-\u003e_count)++; } } SmartPointer\u0026 operator=(const SmartPointer\u0026 ptr) { if (this-\u003e_ptr == ptr._ptr) { return *this; } if (this-\u003e_ptr) { (*this-\u003e_count)--; if (this-\u003e_count == 0) { delete this-\u003e_ptr; delete this-\u003e_count; } } this-\u003e_ptr = ptr._ptr; this-\u003e_count = ptr._count; (*this-\u003e_count)++; return *this; } T\u0026 operator*() { assert(this-\u003e_ptr == nullptr); return *(this-\u003e_ptr); } T* operator-\u003e() { assert(this-\u003e_ptr == nullptr); return this-\u003e_ptr; } ~SmartPointer() { (*this-\u003e_count)--; if (*this-\u003e_count == 0) { delete this-\u003e_ptr; delete this-\u003e_count; } } size_t use_count(){ return *this-\u003e_count; } }; int main() { { SmartPointer\u003cint\u003e sp(new int(10)); SmartPointer\u003cint\u003e sp2(sp); SmartPointer\u003cint\u003e sp3(new int(20)); sp2 = sp3; std::cout \u003c\u003c sp.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c sp3.use_count() \u003c\u003c std::endl; } //delete operator } ","date":"2023-02-10","objectID":"/smart_pointer/:5:0","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"Reference C++ 智能指针最佳实践\u0026源码分析 - 极术社区 - 连接开发者与智能计算生态 (aijishu.com) C++11中智能指针的原理、使用、实现 - wxquare - 博客园 (cnblogs.com) 【C++】智能指针的原理和实现_51CTO博客_c++智能指针 ","date":"2023-02-10","objectID":"/smart_pointer/:6:0","tags":["SmartPoint"],"title":"C++智能指针","uri":"/smart_pointer/"},{"categories":["C/C++"],"content":"c++作为面向对象的语言，主要有三大特性：继承、封装、多态。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时绑定，要么试图做到运行时绑定。因此C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。 ","date":"2023-02-06","objectID":"/virtual_func/:0:0","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"虚函数的内存分布 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其内容真实反映实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。因此有必要知道虚函数在内存中的分布。 class A { public: virtual void v_a(){} virtual ~A(){} int64_t _m_a; }; int main(){ A* a = new A(); return 0; } 如以上代码所示，在C++中定义一个对象 A，那么在内存中的分布大概是如下图这个样子。 首先在主函数的栈帧上有一个 A 类型的指针指向堆里面分配好的对象 A 实例。 对象 A 实例的头部是一个 vtable 指针，紧接着是 A 对象按照声明顺序排列的成员变量。（当我们创建一个对象时，便可以通过实例对象的地址，得到该实例的虚函数表，从而获取其函数指针。） vtable 指针指向的是代码段中的 A 类型的虚函数表中的第一个虚函数起始地址。 虚函数表的结构其实是有一个头部的，叫做 vtable_prefix ，紧接着是按照声明顺序排列的虚函数。 注意到这里有两个虚析构函数，因为对象有两种构造方式，栈构造和堆构造，所以对应的，对象会有两种析构方式，其中堆上对象的析构和栈上对象的析构不同之处在于，栈内存的析构不需要执行 delete 函数，会自动被回收。 typeinfo 存储着 A 的类基础信息，包括父类与类名称，C++关键字 typeid 返回的就是这个对象。 typeinfo 也是一个类，对于没有父类的 A 来说，当前 typeinfo 是 class_type_info 类型的，从虚函数指针指向的vtable 起始位置可以看出。 通过之前的分析可以知道其实传统认为的虚函数表并不是单独存在而是虚表的一部分，如下图所示  紫色线框中的内容仅限于虚拟继承的情形（若无虚拟继承，则无此内容） “offset to top”是指到对象起始地址的偏移值，只有多重继承的情形才有可能不为0，单继承或无继承的情形都为0。 “RTTI information”是一个对象指针，它用于唯一地标识该类型。 “virtual function pointers”也就是我们之前理解的虚函数表，其中存放着虚函数指针列表。 Virtual table（虚表）只实现了虚拟函数的一半机制,如果只有这些是没有用的。只有用某种方法指出每个对象对应的 vtbl 时,它们才能使用。这是 virtual table pointer 的工作,它来建立这种联系。 每个声明了虚函数的对象都带有它,它是一个看不见的数据成员,指向对应类的virtual table。这个看不见的数据成员也称为 vptr,被编译器加在对象里,位置只有才编译器知道。 ","date":"2023-02-06","objectID":"/virtual_func/:1:0","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"虚函数实现原理 ","date":"2023-02-06","objectID":"/virtual_func/:2:0","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"虚函数的调用过程 当调用一个虚函数时，首先通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。其中被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过虚表vtbl（virtual table）和虚表指针vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl核心就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。 在有继承关系时(子类相对于其直接父类) 一般继承时，子类的虚函数表中先将父类虚函数放在前，再放自己的虚函数指针。 如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置。 在多继承的情况下，每个父类都有自己的虚表，子类的成员函数被放到了第一个父类的表中。，也就是说当类在多重继承中时，其实例对象的内存结构并不只记录一个虚函数表指针。基类中有几个存在虚函数，则子类就会保存几个虚函数表指针 class A{ private: uint64_t a; public: virtual void A_a(){std::cout \u003c\u003c __func__;} }; class C{ private: uint64_t c; public: virtual void C_a(){std::cout \u003c\u003c __func__;} }; class D:public A,public C{ private: uint64_t d; public: virtual void D_a(){std::cout \u003c\u003c __func__;} }; ","date":"2023-02-06","objectID":"/virtual_func/:2:1","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"性能分析 调用性能 从前面虚函数的调用过程可知。当调用虚函数时过程如下（引自More Effective C++）: 通过对象的 vptr 找到类的 vtbl。 这是一个简单的操作,因为编译器知道在对象内 哪里能找到 vptr(毕竟是由编译器放置的它们)。因此这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。 找到对应 vtbl 内的指向被调用函数的指针。 这也是很简单的, 因为编译器为每个虚函数在 vtbl 内分配了一个唯一的索引。这步的代价只是在 vtbl 数组内的一个偏移。 调用第二步找到的的指针所指向的函数。 在单继承的情况下 调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。 在多继承的情况 由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。虚函数运行时所需的代价主要是虚函数不是内联函数。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。 空间占用 在上面的虚函数实现原理部分，可以看到为了实现运行时多态机制，编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，所以虚函数的一个代价就是会增加类的体积。在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。 如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。 在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。 由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。 ","date":"2023-02-06","objectID":"/virtual_func/:2:2","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"虚函数应用的注意事项 ","date":"2023-02-06","objectID":"/virtual_func/:3:0","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"内联函数 (inline) 虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要频繁使用和调用的小函数非常有用。默认地，类中定义的所有函数，除了虚函数之外，会隐式地或自动地当成内联函数(注意：内联只是对于编译器的一个建议，编译器可以自己决定是否进行内联). 无论何时，使用基类指针或引用来调用虚函数，它都不能为内联函数(因为调用发生在运行时)。但是，无论何时，使用类的对象(不是指针或引用)来调用时，可以当做是内联，因为编译器在编译时确切知道对象是哪个类的。 ","date":"2023-02-06","objectID":"/virtual_func/:3:1","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"静态成员函数 (static) static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。此外静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针，从而导致两者调用方式不同。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。虚函数的调用关系：this -\u003e vptr -\u003e vtable -\u003evirtual function，对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。 ","date":"2023-02-06","objectID":"/virtual_func/:3:2","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"构造函数 (constructor) 虚函数基于虚表vtable（内存空间），构造函数 (constructor) 如果是virtual的，调用时也需要根据vtable寻找，但是constructor是virtual的情况下是找不到的，因为constructor自己本身都不存在了，创建不到class的实例，没有实例class的成员（除了public static/protected static for friend class/functions，其余无论是否virtual）都不能被访问了。此外构造函数不仅不能是虚函数。而且在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好,多态是被disable的。 ","date":"2023-02-06","objectID":"/virtual_func/:3:3","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"析构函数 (deconstructor) 对于可能作为基类的类的析构函数要求就是virtual的。因为如果不是virtual的，派生类析构的时候调用的是基类的析构函数，而基类的析构函数只要对基类部分进行析构，从而可能导致派生类部分出现内存泄漏问题。 ","date":"2023-02-06","objectID":"/virtual_func/:3:4","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["C/C++"],"content":"纯虚函数 析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。 ","date":"2023-02-06","objectID":"/virtual_func/:3:5","tags":["virtual function"],"title":"C++中的虚函数","uri":"/virtual_func/"},{"categories":["Algorithm"],"content":"八大排序时空复杂度表 Method Average Worst Best Space Stable 直接插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 希尔排序 $O(n^{1-2})$ – – $O(1)$ 不稳定 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 快速排序 $O(nlog_2n)$ $O(n^2)$ $O(nlog_2n)$ $O(log_2n)$ 不稳定 直接选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(1)$ 不稳定 归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(n)$ 稳定 基数排序 $O(d(n+r))$ $O(d(n+r))$ $O(d(n+r))$ $O(n+rd)$ 稳定 注： 1.希尔排序的时间复杂度和增量的选择有关。 2.基数排序的复杂度中，$r$代表关键字的基数，$d$代表长度，$n$表示关键字的个数。 下面分别介绍这些算法的简单实现，由于每种算法都有若干的优化版本，本文只列出常见的实现，若要看进阶的可以参考:力扣-排序算法全解析 另外按照算法的操作特性，可以分为比较排序和非比较排序，比较排序中的若干种排序又可以分为插入排序（直接插入排序、希尔排序）和交换排序（冒泡排序、快速排序）以及选择排序（直接选择排序、堆排序）。非比较排序有计数排序，桶排序等 参考： 各类排序算法生成与测试样例代码 ","date":"2022-05-09","objectID":"/sorts/:1:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"直接插入排序(Direct Insert Sort) 外层循环每趟确定一个数的最终位置，内层循环每次从外层循环的位置往前寻找合适的插入位置。合适指的是，第一个顺序对的位置即满足nums[j-1] \u003c nums[j]的j的位置 vector\u003cint\u003e insert_sort(vector\u003cint\u003e\u0026 nums) { for (int i = 1; i \u003c nums.size(); ++i) { int j = i; while (j \u003e= 1 \u0026\u0026 nums[j] \u003c nums[j - 1]) { swap(nums[j], nums[j - 1]); --j; } } return nums; } ","date":"2022-05-09","objectID":"/sorts/:2:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"希尔排序(Shell Sort) vector\u003cint\u003e shell_sort(vector\u003cint\u003e\u0026 nums) { // 找到符合条件的knuth序列的最大值 int max_knuth_num = 1; while (max_knuth_num \u003c= nums.size() / 3) { max_knuth_num = max_knuth_num * 3 + 1; } // 增量按照 Knuth 序列规则依次递减 for (int gap = max_knuth_num; gap \u003e 0; gap = (gap - 1) / 3) { // 从gap开始遍历到结尾，= for (int i = gap; i \u003c nums.size(); ++i) { int cur_num = nums[i]; int pre_index = i - gap; // 对每个当前遍历的点cur_num，使用插入排序从后往前调整其前面的间隔序列 while (pre_index \u003e= 0 \u0026\u0026 cur_num \u003c nums[pre_index]) { // 向后挪动位置 nums[pre_index + gap] = nums[pre_index]; pre_index -= gap; } // 坐下来 nums[pre_index + gap] = cur_num; } } return nums; } ","date":"2022-05-09","objectID":"/sorts/:3:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"冒泡排序(Bubble Sort) 外层循环每次确定一个数的最终位置，内层循环从头开始每次比较相邻的两个数，大的往后冒泡，内层循环结束后，当前遍历集合的最大数已经“冒泡”到了末尾。 vector\u003cint\u003e bubble_sort(vector\u003cint\u003e\u0026 nums) { bool swapped; for (int i = 1; i \u003c nums.size(); ++i) { swapped = false; for (int j = 1; j \u003c nums.size() - i + 1; ++j) { if (nums[j] \u003c nums[j - 1]) { swap(nums[j], nums[j - 1]); swapped = true; } } if (!swapped) break; } return nums; } ","date":"2022-05-09","objectID":"/sorts/:4:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"快速排序(Quick Sort) 快速排序使用了递归操作，所以其空间复杂度有所增加，但是时间复杂度更占据优势，也是其名字的由来。快速排序不适合已经大部分有序的情况，这样会增加遍历操作，甚至时间复杂度上升至$O(n^2)$ 。考虑这种情况，我们在每次划分的时候随机选择一个数进行交换，可以使得数组更混乱。 其思想是，每一趟排序确定一个数的最终位置，在该位置上，左边的数都小于该数，右边的数都大于该数，由此，我们也称这一趟排序为一次划分(partition)， 每次划分时，都会不断地找到从左往右第一个比该数大的数a和从右往左第一个比该数小的数b，然后将两者交换一下，最终满足条件。在该次划分后，确定了一个数的最终位置pos，那么可以递归地对pos左边的数和pos右边的数进行划分。最后每个数都到了其实际的位置，排序就完成了。 // 划分函数，返回已经有序的位置 int partition(vector\u003cint\u003e\u0026 nums, int left, int right) { // 随机选择一个位置交换 std::random_device rd; std::mt19937 mt(rd()); std::uniform_int_distribution\u003cint\u003e dist(left, right); int pos = dist(mt); swap(nums[left], nums[pos]); int pivot = nums[left]; while (left \u003c right) { while (left \u003c right \u0026\u0026 nums[right] \u003e pivot) right--; nums[left] = nums[right]; while (left \u003c right \u0026\u0026 nums[left] \u003c= pivot) left++; nums[right] = nums[left]; } nums[left] = pivot; return left; } void my_qsort(vector\u003cint\u003e\u0026 nums, int left, int right) { // 保证区间内至少有两个元素，left 和 right if (left \u003e= right) return; int pivot_pos = partition(nums, left, right); my_qsort(nums, left, pivot_pos - 1); my_qsort(nums, pivot_pos + 1, right); } vector\u003cint\u003e quick_sort(vector\u003cint\u003e\u0026 nums) { my_qsort(nums, 0, nums.size() - 1); return nums; } ","date":"2022-05-09","objectID":"/sorts/:5:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"直接选择排序(Direct Select Sort) 外层循环每次确定一个数的最终位置，内层循环每次从未定序数的集合种选出其最小值然后放到其最终的位置。 vector\u003cint\u003e select_sort(vector\u003cint\u003e\u0026 nums) { for (int i = 0; i \u003c nums.size(); ++i) { int min_idx = i; for (int j = i + 1; j \u003c nums.size(); ++j) { if (nums[j] \u003c nums[min_idx]) { min_idx = j; } } swap(nums[i], nums[min_idx]); } return nums; } ","date":"2022-05-09","objectID":"/sorts/:6:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"堆排序(Heap Sort) // 自顶向下调整堆 void adjust_down(vector\u003cint\u003e\u0026 nums, int k, int max_len) { // 每调整一次堆，最大的元素就在第一个位置了 // int num = nums[k]; // 先使 i 指向左子元素，然后指向左右子元素中较大值 for (int i = k * 2 + 1; i \u003c max_len; i = i * 2 + 1) { // 左右子结点比较 if (i + 1 \u003c max_len \u0026\u0026 nums[i] \u003c nums[i + 1]) { ++i; } if (nums[i] \u003c nums[k]) { break; } else { // 子结点比当前结点大要交换一下，然后将该子结点作为下一个遍历结点 swap(nums[k], nums[i]); k = i; } } } // 建堆，默认大顶堆 void build_heap(vector\u003cint\u003e\u0026 nums) { int size = nums.size(); // 非叶子结点遍历 for (int i = size / 2; i \u003e= 0; --i) { adjust_down(nums, i, size); } } // 堆排序, Worst: O(n^2), Best: O(n) Avg: O(nlog(n)) 稳定 vector\u003cint\u003e heap_sort(vector\u003cint\u003e\u0026 nums) { // 从小到大，可以建大根堆，将最大元素依次取出放到后面 build_heap(nums); for (int i = nums.size() - 1; i \u003e 0; --i) { // n-1趟排序，将堆顶最大元素与第i个位置元素交换，大元素就依次置后了 swap(nums[0], nums[i]); // 重新调整堆，限制范围缩小以保护置后的大元素，从根结点调整 adjust_down(nums, 0, i); } return nums; } ","date":"2022-05-09","objectID":"/sorts/:7:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"归并排序(Merge Sort) void my_merge_sort(vector\u003cint\u003e\u0026 nums, int left, int right) { if (left \u003e= right) return; int mid = left + (right - left) / 2; my_merge_sort(nums, left, mid); my_merge_sort(nums, mid + 1, right); int i = left, j = mid + 1, k = 0, temp[right - left + 1]; while (i \u003c= mid \u0026\u0026 j \u003c= right) { temp[k++] = nums[i] \u003c= nums[j] ? nums[i++] : nums[j++]; } while (i \u003c= mid) temp[k++] = nums[i++]; while (j \u003c= right) temp[k++] = nums[j++]; for (k = 0, i = left; i \u003c= right; ++k, ++i) { nums[i] = temp[k]; } } // 归并排序, Worst: O(n^2), Best: O(n) Avg: O(nlog(n)) 稳定 vector\u003cint\u003e merge_sort(vector\u003cint\u003e\u0026 nums) { my_merge_sort(nums, 0, nums.size() - 1); return nums; } ","date":"2022-05-09","objectID":"/sorts/:8:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"基数排序(Radix Sort) 下面实现的版本可以包含有负数的情况，将基数进行加9处理 vector\u003cint\u003e radix_sort(vector\u003cint\u003e\u0026 nums) { int max = 0; // 找出位数最多的数 for (int num : nums) { if (abs(num) \u003e max) { max = abs(num); } } // 计算最长位数 int max_digit_len = 0; while (max != 0) { ++max_digit_len; max /= 10; } // 使用计数排序法对基数进行排序，下标[0, 18]对应[-9, 9] vector\u003cint\u003e counting(19); vector\u003cint\u003e result(nums.size()); int dev = 1; for (int i = 0; i \u003c max_digit_len; ++i) { for (int num : nums) { // 下标调整 int radix = num / dev % 10 + 9; ++counting[radix]; } for (int j = 1; j \u003c counting.size(); ++j) { counting[j] += counting[j - 1]; } // 使用倒序遍历的方式完成计数排序 for (int j = nums.size() - 1; j \u003e= 0; --j) { int radix = nums[j] / dev % 10 + 9; result[--counting[radix]] = nums[j]; } // 计数排序完成后，将结果拷贝回 nums 数组 std::copy(result.begin(), result.end(), nums.begin()); std::fill(counting.begin(), counting.end(), 0); dev *= 10; } return nums; } ","date":"2022-05-09","objectID":"/sorts/:9:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["Algorithm"],"content":"计数排序(Counting Sort) 计数排序就是一种时间复杂度为 $O(n)$ 的排序算法，该算法于 19541954 年由 Harold H. Seward 提出。在对一定范围内的整数排序时，它的复杂度为 $O(n+k)$（其中 k 是整数的范围大小） 用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 $O(n+k)$。 // 计数排序, Worst: O(n+k), k 表示数据范围大小。 本实现方式稳定 vector\u003cint\u003e counting_sort(vector\u003cint\u003e\u0026 nums) { if (nums.size() \u003c= 1) return{}; int max = nums[0]; int min = nums[0]; for (int i = 1; i \u003c nums.size(); ++i) { if (nums[i] \u003e max) max = nums[i]; else if (nums[i] \u003c min) min = nums[i]; } int range = max - min + 1; vector\u003cint\u003e counting(range, 0); for (int num : nums) { counting[num - min]++; } // 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。 // 我们将 counting[0] 先减去 1，后续 counting 直接累加即可 counting[0]--; for (int i = 1; i \u003c range; ++i) { counting[i] += counting[i - 1]; } vector\u003cint\u003e result(nums.size()); for (int i = nums.size() - 1; i \u003e= 0; --i) { // counting[arr[i] - min] 表示此元素在结果数组中的下标 result[counting[nums[i] - min]] = nums[i]; // 更新 counting[arr[i] - min]，指向此元素的前一个下标 counting[nums[i] - min]--; } for (int i = 0; i \u003c nums.size(); ++i) { nums[i] = result[i]; } return nums; } ","date":"2022-05-09","objectID":"/sorts/:10:0","tags":["sort"],"title":"排序算法","uri":"/sorts/"},{"categories":["C/C++"],"content":"C语言IO C语言定义了一套跨平台的带缓冲的输入输出函数，相对于Unix系统I/O，我们称之为标准I/O。标准I/O 库在用户空间维护了自己的 stdio 缓冲区，所以标准I/O 是带有缓存的，而文件 I/O 在用户空间是不带有缓存的，所以在性能、效率上，标准I/O 要优于 文件I/O。 理解上述概念后，就知道了由于标准I/O带有缓存区，所以标准I/O相关函数都不可避免的要显示提供一个缓存区buffer，这个buffer 一般是一个指针，指向一块连续的内存，其最常见的形式是字节数组，因为字节是表示存储的最小单元，但也可以是其类型的数组。另外，为了知道缓冲区内部数据的多少，我们往往还需要一个参数表示缓冲区中要写入或读取的数据的数量。由于我们只是传入了缓冲区的指针，对于缓冲区内部单个数据的大小也要指定，通过单个数据大小和数据数量我们就间接指定了缓冲区内进行操作的数据大小了。总结一下，主要的参数有如下： void *buffer: 指向缓冲区的指针，可以是任意类型 size_t size ：缓冲区内每个对象的大小（字节为单位） size_t count: 需要进行操作的对象数量 FILE *stream: 需要进行操作的文件流 C语言中，头文件 \u003cstdio.h\u003e 提供了通用的文件操作函数以支持窄字符的的输入输出 ，而 \u003cwchar.h\u003e 头文件则提供了支持宽字符的输入输出。 I/O流操作有两个重要的数据结构，一个是 FILE 类型的结构体表示，我们能通过FILE* 类型的指针访问和操作其关联的流。每个流都与一个外部物理设备（文件、标准输入流、打印机、串行端口等）相对应。另一个就是fpos_t，表示文件中位置和状态的结构类型，能够在文件中唯一指定一个位置和多字节解析器状态。 C标准库中有三个预定义标准流： stdin:标准输入流 stdout:标准输出流 stderr标准错误输出流 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:0","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"文件访问 主要有如下几个函数： FILE *fopen( const char *filename, const char *mode ); : 用于打开文件，返回指向FILE*结构的对应的文件指针 int fclose(FILE *stream );：用于关闭打开的文件，成功返回0否则返回EOF int fflush(FILE *stream ); : 对于输出流（以及输出最后一个操作的更新流），将任何未写入的数据从流的缓冲区写入关联的输出设备。对于输入流（以及输入最后一个操作的更新流），行为是未定义的。如果 stream 是空指针，则所有打开的输出流都将被刷新，包括在库包中操作或程序无法直接访问的输出流。 setbuf：手动设置缓冲区大小 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:1","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"直接输入输出 size_t fread(void *buffer, size_t size, size_t count, FILE *stream ); 用于从指定的流中读取count个size大小的对象到buffer中，返回读取成功的字节数 size_t fwrite(const void *buffer, size_t size, size_t count, FILE *stream ); 用于将buffer中count个size大小的对象写入到指定的流中，返回写入成功的字节数 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:2","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"未格式化输入输出 输入输出单个字符 int fgetc( FILE *stream );/int getc( FILE *stream ); : 成功返回字符对应的int值，否则返回EOF int getchar(void); 等价于getc(stdin) int fputc(int ch, FILE *stream)/int putc(int ch, FILE *stream):成功返回字符对应的int值，否则返回EOF并在流中设置error int putchar(int ch); 等价于putc(ch, stdout); 输入输出字符串 char *fgets(char *str, int count, FILE* stream); 从给定的文件流中读取最多count - 1个字符并将其存储到str指向的字符数组中。当解析到换行符时就会停止，这时str会包含该换行符，或者当检测到EOF标记时也会停止。如果读取中没有发生错误，那么会在结尾写入一个空字符。 int fputs(const char *str, FILE *stream); 将str中每个非空字符写入输出流stream,就像一致重复地在执行fputc. 结尾的空字符不会别写入 char *gets_s( char *str, rsize_t n ); / char *gets( char *str );从stdin中读取最多count - 1个字符并将其存储到str指向的字符数组中 . 当解析到换行符或者EOF标记时停止，如果读取中没有发生错误，那么会在结尾写入一个空字符。 如果碰到换行符，则会直接丢弃，且不会被计算到写入的字符数量中 int puts( const char *str ); 将str中每个非空字符写入stdout,然后追加一个换行符，就像一致重复地在执行fgetc. 结尾的空字符不会别写入 按行读取 ssize_t getline(char **lineptr, size_t *n, FILE *stream); 等价于getdelim(lineptr, n, '\\n', stream) ssize_t getdelim(char ** restrict lineptr, size_t* restrict n, int delimiter, FILE* stream); : 像fgetc一样从流stream中读取字符，直到遇到分隔符delimiter, 将读取到的字符串存储到lineptr指向的地址，自动增加其大小，就好像对输入使用了realloc一样，存储的字符包含了分隔符，并且添加了一个空字符在结尾。成功返回存储在buffer中的字符数量，包含分隔符，但是不包括空字符。错误则返回-1并在流中设置feof和ferror ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:3","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"格式化输入输出 int scanf( const char*format, ... );从stdin中读取输入 int fscanf(FILE *stream, const char *format, ... ); 从stream中读取输入 int sscanf( const char *buffer, const char *format, ... );: 从buffer中按照格式输入 int printf( const char *format, ... ); 输出到stdout int fprintf(FILE *stream, const char *format, ... ); 输出到stream int sprintf( char *buffer, const char *format, ... ); 输出到buffer int snprintf( char *restrict buffer, size_t bufsz, const char *restrict format, ... ); 按照格式format写入buffer 指定长度bufsz防止缓冲区溢出，更推荐这个 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:4","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"文件定位 long ftell(FILE *stream ); 返回流中的位置指示器， stream 如果流以二进制模式打开，那么这个函数返回文件中的字节数，从头开始计数 int fseek(FILE *stream, long offset, int origin ); 设置文件的位置指示器，origin表示起始位置，offert表示偏移量。 origin有SEEK_SET、SEEK_CUR和SEEK_END ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:5","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"错误处理 void clearerr(FILE *stream ); 重置错误标志和EOF指示器 int feof(FILE *stream ); 检查是否到达文件末尾，非零就是到了，0就是没 int ferror( FILE *stream ); 检查流是否出现错误 void perror( const char *s ); 打印错误码errno对应的字符描述到stdout ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:6","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"若干宏常量 EOF, FOPEN_MAX,FILENAME_MAX,BUFSIZ ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:7","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"示例 文件复制 #include\u003cstdio.h\u003e#include\u003cstring.h\u003e#include\u003cstdlib.h\u003e int main() { FILE* fpr = fopen(\"file.txt\", \"r+\"); if (fpr == NULL) { printf(\"Error of opening a file : file.txt\\n\"); exit(1); } FILE* fpw = fopen(\"newfile.txt\", \"w+\"); if (fpw == NULL) { printf(\"Error of opening a file : newfile.txt\\n\"); exit(1); } size_t len = 0; char buf[BUFSIZ]; memset(buf, 0, BUFSIZ); while ((len = fread(buf, sizeof(char), BUFSIZ, fpr)) \u003e 0) { fwrite(buf, sizeof(char), len, fpw); } printf(\"copy file success!\"); fclose(fpw); fclose(fpr); return 0; } 测试 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring.h\u003evoid test_getchar() { char c = getchar(); printf(c == '\\n' || c == ' ' || c == '\\t' ? \"输入的字符是换行或空格\" : \"输入的字符是：%c\", c); } void test_fgetc() { FILE* f = fopen(\"file.txt\", \"r\"); if (f == NULL) { printf(\"open file error\\n\"); } char buf[BUFSIZ]; memset(buf, 0, BUFSIZ); int i = 0; int val = 0; while ((val = fgetc(f)) != '\\n') { buf[i++] = val; } buf[i++] = '\\0'; printf(\"从文件file.txt中读取到的第一行字符串为: %s\", buf); } void test_fgets() { FILE* f = fopen(\"file.txt\", \"r\"); if (f == NULL) { printf(\"open file error\\n\"); } char buf[BUFSIZ]; memset(buf, 0, BUFSIZ); while (fgets(buf, BUFSIZ, f) != NULL) { printf(\"%s\", buf); } if (feof(f)) { puts(\"End of File!\"); } } int main() { test_getchar(); test_fgetc(); test_fgets(); return 0; } ","date":"2022-05-06","objectID":"/c_and_cpp_io/:1:8","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"C++IO流 C++ IO Streams and File Input/Output (ntu.edu.sg) C++把输入和输出看作字节流，输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。对于面向文本的程序来说， 每个字节代表一个字符，更通俗地说，字节可以构成字符或数值数据的二进制表示。 IO操作的过程中，任何需要被传递的数据，在经过IO类库处理前后是不同的。这样，我们可以把数据的表示分为两种：内部表示和外部表示。 数据的内部表示便于程序进行数据处理。典型的内部表示有：整型数的二进制表示、浮点数的IEEE表示、字符的ASCII或Unicode编码表示。数据的外部表示则根据不同的外部设备的需要，有具体不同的表现形式。如果外部数据表示是可读的字符序列，则称为文本IO，否则为二进制IO。标准IO流的主要目的是支持文本IO，不直接支持二进制IO。 虽然IO流是以流的方式进行数据传递，但这并不表明传递的数据不能有任何结构，而是指IO流的概念是以流的方式进行输入输出，所传递数据的内部结构隐藏在对流数据的解释中 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:0","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"IO的步骤 在IO流里，输入输出分为4步：格式化/解析，缓冲，编码转换和传递。 格式化/解析：在内部数据表示（以字节为单位）与外部数据表示（以字符为单位）之间进行双向转换。例如一个2字节的整数10002，就需要5个字符来表示。 缓冲：用于在格式/解析与传递只加缓存字符序列。对于输出，较短的字符序列格式化之后并不马上输出，而是保存在缓冲区里，待累积到一定规模之后再传递到外部设备。相反，从外部设备读入的大量数据也是先放在缓冲区，然后逐步取出完成输入。默认时，IO流的输入输出都是经过缓冲的，也可以让IO流工作在无缓冲模式下。 编码转换： 是将一种字符表达式转换成另一种字符表达式。如果格式化产生的字符表达式与外部字符表达式不同（输出时），或者外部表达式与IO流能解析的表达式不同（输入时），就必须进行编码转换。如多字节编码与宽字符编码之间的转换等。多数情况下并不需要进行编码转换。 传递：主要是与外部设备进行通信。输出时，传递负责将经过格式化、缓冲即编码转换后的字符序列发送到外部设备；输入时，则负责将外部设备抽取数据，为其后进行的编码转换、缓冲及解析提供字符序列。 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:1","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"IO流类库组成结构 IO流类库在不同平台的具体实现上，可能会有所变化，但从总体设计上来看，C++流库主要由两个流类层次组成： （1）以streambuf类为父类的类层次 主要完成信息通过缓冲区的交换。派生层次如下 缓冲区：是一个队列数据结构，由一字符序列和两个指针组成，这两个指针分别指向字符要被插入或被取出的位置。 streambuf类为所有的streambuf类层次对象设置了一个固定的内存缓冲区，动态划分为两部分： 用做输入的取区，用取指针指示当前取字符位置。 用做输出的存区，用存指针指示当前存字符位置。 （2）以ios类为父类的类层次 ios类及其派生类是在streambuf类实现的通过缓冲区的信息交换的基础上，进一步增加了各种格式化的输入/输出控制方法。它们为用户提供使用流类的接口，它们均有一个指向streambuf的指针。 ios类有四个直接派生类： istream ostream fstreambase strstreambase 这四种流作为流库中的基本流类。ios类的派生层次如下： ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:2","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"标准输入流cin 不同版本的抽取运算符（»）查看输入流的方法是相同的，它们跳过空白（空格、换行和制表符）直到遇到非空白字符。 一般情况下可以使用如下方式测试流状态： while(cin \u003e\u003e input) { sum += input; } cin \u003e\u003e input; // 这里流已经无效了，应该使用cin.clear() 重置流 if (cin.eof()) cout \u003c\u003c \"End of File\" \u003c\u003c endl; 字符输入 cin.get(ch) 读取单个字符，不会跳过空白，返回流对象cin cin.get()，读取单个字符，不会跳过空白，返回读取的字符 考虑包含空包的输入时可以有如下代码： int ch; while ((ch = cin.get()) != EOF) { // process input; } 使用哪种方式（» , cin.get(ch), cin.get()）读取字符取决于是否希望跳过空白 字符串输入 cin提供了用于字符串输入的成员函数： istream\u0026 get(char*, int, char) 第一个参数时要放置的字符串地址，第二个是比要读取的字符数大1，第三个指定分界符 istream\u0026 get(char*, int) 默认指定换行符号为分界符 istream\u0026 getline(char*, int, char) istream\u0026 get(char*, int, char) get和getline方法的区别是get不会丢弃换行符，也就是换行符依旧停留在输入流中，而getline会抽取并丢弃换行符 直接输入 istream\u0026 read(char*, int, char) read方法不会在输入后加上空字符，因此不能将输入转换为字符串。其与ostream.write()搭配使用完成文件的输入输出 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:3","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"标准输出流cout 以下代码很好地展示了用法 #include\u003ciostream\u003e#include\u003ciomanip\u003e#include\u003ccmath\u003eusing namespace std; int main() { cout \u003c\u003c fixed \u003c\u003c right; cout \u003c\u003c setw(6) \u003c\u003c \"N\" \u003c\u003c setw(14) \u003c\u003c \"square root\" \u003c\u003c setw(15) \u003c\u003c \"fourth root\\n\"; double root; for (int n = 10; n \u003c= 100; n += 10) { root = sqrt(double(n)); cout \u003c\u003c setw(6) \u003c\u003c setfill('.') \u003c\u003c n \u003c\u003c setfill(' ') \u003c\u003c setw(12) \u003c\u003c setprecision(3) \u003c\u003c root \u003c\u003c setw(14) \u003c\u003c setprecision(4) \u003c\u003c sqrt(root) \u003c\u003c endl; } return 0; } N square root fourth root ....10 3.162 1.7783 ....20 4.472 2.1147 ....30 5.477 2.3403 ....40 6.325 2.5149 ....50 7.071 2.6591 ....60 7.746 2.7832 ....70 8.367 2.8925 ....80 8.944 2.9907 ....90 9.487 3.0801 ...100 10.000 3.1623 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:4","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"流状态 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:5","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"文件输入和输出 输出文件步骤 创建一个ofstream对象来管理输出流 将该对象与特定的文件关联起来 以使用cout的方式使用该对象，唯一的区别是输出将进入文件而不是屏幕 ofstream fout; fout.open(\"file.txt\"); fout \u003c\u003c \"data...\"; // 或者 ofstream fout(\"file.txt\"); fout \u003c\u003c \"data...\"; 警告：以默认模式打开文件进行输出，将直接将文件长度截短为0，相当于删除了文件之前的内容 输入文件步骤 创建一个ifstream对象来管理输出流 将该对象与特定的文件关联起来 以使用cin的方式使用该对象 ifstream fin; fin.open(\"file.txt\"); char ch; fin \u003e\u003e ch; // 或者 ifstream fin(\"file.txt\"); fin \u003e\u003e ch; 流状态检查 检查文件是否打开：in.is_open() 相对于以前的方式更好，因为它能够检测出其他方式不能检测出的微妙问题，如上图所示 文件模式 ","date":"2022-05-06","objectID":"/c_and_cpp_io/:2:6","tags":["IO"],"title":"C和C++中的输入输出","uri":"/c_and_cpp_io/"},{"categories":["C/C++"],"content":"深拷贝与浅拷贝 基本数据类型的特点：直接存储在栈(stack)中的数据 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 在C++中： 1 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。 2 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。 ","date":"2022-04-29","objectID":"/constructor/:1:0","tags":["Cpp"],"title":"构造与析构","uri":"/constructor/"},{"categories":["C/C++"],"content":"构造函数 首先明确以下一个事实： Person p = Person(); // 这是定义，不会进入赋值运算符的成员函数 p = Person(); // 这时赋值, 会进入赋值运算符的成员函数 C++的构造函数的作用：初始化类对象的数据成员。 即类的对象被创建的时候，编译系统对该对象分配内存空间，并自动调用构造函数，完成类成员的初始化，可以理解为构造函数的作用就是给类的各个非静态成员变量申请内存并赋初值。 当直接调用类的构造函数时，其生成的对象内存分配在栈上，例如 A a = A(); 或 A(); 当使用new运算符生成指向对象的指针时，其生成的对象内存分配在堆上，例如A a = new A(); 注意，对象的成员变量的初始化动作发生在进入构造函数本体之前，在构造函数内，都不算是被初始化，而是被赋值 如下： class Student { public: Student(int id, const std::string\u0026 name, const std::vector\u003cint\u003e\u0026 score) { // 在花括号里面的都是赋值不是初始化 m_Id = id; m_Name = name; m_Score = score; } private: int m_Id; std::string m_Name; std::vector\u003cint\u003e m_Score; }; 下面的方法才是正确的初始化方式 class Student { public: Student(int id, const std::string\u0026 name, const std::vector\u003cint\u003e\u0026 score) : m_Id(id), m_Name(name), m_Score(score) { } private: int m_Id; std::string m_Name; std::vector\u003cint\u003e m_Score; }; 构造函数的特点：以类名作为函数名，无返回类型。 我们常说的构造函数大致分为三种，即一般的构造函数、拷贝构造函数和移动构造函数。 ","date":"2022-04-29","objectID":"/constructor/:2:0","tags":["Cpp"],"title":"构造与析构","uri":"/constructor/"},{"categories":["C/C++"],"content":"一般构造函数 无参数构造函数/默认构造函数 当调用构造函数不提供参数时，就会调用上述构造函数 若没有定义任何构造函数时，编译器会自动创建一个没有参数的构造函数，称为合成构造函数 带参数的构造函数 带参数的构造函数中，新的标准是可以用类中其余的构造函数在本构造函数中初始化部分成员变量，称其为委托构造函数 ","date":"2022-04-29","objectID":"/constructor/:2:1","tags":["Cpp"],"title":"构造与析构","uri":"/constructor/"},{"categories":["C/C++"],"content":"拷贝构造函数 当一个构造函数的参数为类的引用时，其就是一个拷贝构造函数。 若我们没有给一个类定义一个拷贝构造函数，编译器会自动给我们生成一个构造函数，称为合成拷贝构造函数 ，除非我们在该拷贝构造函数的声明中指定为=delete。 合成拷贝构造函数执行的拷贝动作都是浅拷贝，即只对当前栈上内容进行拷贝，不会对栈中指针指向的内容进行拷贝。 拷贝构造函数的参数必须为本类的引用，否则会引发死循环 考虑以下情况： Person a = Person(); Person b = Person(a); 我们直到在函数中传参数的话，若不加引用就是值传递，那么每个实参都会复制一份，在栈中生成临时对象，然后该临时对象作用域在函数内部。 构造函数同理，若其参数不是本对象的引用，那么当调用该构造函数时，需要复制一份实参生成临时对象，而此时实参也是该类的一个对象，那么这个临时对象的构造又命中了拷贝构造函数，等于是套娃了，形成了死循环。所以拷贝构造函数的参数必须为本类的引用，另外最佳实践是，形参加上cosnt修饰，因为一般也不会用于修改被用于构造的对象。 最佳实践：当本类不包含指针类型的成员变量时，可以使用合成的拷贝构造，即全都是浅拷贝，当本类包含指针类型的成员变量时，应使用自定义的拷贝构造并实现深拷贝。最好给参数加上const修饰符 看如下代码： #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; class Buffer { private: unsigned char *buf; int capacity; int length; public: explicit Buffer(int capacity) : capacity(capacity), length(0), buf(new unsigned char[capacity]{ 0 }) { } int GetLength() { return length; } int GetCapacity() { return capacity; } bool write(unsigned char value) { if (length == capacity) return false; buf[length++] = value; return true; } ~Buffer() { delete[] buf; } friend ostream\u0026 operator\u003c\u003c(ostream \u0026os, Buffer \u0026buffer); }; ostream\u0026 operator\u003c\u003c(ostream \u0026os, Buffer \u0026buffer) { os \u003c\u003c \"Buffer(\" \u003c\u003c buffer.length \u003c\u003c \"/\" \u003c\u003c buffer.capacity \u003c\u003c \")[\"; for (int i = 0; i \u003c buffer.capacity; ++i) { os \u003c\u003c (int)buffer.buf[i] \u003c\u003c \", \"; } os \u003c\u003c \"]\"; return os; } int main() { auto buffer = Buffer(10); auto buffer2 = buffer; buffer.write(65); cout \u003c\u003c buffer \u003c\u003c endl; cout \u003c\u003c buffer2 \u003c\u003c endl; return 0; } Buffer(1/10)[65, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Buffer(0/10)[65, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] 进程已结束,退出代码-1073740940 (0xC0000374) 看到没，由于没有定义拷贝构造函数，所以buffer2没有写却出现了65这个值。另外进程突出代码为一个负数，说明出现了异常，是因为，进行了两次析构。 在上述代码中加入深复制操作后，就有了正确的结果了，如下： Buffer(const Buffer\u0026 buffer) { if (\u0026buffer == this) return; // 判断是否自赋值，避免后续操作开销 this-\u003ecapacity = buffer.capacity; this-\u003elength = buffer.length; this-\u003ebuf = new unsigned char[buffer.capacity]; std::copy(buffer.buf, buffer.buf + buffer.capacity, this-\u003ebuf); } Buffer(1/10)[65, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Buffer(0/10)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] 进程已结束,退出代码0 此外赋值运算符重载函数 的功能和拷贝构造函数类似， 最佳实践：当定义了拷贝构造函数时，也应一起定义赋值运算符重载函数 Buffer\u0026 operator=(const Buffer\u0026 buffer) { if (\u0026buffer == this) return *this; this-\u003ecapacity = buffer.capacity; this-\u003elength = buffer.length; delete[] this-\u003ebuf; this-\u003ebuf = new unsigned char[buffer.capacity]; std::copy(buf, buf + buffer.capacity, this-\u003ebuf); } 注意的是这里开头也要做自赋值判断，目的是为了避免多余的开销 ","date":"2022-04-29","objectID":"/constructor/:2:2","tags":["Cpp"],"title":"构造与析构","uri":"/constructor/"},{"categories":["C/C++"],"content":"移动构造函数 在拷贝构造函数中，若有如下代码 auto buffer = Buffer(10); // 第一次构造 buffer = Buffer(16); // 这里构造了一个临时对象， 并将临时对象拷贝进行了一次拷贝 cout \u003c\u003c buffer \u003c\u003c endl; return 0; 执行结果为 Constructor: Buffer(0/10)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Constructor: Buffer(0/16)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Copy: Buffer(0/10)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Destructor: Buffer(0/16)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Buffer(0/16)[0, 25, 151, 226, 40, 2, 0, 0, 80, 1, 151, 226, 40, 2, 0, 0, ] Destructor: Buffer(0/16)[0, 25, 151, 226, 40, 2, 0, 0, 80, 1, 151, 226, 40, 2, 0, 0, ] 可以看到首先构造了一个buffer，调用了第一次构造函数，然后在赋值运算符的右侧，构造了一个临时对象，然后将这临时对象进行了一次拷贝赋值。然后临时对象销毁，接着打印buffer,最后buffer销毁 为了解决这种不必要的拷贝，C++11引入了一个新的概念也就是移动语义，同时带来了移动构造函数和移动赋值运算符 由此，我们加入以下代码 Buffer(Buffer\u0026\u0026 buffer) noexcept{ cout \u003c\u003c \"Move Constructor: \" \u003c\u003c *this \u003c\u003c endl; // 你的归我了 this-\u003ecapacity = buffer.capacity; this-\u003elength = buffer.length; this-\u003ebuf = buffer.buf; // 你的删除 buffer.capacity = 0; buffer.length = 0; buffer.buf = nullptr; } Buffer\u0026 operator=(Buffer\u0026\u0026 buffer) noexcept{ cout \u003c\u003c \"Move: \" \u003c\u003c *this \u003c\u003c endl; if (\u0026buffer == this) return *this; this-\u003ecapacity = buffer.capacity; this-\u003elength = buffer.length; delete[] this-\u003ebuf; this-\u003ebuf = buffer.buf; buffer.capacity = 0; buffer.length = 0; buffer.buf = nullptr; } 最佳实践，一要加上noexcept保证不发生异常，二移动赋值时要进行自赋值判断，三被移动的对象的指针要赋值为空指针 结果如下，可以看到Copy操作变为了Move操作 Constructor: Buffer(0/10)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Constructor: Buffer(0/16)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Move: Buffer(0/10)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Destructor: Buffer(0/0)[] Buffer(0/16)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] Destructor: Buffer(0/16)[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ] 当加入如下代码或者在诸如vector的一些支持移动操作的标准库容器中，也会使用到移动构造函数 auto buffer1 = std::move(buffer); 结果： Move Constructor: Buffer(2/0)[] Destructor: Buffer(0/0)[] 最佳实践 为了减少重复代码，可以在拷贝构造函数中调用拷贝赋值函数，移动构造函数同理 // 初始化，指针要为空，因为赋值操作中有 先delete[] 操作。 Buffer(const Buffer\u0026 buffer) : capacity(0), length(0), buf(nullptr){ cout \u003c\u003c \"Copy Constructor: \" \u003c\u003c *this \u003c\u003c endl; *this = buffer; } // 要将buffer左值转为右值，这里buffer具名，是一个左值 Buffer(Buffer\u0026\u0026 buffer) noexcept : capacity(0), length(0), buf(nullptr){ *this = std::move(buffer); } 更进一步，拷贝赋值和移动赋值还是有些重复代码，无非就是把一个对象的值转移到另一对象，为了解决这一问题，出现一个新的编程范式：Copy \u0026 Swap 首先在类中定义一个交换函数： static void Swap(Buffer\u0026 lhs, Buffer\u0026 rhs) noexcept{ std::swap(lhs.buf, rhs.buf); std::swap(lhs.capacity, rhs.capacity); std::swap(lhs.length, rhs.length); } 接着改进拷贝构造和拷贝赋值，其中，拷贝构造只需将将其他的值复制给自己的初始化列表即可，而拷贝赋值则是将形参由引用变成值传递，所以直接和临时对象交换即可，保证了异常安全 // 再改进版 Buffer(Buffer\u0026 buffer) : capacity(buffer.capacity), length(buffer.length), buf(buffer.capacity ? new unsigned char[buffer.capacity] : nullptr) { cout \u003c\u003c \"Copy Constructor: \" \u003c\u003c *this \u003c\u003c endl; } // 改进版 Copy \u0026 Swap, 异常安全，因为传进来的是拷贝的临时对象， Buffer\u0026 operator=(Buffer buffer) { cout \u003c\u003c \"Copy \u0026 Swap: \" \u003c\u003c *this \u003c\u003c endl; Swap(*this, buffer); return *this; } 接着改进移动构造和移动赋值，由于移动构造传进来的是一个xvalue,将亡值，所以可以毫不犹豫交换，自己可以初始化为0先然后调用交换函数即可 Buffer(Buffer\u0026\u0026 buffer) noexcept : Buffer(buffer.capacity){ Swap(*this, buffer); } 其实这时已经不需要移动赋值了，将亡值可以和拷贝赋值一起操作 ","date":"2022-04-29","objectID":"/constructor/:2:3","tags":["Cpp"],"title":"构造与析构","uri":"/constructor/"},{"categories":["C/C++"],"content":"析构函数 析构函数用于在销毁一个对象动作完成前执行一些操作 当一个类具有子类时，或者一个类有可能被继承时，应该将其析构函数设置为虚析构函数。 这时因为，当一个类中有指针成员时，在多态的场景中，例如有一个指向父类类型的指针被赋值了一个子类对象的地址时，若析构函数不是虚函数，那么该对象析构时调用的是父类的析构函数而不是子类对象的析构函数，那么会导致子类的一些特有成员变量未被销毁，从而造成内存泄漏。 ","date":"2022-04-29","objectID":"/constructor/:3:0","tags":["Cpp"],"title":"构造与析构","uri":"/constructor/"},{"categories":["Algorithm"],"content":"二分查找 LeetBook: 二分查找入门 难度 题目 刷次数 经典指数 Easy 374.猜数字大小 ✅ ⭐⭐⭐⭐⭐ Medium 33.搜索旋转排序数组 ✅ ⭐⭐⭐ Medium 153. 寻找旋转排序数组中的最小值 ✅ ⭐⭐ Medium 658. 找到 K 个最接近的元素 ✅ ⭐⭐⭐⭐ Medium 702. 搜索长度未知的有序数组 ✅ ⭐⭐ Medium 287. 寻找重复数 ✅ ⭐⭐⭐ Hard 4. 寻找两个正序数组的中位数 ✅ ⭐⭐⭐⭐ Hard 719. 找出第 k 小的距离对 ✅ ⭐⭐⭐ Hard 410. 分割数组的最大值 ✅ ⭐ ","date":"2022-04-28","objectID":"/leetcode/:1:0","tags":[],"title":"精选题目","uri":"/leetcode/"},{"categories":["Algorithm"],"content":"二叉树 LeetBook: 二叉树 难度 题目 刷次数 经典指数 Easy 144. 二叉树的前序遍历 ✅ ⭐⭐⭐⭐⭐ Easy 94. 二叉树的中序遍历 ✅ ⭐⭐⭐⭐⭐ Easy 145. 二叉树的后序遍历 ✅ ⭐⭐⭐⭐⭐ Medium 102. 二叉树的层序遍历 ✅ ⭐⭐⭐⭐⭐ Easy 104. 二叉树的最大深度 ✅ ⭐⭐⭐⭐⭐ Easy 101. 对称二叉树 ✅ ⭐⭐⭐⭐⭐ Easy 112. 路径总和 ✅ ⭐⭐⭐⭐⭐ Medium 106. 从中序与后序遍历序列构造二叉树 ✅ ⭐⭐⭐⭐ Medium 105. 从前序与中序遍历序列构造二叉树 ✅ ⭐⭐⭐⭐ Medium 116. 填充每个节点的下一个右侧节点指针 ✅ ⭐⭐⭐⭐ Medium 17. 填充每个节点的下一个右侧节点指针 II ✅ ⭐⭐⭐⭐ Medium 236. 二叉树的最近公共祖先 ✅ ⭐⭐⭐⭐ Hard 297. 二叉树的序列化与反序列化 ✅ ⭐⭐⭐ ","date":"2022-04-28","objectID":"/leetcode/:2:0","tags":[],"title":"精选题目","uri":"/leetcode/"},{"categories":["Algorithm"],"content":"链表 LeetBook: 链表 难度 题目 刷次数 经典指数 Easy 141. 环形链表 ✅ ⭐⭐⭐⭐⭐ Medium 142. 环形链表 II ✅ ⭐⭐⭐⭐⭐ Easy 160. 相交链表 ✅ ⭐⭐⭐ Medium 19. 删除链表的倒数第 N 个结点 ✅ ⭐⭐⭐⭐⭐ Easy 206. 反转链表 ✅✅ ⭐⭐⭐⭐⭐ Easy 203. 移除链表元素 ✅ ⭐⭐⭐ Medium 328. 奇偶链表 ✅ ⭐⭐⭐⭐ Medium 707. 设计链表 ✅ ⭐⭐⭐⭐ Medium 430. 扁平化多级双向链表 ✅ ⭐⭐ ","date":"2022-04-28","objectID":"/leetcode/:3:0","tags":[],"title":"精选题目","uri":"/leetcode/"},{"categories":["Algorithm"],"content":"队列 \u0026 栈 LeetBook: 队列 \u0026 栈 难度 题目 刷次数 经典指数 Medium 622. 设计循环队列 ✅ ⭐⭐⭐⭐⭐ Medium 286. 墙与门 ✅ ⭐⭐⭐ Medium 752. 打开转盘锁 ✅ ⭐⭐⭐ Medium 279. 完全平方数 ✅ ⭐⭐⭐⭐ Easy 20. 有效的括号 ✅ ⭐⭐⭐⭐ Medium 739. 每日温度 ✅ ⭐⭐⭐⭐⭐ Medium 150. 逆波兰表达式求值 ✅ ⭐⭐⭐⭐⭐ Medium 542. 01 矩阵 ✅ ⭐⭐⭐⭐ Medium 394. 字符串解码 ✅ ⭐⭐⭐⭐⭐ ","date":"2022-04-28","objectID":"/leetcode/:4:0","tags":[],"title":"精选题目","uri":"/leetcode/"},{"categories":["Algorithm"],"content":"排序 LeetBook: 排序 难度 题目 刷次数 经典指数 Easy 283. 移动零 ✅ ⭐⭐⭐⭐ Easy 506. 相对名次 ✅ ⭐⭐⭐ Medium 215. 数组中的第K个最大元素 ✅ ⭐⭐⭐⭐⭐ Medium 912. 排序数组 ✅ ⭐⭐⭐⭐⭐ Medium 147. 对链表进行插入排序 ✅ ⭐⭐⭐⭐ Medium 剑指 Offer 40. 最小的k个数 ✅ ⭐⭐⭐⭐⭐ Medium 169. 多数元素 ✅ ⭐⭐⭐⭐⭐ Medium 75. 颜色分类 ✅ ⭐⭐⭐⭐⭐ Hard 剑指 Offer 51. 数组中的逆序对 ✅ ⭐⭐⭐⭐⭐ Hard 164. 最大间距 ✅ ⭐⭐⭐ ","date":"2022-04-28","objectID":"/leetcode/:5:0","tags":[],"title":"精选题目","uri":"/leetcode/"},{"categories":["Algorithm"],"content":"动态规划 LeetBook:动态规划一 难度 题目 刷次数 经典指数 Easy 53. 最大子数组和 ✅ ⭐⭐⭐⭐ Medium 918. 环形子数组的最大和 ✅ ⭐⭐⭐ Medium 300. 最长递增子序列 ✅ ⭐⭐⭐⭐⭐ Hard 673. 最长递增子序列的个数 ✅ ⭐⭐⭐⭐⭐ Medium 152. 乘积最大子数组 ✅ ⭐⭐⭐⭐⭐ Hard 354. 俄罗斯套娃信封问题 ✅ ⭐⭐⭐⭐ Hard 面试题 17.24. 最大子矩阵 ✅ ⭐⭐⭐⭐⭐ Hard 363. 矩形区域不超过 K 的最大数值和 ✅ ⭐⭐⭐⭐ Medium 198. 打家劫舍 ✅ ⭐⭐⭐⭐⭐ Medium 213. 打家劫舍 II ✅ ⭐⭐⭐⭐⭐ Medium 740. 删除并获得点数 ✅ ⭐⭐⭐⭐ Hard 1388. 3n 块披萨 ✅ ⭐⭐⭐⭐ Medium 873. 最长的斐波那契子序列的长度 ✅ ⭐⭐⭐⭐ Medium 1027. 最长等差数列 ✅ ⭐⭐⭐⭐ ","date":"2022-04-28","objectID":"/leetcode/:6:0","tags":[],"title":"精选题目","uri":"/leetcode/"},{"categories":["Algorithm"],"content":"前序遍历 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。 ","date":"2022-04-23","objectID":"/binary_tree/:1:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法 实际上迭代解法分两种形式： 形式一：模拟栈 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (!root) return ans; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); ans.emplace_back(node-\u003eval); // 注意模拟栈时，首先出栈的要先入栈 if (node-\u003eright) st.push(node-\u003eright); if (node-\u003eleft) st.push(node-\u003eleft); } return ans; } }; 形式二：通用框架 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; TreeNode* node = root; while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { ans.emplace_back(node-\u003eval); st.emplace(node); node = node -\u003e left; } node = st.top(); st.pop(); node = node -\u003e right; } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:1:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 更简单，更易于理解，但不容易体现技术水平 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { if (!node) return; // 先写操作，后遍历左右子树 ans.emplace_back(node-\u003eval); dfs(node-\u003eleft, ans); dfs(node-\u003eright, ans); } }; ","date":"2022-04-23","objectID":"/binary_tree/:1:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"中序遍历 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。 通常来说，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。 ","date":"2022-04-23","objectID":"/binary_tree/:2:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法 class Solution { public: vector\u003cint\u003e midorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; TreeNode* node = root; while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { st.emplace(node); node = node -\u003e left; } node = st.top(); st.pop(); ans.emplace_back(node-\u003eval); node = node -\u003e right; } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:2:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 class Solution { public: vector\u003cint\u003e midorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { if (!node) return; dfs(node-\u003eleft, ans); // 先遍历左子树，再进行操作，再遍历右子树 ans.emplace_back(node-\u003eval); dfs(node-\u003eright, ans); } }; ","date":"2022-04-23","objectID":"/binary_tree/:2:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"后序遍历 值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。 另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。 如上图，您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。 如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。 ","date":"2022-04-23","objectID":"/binary_tree/:3:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法 方法一：反前序迭代再反向输出 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { deque\u003cint\u003e ans; if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; TreeNode* node = root; while (!st.empty() || node != nullptr) { // 先往右走，走到底了就往左，接着重复同样操作 while (node != nullptr) { ans.emplace_front(node-\u003eval); st.emplace(node); node = node -\u003e right; } node = st.top(); st.pop(); node = node -\u003e left; } return ans; } }; 方法二： 硬迭代（较难） class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; // 特例判定 if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; // 当前结点初始化为根节点 TreeNode* node = root; // prev为记录的前继结点 TreeNode* prev = nullptr; // 循环判断栈非空 或者 当前结点为空 while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { st.emplace(node); // 入栈 node = node -\u003e left; // 继续往左下迭代 } node = st.top(); st.pop(); // 出栈 // 以下if判断为后序遍历特有的 // 当前结点右子树为空（之前已经入栈了，等于是也遍历完了左右子树了）或刚从右子树上来 if (!node-\u003eright || node-\u003eright == prev) { ans.emplace_back(node-\u003eval); // 更新前继结点为当前结点 prev = node; // node已经访问过了，现在往上走，为了防止node被压入栈，所以要置空 node = nullptr; } else { // 从左边上来的时候，往右下角走之前也要入栈 st.emplace(node); node = node -\u003e right; // 往右子树走一次 } } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:3:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { if (!node) return; dfs(node-\u003eleft, ans); // 先遍历左子树，再进行操作，再遍历右子树 dfs(node-\u003eright, ans); ans.emplace_back(node-\u003eval); } }; ","date":"2022-04-23","objectID":"/binary_tree/:3:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"层次遍历（广度优先） 此种方法区别于其他的方法的地方，在于其为广度优先搜索，适用于一些树的高度或路径记录的问题，需要用到队列来保存候选结点 class Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { vector\u003cvector\u003cint\u003e\u003e ans; if (!root) return ans; // 定义一个队列 queue\u003cTreeNode*\u003e que; // 初始加入根节点 que.emplace(root); // 可用于计算层数 int level = 0; while (!que.empty()) { // 先记录队列中元素数量,即当前层元素数量 int size = que.size(); vector\u003cint\u003e temp; // 当前层每个元素从队列头部出队后加入其左右的非空子结点 for (int i = 0; i \u003c size; ++i) { TreeNode* cur = que.front(); que.pop(); temp.emplace_back(cur -\u003e val); if (cur -\u003e left) que.emplace(cur -\u003e left); if (cur -\u003e right) que.emplace(cur -\u003e right); } // 将当前层的所有元素加入结果数组 ans.emplace_back(temp); } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:4:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"Morris遍历 本方法适用于前序和中序遍历和后序遍历 morris遍历的思想是，通过记忆当前遍历节点的前继节点，建立一个回溯的通道，避免了栈的开销，空间复杂度为常数级。其原理如下代码注释所示 Morris遍历也有中序版本，只需要将对当前节点的操作放到已经遍历完左子树节点的位置即可。 class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; if (!root) return ans; // 初始化迭代指针p1, p1始终指向需要进行操作的结点 TreeNode* p1 = root; // p2 指针指向p1的前继结点, 一般为p1的左子树的最右下角的结点 TreeNode* p2 = nullptr; // 终止条件为 p1 非空 while (p1 != nullptr) { // p2 初始化为p1的左子树根节点 p2 = p1-\u003eleft; // p2 非空, 才要遍历左子树，否则直接遍历右子树 if (p2 != nullptr) { // p2 往右下角一直走，直到其指向最右下角的结点 while (p2 -\u003e right != nullptr \u0026\u0026 p2 -\u003e right != p1) p2 = p2 -\u003e right; // p2 没有后继（p2-\u003eright）结点, 那么改变其后继为p1 if (p2 -\u003e right == nullptr) { // 前序遍历的操作位置在这里！！！！！！！ ans.emplace_back(p1 -\u003e val); // 建立 p1 的前继结点 p2 -\u003e right = p1; // p1 向左下角继续遍历 p1 = p1 -\u003e left; continue; } else { // p2 的后继为 p1, 说明已经遍历过了当前节点的左子树 // 那么将这种关系删除，恢复原状，接着遍历右子树 // 中序遍历 操作的位置在这里！！！！！！ p2-\u003eright = nullptr; p1 = p1 -\u003e right; } } else { // p2 为空，那么直接对当前遍历结点 p1 操作，然后遍历右子树 ans.emplace_back(p1 -\u003e val); p1 = p1 -\u003e right; } } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:5:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"通用框架 ","date":"2022-04-23","objectID":"/binary_tree/:6:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法之先入栈法（前、中序统一） 核心思想为： 每拿到一个 节点 就把它保存在 栈 中 继续对这个节点的 左子树 重复 过程1，直到左子树为 空 因为保存在 栈 中的节点都遍历了 左子树 但是没有遍历 右子树，所以对栈中节点 出栈 并对它的 右子树 重复 过程1 直到遍历完所有节点 前序和中序的统一 class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; // 特例判定 if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; // 当前结点初始化为根节点 TreeNode* node = root; // 循环判断栈非空 或者 当前结点为空 while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { // 前序操作插入位置 st.emplace(node); // 入栈 node = node -\u003e left; // 继续往左下迭代 } node = st.top(); st.pop(); // 出栈 // 中序操作插入位置 node = node -\u003e right; // 往右子树走一次 } return ans; } }; 上述解法的后序遍历需要一些额外的操作，需要记录一个前继结点 后序 class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; // 特例判定 if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; // 当前结点初始化为根节点 TreeNode* node = root; // prev为记录的前继结点 TreeNode* prev = nullptr; // 循环判断栈非空 或者 当前结点为空 while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { st.emplace(node); // 入栈 node = node -\u003e left; // 继续往左下迭代 } node = st.top(); st.pop(); // 出栈 // 以下if判断为后序遍历特有的 // 当前结点右子树为空（之前已经入栈了，等于是也遍历完了左右子树了）或刚从右子树上来 if (!node-\u003eright || node-\u003eright == prev) { ans.emplace_back(node-\u003eval); // 更新前继结点为当前结点 prev = node; // node已经访问过了，现在往上走，为了防止node被压入栈，所以要置空 node = nullptr; } else { // 从左边上来的时候，往右下角走之前也要入栈 st.emplace(node); node = node -\u003e right; // 往右子树走一次 } } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:6:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法之先出栈法（ 前、后序统一） 这里的后序还是采用的逆前序入栈在逆序输出的方式 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { stack\u003cTreeNode*\u003e st; vector\u003cint\u003e result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-\u003eval); if (node-\u003eleft) st.push(node-\u003eleft); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-\u003eright) st.push(node-\u003eright); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } }; 中序遍历的方式通过插入空结点作为标记 class Solution { public: vector\u003cint\u003e inorderTraversal(TreeNode* root) { vector\u003cint\u003e result; stack\u003cTreeNode*\u003e st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.pop(); // 添加右节点（空节点不入栈） if (node-\u003eright) st.push(node-\u003eright); // 添加中节点 st.push(node); // 中节点访问过，但是还没有处理，加入空节点做为标记。 st.push(NULL); // 添加左节点（空节点不入栈） if (node-\u003eleft) st.push(node-\u003eleft); } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 // 将空节点弹出 st.pop(); // 重新取出栈中元素 node = st.top(); st.pop(); // 加入到结果集 result.push_back(node-\u003eval); } } return result; } }; ","date":"2022-04-23","objectID":"/binary_tree/:6:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 (前、中、后序统一) ```cpp class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { // 定义返回集 vector\u003cint\u003e ans; // 进行特殊条件判断 if (root == nullptr) return ans; // 调用递归函数 dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { // 递归终止条件 if (!node) return; // 前序操作插入位置 dfs(node-\u003eleft, ans); // 中序操作插入位置 dfs(node-\u003eright, ans); // 后序操作插入位置 } }; ","date":"2022-04-23","objectID":"/binary_tree/:6:3","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"Morris解法（前、中序统一） class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; if (!root) return ans; // 初始化迭代指针p1, p1始终指向需要进行操作的结点 TreeNode* p1 = root; // p2 指针指向p1的前继结点, 一般为p1的左子树的最右下角的结点 TreeNode* p2 = nullptr; // 终止条件为 p1 非空 while (p1 != nullptr) { // p2 初始化为p1的左子树根节点 p2 = p1-\u003eleft; // p2 非空, 才要遍历左子树，否则直接遍历右子树 if (p2 != nullptr) { // p2 往右下角一直走，直到其指向最右下角的结点 while (p2 -\u003e right != nullptr \u0026\u0026 p2 -\u003e right != p1) p2 = p2 -\u003e right; // p2 没有后继（p2-\u003eright）结点, 那么改变其后继为p1 if (p2 -\u003e right == nullptr) { // !!!!!!!前序遍历的操作位置在这里!!!!!!!! // 【ans.emplace_back(p1 -\u003e val);】 // 建立 p1 的前继结点 p2 -\u003e right = p1; // p1 向左下角继续遍历 p1 = p1 -\u003e left; continue; } else { // p2 的后继为 p1, 说明已经遍历过了当前节点的左子树 // 那么将这种关系删除，恢复原状，接着遍历右子树 // !!!!!!!!中序遍历 操作的位置在这里！！！！！！ // 【ans.emplace_back(p1 -\u003e val);】 p2-\u003eright = nullptr; p1 = p1 -\u003e right; } } else { // p2 为空，那么直接对当前遍历结点 p1 操作，然后遍历右子树 ans.emplace_back(p1 -\u003e val); p1 = p1 -\u003e right; } } return ans; } }; 后序解法需要做一些修改： class Solution { public: void addPath(vector\u003cint\u003e \u0026vec, TreeNode *node) { int count = 0; while (node != nullptr) { ++count; vec.emplace_back(node-\u003eval); node = node-\u003eright; } reverse(vec.end() - count vec.end()); } vector\u003cint\u003e postorderTraversal(TreeNode *root) { vector\u003cint\u003e res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-\u003eleft; if (p2 != nullptr) { while (p2-\u003eright != nullptr \u0026\u0026 p2-\u003eright != p1) { p2 = p2-\u003eright; } if (p2-\u003eright == nullptr) { p2-\u003eright = p1; p1 = p1-\u003eleft; continue; } else { p2-\u003eright = nullptr; addPath(res, p1-\u003eleft); } } p1 = p1-\u003eright; } addPath(res, root); return res; } }; ","date":"2022-04-23","objectID":"/binary_tree/:6:4","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["C/C++"],"content":"从4行代码看右值引用 - qicosmos(江南) - 博客园 Value categories - cppreference.com https://www.stroustrup.com/terminology.pdf ","date":"2022-04-21","objectID":"/rvalue_ref/:0:0","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"左值与右值 ","date":"2022-04-21","objectID":"/rvalue_ref/:1:0","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"标准定义 每个 C++ 表达式（一个操作符和它的操作数，一个字面值，一个变量名等等）都代表着两个独立属性：类型+属性分类。，属性分类也叫值类别。 值类别是编译器在表达式计算期间创建、复制和移动临时对象时必须遵循的规则的基础。 C++17 标准定义表达式值类别，如下所示： glvalue (general lvalue)： 泛左值，由(lvalue)和(xvalue)构成。 rvalue 右值，由(xvalue)和(prvalue)构成。右值具有潜在的可移动性 prvalue(pure rvaluue) ： 纯右值，即传统意义上的右值 xvalue : 中间值？将亡值？，指通过“右值引用”产生的对象。 这里x可以理解为即将消失(expiring)，也可理解为中间（横跨左值和右值） lvalue ：传统意义上的左值 详细的定义可以参考：C++ lvalue，prvalue，xvalue，glvalue和rvalue详解（from cppreference） - PhiliAI - 博客园 (cnblogs.com) ","date":"2022-04-21","objectID":"/rvalue_ref/:1:1","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"通俗解释 C/C++ 语言中可以放在赋值符号左边的变量，左值表示存储在计算机内存的对象，左值相当于地址值。右值：当一个符号或者常量放在操作符右边的时候，计算机就读取他们的“右值”，也就是其代表的真实值，右值相当于数据值。 左值是可以取地址的，这也是区分左值和右值的唯一正确的标志 左值(lvalue)：可以出现在 = 左边 右值(rvalue)：只能出现在 = 右边 看一些左值和右值的例子，下面是整型的 int a = 9; int b = 4; // 左值为表达式 (a = 4) += 28; // 左值是一个表达式 a=4，这句话结果为 a=32 // 左值为变量 a = b; // a 和 b 都是左值 a + b = 42; // Error, a + b整体只是右值，出现右边，这句话出错 看一个关于 string 类型的 特别注意，C++规定字符串是左值 string s1(\"Hello\"); string s2(\"World\"); s1 + s2 = s2; // s1 + s2 是右值，但是这里编译成功了，后面看一下 string() = \"World\"; // 编译通过，左边是临时对象， 竟然也可以赋值 在函数中也会用到 int foo() { return 5; } // 函数返回的是一个右值 int x = foo(); int* p = \u0026foo(); //Error，对函数的返回值取地址，但是函数返回值为右值，取地址不行 foo() = 7; // Error，函数返回值为右值，只能出现在右边 简单的来说，能取地址的变量一定是左值，有名字的变量也一定是左值，最经典的void fun(p\u0026\u0026 shit)，其中shit也是左值，因为右值引用是左值（所以才会有move，forward这些函数的产生，其中move出来一定是右值，forward保持变量形式和之前的不变，就是为了解决右值引用是左值的问题）。 至于为什么不能把等号左边看成左值，因为在C++中，等号是可以运算符重载的，等号完全可以重载成为等号左边为右值的形式 纯右值是传统右值的一部分，纯右值是表达式产生的中间值，不能取地址 本质上，消亡值就是通过右值引用产生的值。右值一定会在表达式结束后被销毁，比如return x（x被copy以后会被销毁）, 1+2（3这个中间值会被销毁）。 ","date":"2022-04-21","objectID":"/rvalue_ref/:1:2","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"左值引用与右值引用 当右值出现在operater = (copy assignment) 的右侧，我们认为对其资源进行偷取/搬移（move）而非拷贝是可以的，是合理的。 那么就得有如下机制： 必须有语法让我们在调用端告诉编译器，这是一个”Rvalue“ 必须有语法让我们在被调用端写出一个专门处理”Rvalue“的所谓move assignment函数 ","date":"2022-04-21","objectID":"/rvalue_ref/:2:0","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"左值引用 左值引用根据其修饰符 const 的不同，可以区分为常量左值引用和非常量左值引用。左值引用实际上就是指针。 非常量左值引用只能绑定到非常量左值，不能绑定到常量左值和常量右值，（因为非常左值可以改变其值，但常量不可改变，性质相矛盾） 非常量右值。而如果绑定到非常量右值，就有可能指向一个已经被销毁的对象。 常量左值引用能绑定到非常量左值，常量左值，非常量右值，常量右值。 int a = 9; int \u0026aRef1 = a; // 非常量左值引用 \u003c----\u003e 非常量左值 const int \u0026aRef2 = a; // 常量左值引用 \u003c----\u003e 非常量左值 const int b = 4; int \u0026bRef1 = b; // Error，非常量左值不能绑定常量右值 const int \u0026bRef2 = b; // 常量左值引用 \u003c----\u003e 常量左值 const int \u0026ref1 = 2; // 常量左值引用 \u003c----\u003e 右值（具体某个值） const int \u0026ref2 = a==2; // 常量左值引用 \u003c----\u003e 右值（表达式） ","date":"2022-04-21","objectID":"/rvalue_ref/:2:1","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"右值引用 为什么要用到右值引用？ 从实践角度讲，它能够完美解决 C++ 中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了 C++ 中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 为了区别，C++ 把 \u0026 作为左值引用的声明符，把 \u0026\u0026 作为右值引用的声明符。例如， int GetValue() { return 3; } int main() { int a = 0; int \u0026alRef = a; // 左值引用 int \u0026\u0026rRef1 = 1; // 临时对象是右值 int \u0026\u0026rRef2 = GetValue(); // 调用的函数返回值为右值 } void ProcessValue(int \u0026i) { // 左值引用 cout \u003c\u003c \"lValue processed: \" \u003c\u003c i \u003c\u003c endl; } void ProcessValue(int \u0026\u0026i) { // 右值引用 cout \u003c\u003c \"rValue processed: \" \u003c\u003c i \u003c\u003c endl; } int GetValue() { return 3; } int main() { int a = 0; int b = 1; ProcessValue(a); // 左值 ProcessValue(1); // 临时对象是右值 ProcessValue(GetValue()); // 调用的函数为右值 ProcessValue(a + b); // 左值 } 从内存角度来看，我们给变量 a 分配好了内存，所以它是正统的内存使用者；而像函数的返回值、临时对象这样的右值，我们找不到它的内存，所以是盗版的内存使用者，这就是左值和右值的区别。 关于右值引用： 具名右值引用被视为左值。 无名右值引用被视为x值（将亡值）。 对函数的右值引用无论具名与否都将被视为左值。 struct A { int m; }; A\u0026\u0026 operator+(A, A); A\u0026\u0026 f(); A a; A\u0026\u0026 ar = static_cast\u003cA\u0026\u0026\u003e(a); 这里表达式 f(), f().m, static_cast\u003cA\u0026\u0026\u003e(a), 以及 a + a 都是 x值。 而表达式 ar 为 A 类型的左值。 ","date":"2022-04-21","objectID":"/rvalue_ref/:2:2","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"move 与 forward move std::move可以获取一个表达式的右值引用在C++11中，标准库在\u003cutility\u003e中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast\u003cT\u0026\u0026\u003e(lvalue); std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。 forward 可参考：聊聊C++中的完美转发 - 知乎 (zhihu.com) std::forward被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。 ","date":"2022-04-21","objectID":"/rvalue_ref/:2:3","tags":["Cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["Algorithm"],"content":"Donald Knuth（高德纳）曾经说过二分法思路很简单，细节是魔鬼。本文就来探讨下二分法中的那些“魔鬼”细节 Reference 力扣-二分查找Leetbook 知乎-谈二分查找-小范同学 ","date":"2022-04-19","objectID":"/binary_search/:0:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"二分查找通用框架 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while (...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u003c target) { left = ... } else if (nums[mid] \u003e target) { right = ... } } return ...; } 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。 其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。 另外声明一下，计算 mid 时需要防止溢出，代码中left + (right - left) / 2就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。 这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。 开门见山，下图就是三种主要模板的框架 这 3 个模板的不同之处在于： 左、中、右索引的分配。 循环或递归终止条件。 后处理的必要性。 模板 #1 和 #3 是最常用的，几乎所有二分查找问题都可以用其中之一轻松实现。模板 #2 更 高级一些，用于解决某些类型的问题。 这 3 个模板中的每一个都提供了一个特定的用例： 模板 #1 (left \u003c= right) 二分查找的最基础和最基本的形式。 查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。 不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。 模板 #2 (left \u003c right) 一种实现二分查找的高级方法。 查找条件需要访问元素的直接右邻居。 使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。 保证查找空间在每一步中至少有 2 个元素。 需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。 模板 #3 (left + 1 \u003c right) 实现二分查找的另一种方法。 搜索条件需要访问元素的直接左右邻居。 使用元素的邻居来确定它是向右还是向左。 保证查找空间在每个步骤中至少有 3 个元素。 需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。 ","date":"2022-04-19","objectID":"/binary_search/:1:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"第一种模板 本模板while条件采用 \u003c= 符号，索引初始的搜索区间右端点应为nums.length-1 ","date":"2022-04-19","objectID":"/binary_search/:2:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索单个值 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } ","date":"2022-04-19","objectID":"/binary_search/:2:1","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索左端点 最后需要做如下越界检查，左边和右边 left加到nums.length，此时target比所有值都大，不符合条件，所以检查left \u003e= nums.length 可直接返回-1 right会减到 -1，分两种情况 (1) target比所有值都小, 不符合条件， 此时left = 0, 但 nums[left] != target (2) 第一个元素正好为target，符合条件，right也会减到-1,但 nums[left] == target 所以可以直接检查第一个元素即nums[left]是否为目标值来区分两种情况。 当找到target时，right = mid - 1 即目标索引 mid = right + 1 = left ， 所以返回left. int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { // 缩小右边搜索区间 // 锁定左侧边界 right = mid - 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } // 做检查 if (left \u003e= nums.length || nums[left] != target) return -1; return left; } ","date":"2022-04-19","objectID":"/binary_search/:2:2","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索右端点 做如下越界检查 left加到nums.length，分两种情况 （1）target比所有值都大, 不符合条件，此时right = nums.length - 1,但nums[right] != target （2）最后元素正好为target，符合条件，left也会加到nums.length,但nums[right] == target right会减到-1，此时target比所有值都小，不符合条件，所以首先检查左边right \u003c 0可直接返回-1。 所以直接检查最后一个元素即nums[right]是否为目标值来区分上述两种情况。 当找到target时，left = mid + 1 即目标索引 mid = left - 1 = right， 返回right int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { // 缩小左边搜索区间 // 锁定右侧边界 left = mid + 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } // 做检查 if (right \u003c 0 || nums[right] != target) return -1; return right; } ","date":"2022-04-19","objectID":"/binary_search/:2:3","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"第二种模板 本模板while条件采用 \u003c 符号，索引初始的搜索区间右端点应为nums.length ","date":"2022-04-19","objectID":"/binary_search/:3:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索单个值 返回left 或者 right, 因为此时left == right,其含义是nums中小于target的值数量，所以函数返回值的取值区间为[0, num.length]， 所以最后要做检查 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length; while (left \u003c right) { // 注意 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; // 注意 } } // Post-processing: // End Condition: left == right if(left != nums.length \u0026\u0026 nums[left] == target) return left; return -1; } ","date":"2022-04-19","objectID":"/binary_search/:3:1","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索左端点 直接返回left 是因为找到目标时，有right == mid, 又因为left == right所以返回left 考虑以下两种情况： 当 left 一直向右移动，最终left == nums.length(每次left = mid + 1), 意味着 target比所有数都大。不符合条件,检查这种情况返回-1即可。 当right一直向左移动，最终right == 0, (每次right= mid), 意味着 target 比所有数都小，不符合条件， nums[left] != target 最终剩余的nums[right]未检查，但nums[left] == target, 符合条件 为了区分上述两种情况，直接检查nums[left] == target 即可 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } // 额外检查target比所有数都大 if (left == nums.length) return -1; // 检查区间残留元素 return nums[left] == target ? left : -1; // 或者可以这样写 // if (left != nums.length \u0026\u0026 nums[left] == target) return left; // return -1; // 或者以下统一形式 return (left != nums.length \u0026\u0026 nums[left] == target) ? left : -1; } ","date":"2022-04-19","objectID":"/binary_search/:3:2","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索右端点 注意这里是返回left - 1, 因为目标找到时有 left = mid + 1; 所以mid = left - 1; 考虑以下两种情况： 因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target 当 left 一直向右移动，最终left == nums.length(每次left = mid + 1), 意味着 target比所有数都大 。不符合条件, nums[left - 1] != target, 检查这种情况返回-1即可 恰好最后一个元素等于target,即 nums[left - 1] == target, 符合条件 为了区分上述两种情况，直接检查nums[left - 1] == target 即可 当right一直向左移动，最终right == 0, (每次right= mid), 意味着target 比所有数都小，不符合条件， nums[left] != target int binarySearch(int[] nums, int target) { int left = 0, right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { left = mid + 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } if (left == 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; } ","date":"2022-04-19","objectID":"/binary_search/:3:3","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"第三种模板 int binarySearch(vector\u003cint\u003e\u0026 nums, int target){ if (nums.size() == 0) return -1; int left = 0, right = nums.size() - 1; while (left + 1 \u003c right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid; } else { right = mid; } } // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1; } ","date":"2022-04-19","objectID":"/binary_search/:4:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"若干条经验 当搜寻单个值时，用模板一，更易于理解，每次二分都直接进行了判断， 当搜寻某个最值或者区间端点时，用模板二 当使用模板一时，whie(left \u003c= right)常常与right = size() - 1 连用 当用模板二时，while (left \u003c right)常常与 right = size() 连用（不确定，有时也看情况） 当使用模板二时，int mid = left + (right - left) / 2 与 left = mid + 1连用，避免死循环，同理int mid = left + (right - left + 1) / 2与`left = mid``连用 当使用模板二时，考虑采用left = mid + 1 还是 left = mid 时，可以做如下思考：当前基于mid判断的nums[mid]是否可能出现在结果区间内，如果可能，考虑二分的那一侧应该包含mid, 即left = mid 或 right = mid,同理，当不可能出现在结果区间内，则应坚决排除，即left = mid + 1 或 right = mid + 1 ","date":"2022-04-19","objectID":"/binary_search/:5:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"实例研究 ","date":"2022-04-19","objectID":"/binary_search/:6:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"单一值查找情况 力扣-二分查找 模板一 初始时right必须是len - 1, 否则在left = mid + 1时，可能取到left == right 且 left == len， 访问越界数组! class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } }; 模板二 注意： 下面文字说明中 ”=“ 不表示赋值 下面这种情况，初始时right = len - 1, 结束条件为left == right 当target大于区间所有元素时，搜索区间右端点始终固定为len - 1 若最后搜索区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步left = mid + 1 = right = len - 1, 然后有 left == right, 搜索结束。不会出现越界的情况 当target小于区间所有元素时，搜索区间左端点始终固定为0 若最后搜素区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步right = mid = left, 此时left = right, 搜索结束。也不会出现越界 上述两种情况，最后都是left = right时结束，但left下标的值却没有验证检查是否等于target，所以最后要做一个补充检查。此时left取值范围在[0, len - 1], 很安全，所以直接取值判断即可。 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len - 1; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return nums[left] == target ? left : -1; } }; 下面情况， 我们将right初始值取为len，看看会发生什么变化 当target大于区间所有元素时，搜索区间右端点始终固定为len 若最后搜索区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步left = mid + 1 = right = len, 然后有 left == right, 搜索结束。注意这时left = len，下标已经越界了, 如果最后直接取nums[left]会访问越界！ 当target小于区间所有元素时，搜索区间左端点始终固定为0 若最后搜素区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步right = mid = left, 此时left = right, 搜索结束。也不会出现越界。 上述两种情况，最后都是left = right时结束，但left下标的值却没有验证检查是否等于target，同样最后要做一个补充检查，但是补充检查时，因为left取值范围为[0, len], 取值范围不安全，所以要多一个排除条件left != len。 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return (left != len \u0026\u0026 nums[left] == target) left : -1; } }; 再看看下面的代码，又在上面的代码上做了点小小的改动，即每次判断后下一搜索区间的取值范围，这里实际上把nums[mid] \u003e target条件下的right更新为了mid - 1, 可以看出没有丝毫影响，因为我们要找的是target, 当指明了target小于某个值，当然可以跳过该mid索引了，想一下，当nums[mid] == target时，我们为什么要取=mid, 因为满足此条件的任何mid索引对应的值都有可能出现在结果区间中，我们不能用left = mid + 1 或 right = mid - 1来跳过。那为什么不能取left=mid，这就是前文所述的死循环问题了，与mid取值有关，不做赘述。 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } return (left != len \u0026\u0026 nums[left] == target) ? left : -1; } }; 小结 可以看出对于寻找单一值得情况，模板二中初始值 right = len 还是 right = len - 1，都是可以找到结果得，只是最后left的取值区间不一致，当right取len时，left取值空间包括了len，应该在后处理中做出排除。 当搜索区间断点时，比如以下搜索出现数字的最小位置和最大位置的代码： int binarySearch(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size(); while(left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return (left != nums.size() \u0026\u0026 nums[left] == target) left : -1; } 下面代码中，区别在于当nums[mid] = target时，所采取的动作，当搜索最大索引时，收紧左边界，但是由于避免死循环，所以left = mid + 1,导致结果区间中，left 为 最大目标索引的下一个位置，所以目标索引应该取left - 1 或right - 1,又由于left的取值区间为[0, nums.size()] ， 但我们只需关心left - 1的取值区间，即[-1, nums.size() - 1],发现这种情况相对于搜索最小位置的代码而言，自然优化了区间右端点，却导致了左端点越界，所以要额外检查左端点越界的情况。 int binarySearch(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size(); while(left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= target) { left = mid + 1; } else (nums[mid] \u003e target) { right = mid; } } return (left != 0 \u0026\u0026 nums[left - 1] == target) ? (left - 1) : -1; } 所以我们又可以考虑，当搜索右端点时，right初始化为nums.size() - 1时，要作何改变，代码如下 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size() - 1; if (left == right) return nums[0] == target ? 0 : -1; while(left \u003c right) { int mid = left + (right - left) /","date":"2022-04-19","objectID":"/binary_search/:6:1","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["tools"],"content":"通用资源集 名校公开课程评价网 (conanhujinming.github.io) yet another insignificant Programming Notes (ntu.edu.sg) ","date":"2022-04-15","objectID":"/learing_resources/:1:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"操作系统 ","date":"2022-04-15","objectID":"/learing_resources/:2:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"推荐书籍 原理类 《操作系统设计与实现》Andrew S.Tanenbaum 《现代操作系统》Andrew S.Tanenbaum 《操作系统概念》Abraham Silberschatz 《Operating Systems: Three Easy Pieces》（OSTEP） 《深入理解计算机系统》（CSAPP） 《操作系统—精髓与设计原理》 《现代操作系统：原理与实现》（陈海波、夏虞斌等著，“银杏书”） 应用类 《Linux内核设计与实现》Robert Love ","date":"2022-04-15","objectID":"/learing_resources/:2:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"MIT6.S081 MIT6.S081操作系统导论 - 名校公开课程评价网 (conanhujinming.github.io) 课程翻译：简介 - MIT6.S081 (gitbook.io) MIT官方课程表： 6.S081 / Fall 2021 (mit.edu) xv6源码：mit-pdos/xv6-riscv: Xv6 for RISC-V (github.com) xv6-book (原版)：Lec01 Introduction and Examples (Robert) - MIT6.S081 (gitbook.io) xv6-book (翻译)：FrankZn/xv6-riscv-book-Chinese (github.com) 学习笔记： Docs (feishu.cn) 交流讨论: Docs (feishu.cn) 道友视频： 阿苏EEer的个人空间_哔哩哔哩_bilibili ","date":"2022-04-15","objectID":"/learing_resources/:2:2","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"ucore 课程地址：操作系统 - 清华大学 - 学堂在线 (xuetangx.com) ","date":"2022-04-15","objectID":"/learing_resources/:2:3","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"南大课程 实验地址：Introduction · GitBook (nju-projectn.github.io) 计算机系统基础实验：2020_spring_pa_0-1_环境配置和简介_哔哩哔哩_bilibili [完结] 2020 南京大学 “操作系统：设计与实现” (蒋炎岩)_哔哩哔哩_bilibili ","date":"2022-04-15","objectID":"/learing_resources/:2:4","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"计算机网络 ","date":"2022-04-15","objectID":"/learing_resources/:3:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"推荐书籍 原理类 《计算机网络 自顶向下方法》 《TCP/IP详解 卷1：协议》 《图解HTTP》 应用类 《Unix网络编程 卷1 Socket API/卷2 IPC》（UNP） 《TCP/IP详解 卷2：实现》 《TCP/IP详解 卷3：实现》 《TCP/IP网络编程》韩-尹圣雨 ","date":"2022-04-15","objectID":"/learing_resources/:3:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"中科大郑烇课程 《高级计算机网络》 中科大郑烇全套《高级计算机网络》_哔哩哔哩_bilibili 《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili ","date":"2022-04-15","objectID":"/learing_resources/:3:2","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"数据结构与算法 ","date":"2022-04-15","objectID":"/learing_resources/:4:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"推荐书籍 《算法导论》 《算法》 ","date":"2022-04-15","objectID":"/learing_resources/:4:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"C++ ","date":"2022-04-15","objectID":"/learing_resources/:5:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"推荐书籍 《Primer C++》 《Essential C++》 《Effective C++》 《Modern Effective C++》 《现代 C++ 教程：高速上手 C++ 11/14/17/20》 ","date":"2022-04-15","objectID":"/learing_resources/:5:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"视频教程 南科大于仕琪老师的C/C++课程 所有课程资料均开源，包括Lecture slides, Lecture notes和Lab。建议1.25倍速观看。 非常基础的入门课程，但是老师Hands on coding的教学方法和清晰的思路让学习者如沐春风。 ShiqiYu/CPP: Lecture notes, projects and other materials for Course ‘CS205 C/C++ Program Design’ at Southern University of Science and Technology. (github.com) 快速学习C和C++，基础语法和优化策略，学了不再怕指针(南科大计算机系原版) 彭于斌的高性能并行编程与优化课程 课程同样完全开源，视频，幻灯片，代码和作业都可在GitHub上找到。建议1.5倍速观看。 本课程的优势在于涉及面非常广，而且全是作者工程多年工程实践下来的精华（虽然作者只是个在校学生orz），从Cmake开始讲到编译器优化，从TBB讲到CUDA，涉及到C++编程规范和高性能编程的方方面面。 parallel101/course: 高性能并行编程与优化 - 课件 (github.com) https://www.bilibili.com/video/BV1fa411r7zp?share_source=copy_web ","date":"2022-04-15","objectID":"/learing_resources/:5:2","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"博客推荐 C++ 并发编程（从C++11到C++17） (paul.pub) ","date":"2022-04-15","objectID":"/learing_resources/:5:3","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"练手项目 有没有在线练习C++的网站？ - 知乎 (zhihu.com) ","date":"2022-04-15","objectID":"/learing_resources/:5:4","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"开源项目 ","date":"2022-04-15","objectID":"/learing_resources/:6:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["tools"],"content":"BRPC incubator-brpc · GitHub 百度内最常使用的工业级RPC框架, 有1,000,000+个实例(不包含client)和上千种多种服务。“brpc\"的含义是\"better RPC”。 重点关注下面几个文件： Task_group.cpp，bthread.cpp，futex.cpp，socket.cpp，channel.cpp 进阶 bvar实现，bthread_t使用 ","date":"2022-04-15","objectID":"/learing_resources/:6:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":[],"content":"C++语言 ","date":"2022-04-09","objectID":"/learning_route/:1:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"C++基础语法 头文件以及宏定义 const 与 constexpr auto 与 decltype using 与 命名空间 enum 枚举类 分离式编译 指针与引用 C++结构体与C结构体 传值方式 静态变量static volatile关键字 隐式类型转换与 explicit 关键字 类型转换 static_cast\u003c\u003e, dynamic_cast\u003c\u003e Lambda表达式 ","date":"2022-04-09","objectID":"/learning_route/:1:1","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"面向对象 面向对象理解：封装、继承、多态 struct 与 class区别 构造函数 初始化列表：顺序 默认构造函数 拷贝构造函数 移动构造函数 重载和重写 运算符重载 拷贝赋值运算符 多态与虚函数 多态：编译器多态（模板），运行时多态（重写） ","date":"2022-04-09","objectID":"/learning_route/:1:2","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"C++标准库 IO库 IO类： iostream 文件输入输出： fstream string流：sstream 标准模板库（STL） 序列容器(vector,list,deque) vector: 扩容 list: 双向列表 deque: 多node组合 关联容器 (multi) unordered_map/set : Hash Table + 链表/红黑树 (multi) map/set : 红黑树，有序 STL6大组成部分 容器(Container)、算法(Algorithm)、迭代器(Iterator) 适配器(Adapter)、分配器(Alloctor)、仿函数(Functor) string类 ","date":"2022-04-09","objectID":"/learning_route/:1:3","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"动态内存与智能指针 shared_ptr unique_ptr new 与 delete 右值引用 (\u0026\u0026) 与 对象移动(std::move) ","date":"2022-04-09","objectID":"/learning_route/:1:4","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"异常处理 抛出异常 捕获异常 异常类层次 ","date":"2022-04-09","objectID":"/learning_route/:1:5","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"数据结构与算法 ","date":"2022-04-09","objectID":"/learning_route/:2:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"数据结构 链表 单向链表 双向链表 队列 环形队列 栈 双栈 堆 建堆、调整堆 大顶堆、小顶堆 二叉树 完全二叉树 先序遍历、中序遍历、后序遍历 二分查找树BST 红黑树 b树、b+树 图 有向图、无向图 邻接表、邻接矩阵、稀疏矩阵 散列表（Hash Table） 跳表 布隆过滤器 ","date":"2022-04-09","objectID":"/learning_route/:2:1","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"算法 排序: 快排、归并、堆排序 、希尔 分治法、减治法，二分查找 图算法：dijkstra算法，最小生成树Kruskal DFS，BFS 贪心算法 动态规划 ","date":"2022-04-09","objectID":"/learning_route/:2:2","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"操作系统 ","date":"2022-04-09","objectID":"/learning_route/:3:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"基本概念 用户态/内核态 系统调用 ","date":"2022-04-09","objectID":"/learning_route/:3:1","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"内存管理 物理内存/虚拟内存 虚拟地址映射 分页，页表 页面置换算法 缺页中断 内存池 ","date":"2022-04-09","objectID":"/learning_route/:3:2","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"进程与线程 进程 孤儿进程 僵尸进程 守护进程 线程 IPC 管道、命名管道 信号Signal 信号量Semaphore Socket 共享内存shared memory 内存映射mman ","date":"2022-04-09","objectID":"/learning_route/:3:3","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"死锁 互斥 互斥锁 读写锁 同步 信号量 条件变量+互斥锁 ","date":"2022-04-09","objectID":"/learning_route/:3:4","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"文件系统 磁盘文件系统 虚拟文件系统 文件系统实现原理 ","date":"2022-04-09","objectID":"/learning_route/:3:5","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"IO ","date":"2022-04-09","objectID":"/learning_route/:3:6","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"Linux系统实操 shell / vi的使用 Linux系统性能监控参数 ps / netstat / df ","date":"2022-04-09","objectID":"/learning_route/:3:7","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"数据库 关系型数据库(MySQL) MySQ安装与配置 sql建表，索引，存储过程 存储引擎，myissam/innodb 数据库连接池 异步数据库请求 数据库集群， 分库分表，读写分离 NoSQL(Redis) Redis编译安全，配置 Redis命令使用 Redis连接池/异步Redis的做法 Redis集群，数据备份 缓存雪崩，缓存击穿 ","date":"2022-04-09","objectID":"/learning_route/:4:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"网络原理 网络体系模型 TCP三次握手，四次挥手，滑动窗口，状态机 UDP的原理 http/https/http2.0/http3.0 Session Cookie application 网络安全，加密，数字签名 wireshark, tcpdump iperf ","date":"2022-04-09","objectID":"/learning_route/:5:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"网络编程 ping, telnet, ifconfig 使用 socket编程， tcp/udp 网络IO模型，阻塞/非阻塞，同步异步 io多路复用 select/poll/epoll epoll reactor, proactor time_wait/close_wait大量 C10K/C1000K/C10M 网络框架 libevent/libv 协程 ntyco, libco ","date":"2022-04-09","objectID":"/learning_route/:6:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"设计模式 设计原则 创建型模式 单例模式 工厂模式 结构型模式 适配器模式 代理模式 组合模式 装饰模式 行为型模式 策略模式 观察者模式 迭代器模式 模板方法模式 命令模式 ","date":"2022-04-09","objectID":"/learning_route/:7:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"并行与分布式系统  ","date":"2022-04-09","objectID":"/learning_route/:8:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":["Computer Network"],"content":"可靠数据传输原理 可靠数据传输(Reliable Data Transfer)是一个很大的概念，在计算机网络的五层模型中，它可以出现在传输层、数据链路层和应用层。简单点说，可靠数据传输服务保证了通信过程中的数据接收方接收到的数据与其从数据发送方发出的数据一致。而提供这种可靠数据传输服务的协议称为可靠数据传输协议，例如传输层的TCP协议。 可靠数据传输为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。在这条信道中传输的数据bit不会受到损坏和或丢失，而且所有的数据都是按其发送顺序交付。其对应的服务框架如下图所示，TCP协议向调用它的因特网应用所提供的服务模型恰恰如此，所以当谈到可靠数据传输时，不可避免地会涉及大量TCP协议的分析。 那么一个网络协议要实现可靠数据传输需要具备哪些特性呢？或者说，协议中需要设定哪些规则来避免数据传输的不可靠？为了数据传输的可靠，我们就要解决数据不可靠的情况，而数据传输的不可靠的情形最基本的有如下几种： 数据在信道中传输时，比特出现了错误，例如本来该bit为0，到了接收端却成为了1 数据在信道中传输时，比特发生了丢失，例如本来按序发送了16个比特，结果到了接收端只收到了8个比特 数据在信道中传输时，比特流的顺序发生了变化，例如发送端按照序号1，2，3，4，5发送的比特流，结果到了接收端收到是1，3，2，5，4 数据在信道中传输时，接收端接收到了重复的数据，例如发送端按照序号1，2，3发送，到了接收端收到是1，2，2，3 先思考一下，针对上面的若干基本情况，我们要怎么处理。首先数据在接收方出现了不一致的情况，我们如何得知呢？这就需要通过差错检测机制，通过差错检测，我们可以检测到何时何处出现了比特差错。然后，出现了差错该怎么办呢？作为接收方，肯定要告诉发送方我收到的数据有问题，所以就要有接收方反馈功能，也就是接收方发送明确的反馈信息给发送方。那么发送方接收了该反馈信息又该怎么做呢？最基本且有效的情况无非就是重新发送一份错误数据对应的原数据，也就是重传。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:1:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"可靠数据传输特征 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"差错检测 ​ 差错检测主要的实现方式就是在传输的数据流中添加额外的比特信息以增加冗余度，主要分为两大类：奇偶效验和分组检验。其中分组校验中典型的方法有校验和法（IP数据报）和循环冗余校验法。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"接收方反馈 一般是给出肯定确认ACK或否定确认NAK，也可以通过冗余ACK的方式代替否定确认。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"重传 在分组传送时，主要有累积重传和选择重传。 通过上述几个功能，我们可以设计出能够工作的协议，但是，仔细想象一下你就会发现，这个步骤中有一个致命缺陷。在接收方给发送方发送反馈信息时，假设这个反馈信息也出了错误，那么发送方就无法知道接收方是否正确接收上一次发送的数据了。 再思考一下，如果我们是协议设计者，会怎么做？可以考虑以下几种方式： 发送方接收到错误的反馈信息表示无法理解时，便又向接收方发送针对该反馈信息的解释请求，即引入了一种新型的从发送方到接收方的分组。就像打电话时一方不理解另一方时会提问“你说啥？”，另一方则会重复回答。要是这个“你说啥”也产生了差错，岂不又是越陷越深了。 增加足够的检验和比特，使得发送方不但可以检测差错还可以恢复差错，对于只产生错误而没有丢失的分组，就可以直接解决问题。 当发送方收到含糊不清的反馈信息后，只需要重传当前数据分组即可。这种方法在信道中引入了冗余分组。而冗余分组所带来一个问题就是，接收方不知道它上次发送的反馈信息是否被发送方正确接收，也就是说接收方无法事先知道接收到的分组时新的还是一次重传，这很重要，因为如果将重传分组当作新的分组，那么数据包就会出错了。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:3","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"序号 ​为了解决上述冗余分组中的问题，我们就又提出一种协议功能，就是给数据分组编号，这也是包括TCP在内所有的数据分组采用的方法。即在数据分组中添加一个新的字段，让发送方对其数据分组编号，将发送数据分组的序号放在该字段。于是，接收方只需要检查序号就可以确定该分组是否是一次重传了。对于停等协议（Stop and Wait，SW）来说，该字段只需要一个比特即可。因为停等协议中，发送方必须等待接收方传回ACK或NAK才能继续发送下一个数据分组。 除了具备差错检测与恢复外，我们还需要考虑当分组丢失分情况，而上面的协议功能不足以解决分组丢失的问题。当发送方发送一个数据后，在信道中丢失，接收方自然没有收到数据从而不会发送反馈，于是发送方迟迟没有收到确认。这时候，我们一般情况下都是会等待一定时间后重新发送该分组。所以我们又引入一个新的协议功能：倒计数定时器，通过设定一个给定的时间量，当时间量过期后，便重传分组。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:4","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"倒计数定时器 为了容忍数据丢失，我们在发送方引入倒计数定时器。即1. 每次发送一个分组时（包括第一次分组和重传分组），启动一个定时器。2. 响应定时器中断（采取适当动作，比如重传）。3. 终止定时器。 综上，在实现了差错检测，接收方反馈，重传，序号，倒计数定时器这些协议功能后，就可以得到一个可靠数据传输协议了。 具备上述协议功能的协议分为两种，一种是停止-等待协议，一种是流水线协议，后者是前者的加强版，提升了信道的利用率。实际上ARQ协议也是分为了类似的两类。说到ARQ，那么就介绍一下它：  ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。其中，连续ARQ就是一种流水线协议。 我们说到流水线协议相对于停止等待协议增加了信道的利用率，但是也带来了一定程度的局限性。例如： 流水线协议必须增加序号的范围，因为每个传输中的分组必须有一个唯一的序号用来区分分组，而且也许在输送中存在多个未确认的报文。而停止等待协议只需一个比特位来给分组编号（即比特交替协议） 协议的发送方和接收方两端也许必须缓存多个分组。这样做的目的是为了差错恢复，这取决于协议如何处理丢失、损坏以及时延过大的分组所需序号范围i和对缓冲的要求取决于数据传输协议如何 流水线协议中差错恢复的两种方法：回退N步（Go-Back-N,GBN）和选择重传（Selective Repeat,SR）。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:5","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"回退N步协议(GBN) 回退N步协议允许发送方发送多个分组而不确认，但是其在流水线中未确认的分组的数量不能超过N。这个协议又被称作滑动窗口协议，是因为流水线中已被发送但还未被确认的分组的许可范围构成了一个在序号范围内长度为N的窗口，N就是窗口的大小，随着协议运行，该窗口的序号空间不断向前滑动。思考一下，为什么要设置这么一个窗口呢？其实是为了流量控制和拥塞控制的需要，我们将在后文介绍。 在GBN中，发送方必须响应的三种类型事件是： 上层的调用。 收到一个ACK，该协议对序号为n的分组的确认采取累积确认的方式，表明接收方已经正确接收到序号为n的以前且包括n在内的所有分组。 超时事件，go-back N行为正来自出现丢失或时延过长分组时发送方采取的差错恢复行为。同样也用到了定时器，出现超时的时候，发送方将重传所有已发送但还未被确认的分组，所以在发送方缓存这些分组是十分必要的。如果收到一个ACk,但仍有已发送但未确认的分组，则定时器会被重新启动，如果没有则会终止。 GBN协议中，接收方会丢弃失序的分组，因为GBN采用累积确认，一次交付给上层一个分组，接收方必须按序将数据交付给上层，丢失分组是一种简单的方法之一，另外的一种就是放在接收方缓存起来，等带下一个按序的分组，最后在组装正确的数据交付。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:3:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"选择重传协议(SR) GBN虽然采用了流水线解决了信道利用率的问题，但是也会存在另外的性能问题，例如当窗口长度很大或者带宽时延积都很大时，在流水线中有更多的分组时更甚。因为在这些情况下，必须重传大量分组，代价太大了，也许只是窗口中诸多分组的一个或几个分组出现错误，便要重传全部已经发送但未确认的分组，未免太浪费了。 而选择重传机制就是让发送方仅仅重传那些它怀疑在接收方出错(丢失或受损)的分组，从而避免了不必要的重传。但是这种方式就不能采用累积确认了，而是要求接收方逐个地确认正确接收的分组。即接收方确认正确的分组不管其是否失序，失序的分组将被缓存直到所有比失序分组序号小的分组都被接收为止，才会将一批分组按序交付。 但是这种方式会带来一个问题，就是接收方和发送方的窗口并不是总是一致的，因为对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不是总能看到一样的结果。这意味着，当序号范围有限时，发送方和接收窗口之间缺乏同步会产生严重的后果。这就要求SR协议中，窗口长度必须小于或等于序号空间大小的一半。后续将证明。 到现在为止，我们介绍了若干可靠传输机制，下表是一个总结。 机制 用途和说明 检验和 用于检测在一个传输分组中的比特错误 定时器 用于超时/重传一个分组,可能因为该分组(或其ACK)在信道中丢失了。由于当一个分组延时但未丢失，或当一个分组已被接收方接收但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本 序号 用于为从发送方流向接收方的数据分组按序号编号。所接受分组的序号的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本 确认 接收方用于告诉发送方一个分组或一组分组已经被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或积累的，这取决于协议 否定确认 接收方用于告诉发送方某个分组未被正确的接收.否则人确定报文通常携带着未被正确接收的分组的序号 窗口、流水线 发送方也许被限制仅发送那些序号落在一个指定范围内的分组.通过允许一次发送多个分组但未被确认,发送方的利用率可以在停等操作模式上得到增加。我们很快将会看到,窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者的情况来进行设置 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:4:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"从TCP协议中看可靠数据传输 介绍了可靠数据传输的基本原理之后，我们再来探讨一种典型的可靠数据传输协议——TCP，TCP是因特网运输层的面向连接的可靠的运输协议。 TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。 TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手来关闭一个连接 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP报文段结构 16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。 32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。 32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。 4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示 15，所以 TCP 头部最长是60 字节 6 位标志位包含如下几项： URG 标志，表示紧急指针（urgent pointer）是否有效。 ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文段。 16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。 这也是 TCP 可靠传输的一个重要保障。 16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP三次握手 1、三次握手是什么？ 三次握手其实就是指在建立TCP连接时需要客户端和服务器端总共发送三个数据包，主要作用是确认服务器端和客户端的发送和接受能力是否正常，指定自己的初始序列号为后面的可靠性传输作准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息 第一次握手: 客户端向服务器端发送一个SYN报文，并指明自己的初始序列号ISN，此时客户端处于SYN_SEND状态。 首部的同步位SYN=1，初始序列号seq=1，SYN=1的报文段不能携带数据，但要消耗掉一个序号 第二次握手：服务器端在收到客户端的SYN报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。 2、为什么需要三次握手，两次不行吗？ 弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 因此，需要三次握手才能确认双方的接收与发送能力是否正常。 试想如果是用两次握手，则会出现下面这种情况： 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源 3、什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…… 4、ISN(Initial Sequence Number)是固定的吗？ 当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。 三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 5、三次握手过程中可以携带数据吗？ 其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据 为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。 6、SYN攻击是什么？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 netstat -n -p TCP | grep SYN_RECV 常见的防御 SYN 攻击的方法有如下几种： 缩短超时（SYN Timeout）时间 增加最大半连接数 过滤网关防护 SYN cookies技术  ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP滑动窗口 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。 、 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:3","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP四次挥手 1、四次挥手过程? 建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下： 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。 收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。 在socket编程中，任何一方执行close()操作即可产生挥手操作。 2、挥手为什么需要四次？ 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。 3、2MSL等待状态 TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。 对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。 这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。 4、四次挥手释放连接时，等待2MSL的意义? MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。 两个理由： 保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 5、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？ 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:4","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP状态转换 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:5","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"流量控制 TCP 利用滑动窗口实现流量控制 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。 TCP的两端都有发送/接收缓存和发送/接收窗口。TCP的缓存是一个循环队列。在进程调用send()发送的数据的时候，会将数据拷贝进入内核的socket发送缓冲区之中，然后send便会在上层返回。换句话说，send返回之时，数据不一定会发送到对端去。接收缓冲区把数据缓存入内核，应用进程如果一直没有调用recv()进行读取的话，此数据会一直缓存在相应socket的接收缓冲区内。不管进程是否调用recv()读取socket，对端发来的数据都会经由内核接收并且缓存到socket的内核接收缓冲区之中。 发送缓存中的发送窗口可以用3个指针表示。已发送但未被确认数据大小\u003c=发送窗口的大小。已被确认的数据会从发送缓存中删除。然后发送窗口整体向左移。此外要说明一下，接受方的接受窗口是指接受方中的接受缓存中剩余可用空间大小，该值会通知给发送端调整发送窗口，从而控制流量。 发送方应用程序必须控制写入缓存的速率，不能太快，否则发送缓存会没有存放数据的空间。但是，linux下可以动态调整缓冲区的大小。发送缓冲区的动态调整比较简单，当发送缓冲区的剩余空间充足的时候，可以减小发送缓冲区的大小，反之则增加缓冲区的大小。 cat /proc/sys/net/ipv4/tcp_wmem 4096 87380 4194304 // 4096表示缓冲区的最小大小，4194304表示缓冲区的最大大小，87380 表示默认值 发送窗口的大小受TCP数据报中窗口大小的影响，TCP数据报中的窗口大小是接收端通知发送端其还可以接收多少数据，因此发送窗口根据接收的的窗口大小的值动态变化。需要明确的是，发送窗口只是发送缓存的一部分。 接受缓存区也可以自动调整，在高并发的场景中可以降低默认的缓冲区大小，提高并发性。 cat /proc/sys/net/ipv4/tcp_rmem 4096 87380 4194304 查看是否开启接受缓冲区自动调整的功能 cat /proc/sys/net/ipv4/tcp_moderate_rcvbuf 4096 87380 4194304 发送缓冲区自动调节的依据是待发送的数据，接收缓冲区由于只能被动地等待接收数据，它该如何自动调整呢？可以依据空闲系统内存的数量来调节接收窗口。如果系统的空闲内存很多，就可以把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而对方的发送速度就会通过增加飞行报文（发送还未确认的报文）来提升。反之，当内存紧张时就会缩小缓冲区，这虽然会减慢速度，但可以保证更多的并发连接正常工作。需要注意，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样做就可以避免了丢包情况。 当接受缓存满并且系统不再有内存分配调整大小，此时接受方会发送零窗口大小的报文，具体做法是将返回的确认（ACK）报文的窗口值大小设置为0（窗口关闭），让发送方停止发送数据。之后接收方有足够的缓存，再发送非零窗口大小的报文。 此外，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。这样做是为了避免发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，使得变成相互等待，会造成了死锁的现象 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:6:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"拥塞控制 在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的包丢失，此时网络拥塞将会进入恶性循环并且不断地放大。 拥塞控制协议维护着一个拥塞窗口，会根据网络的拥塞状态而动态调整，其调整规则为1.只要网络中没有出现拥塞，cwnd 就会增大；2. 网络中如果出现了拥塞，cwnd 就减少。加入拥塞窗口后，此时发送窗口swnd = min(cwnd(拥塞窗口), rwnd(接受窗口)) 那么如何判断是否出现网络拥塞呢？一种简单的方法就是只要发生了丢包，触发超时重传就会判定网络出现拥塞。 TCP 在刚建立连接完成后，首先是有个慢启动的过程，以指数性的提高发送数据包的数量。当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。当慢启动一段时间后，达到慢启动门限 ssthresh，就会改用拥塞避免模式，进行线性增大。当网络出现超时重传（拥塞）时，门限值调整为一半，cwnd=1，然后改为执行慢启动模式。当网络出现快速重传（拥塞）时，cwnd = cwnd/2，ssthresh = cwnd，然后改为执行拥塞避免模式。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"慢开始+拥塞避免 （1）拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16； （2）执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长； （3）假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=cwnd/2=12，cwnd重新设置为1，并执行慢开始算法。 （4）当cwnd=12=ssthresh时，改为执行拥塞避免算法。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"快重传+快恢复 快重传(Fast retransmit) 快速重传(Fast retransmit)要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。 快恢复(Fast Recovery) （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。此时直接进入拥塞避免。请注意：接下来不执行慢开始算法。 （2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"拥塞控制与流量控制区别 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:3","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"参考 【计算机网络】学习笔记汇总（目录）（谢希仁） - 知乎 (zhihu.com) ","date":"2022-01-07","objectID":"/reliable_data_transfer/:8:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["C/C++"],"content":"本文只是简单介绍用GCC编译C或C++文件的基本流程，不涉及对编译和链接的深入分析 ","date":"2021-05-19","objectID":"/compile_link/:0:0","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"GCC 编译工具 GCC是一款强大的编译工具，下文在介绍c以及c++程序的编译运行流程中将采用gcc做示例。 GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由 [2] 。 GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言编 译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数 -std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 \u003e 4.8.5） 查看版本 gcc/g++ -v/--version ","date":"2021-05-19","objectID":"/compile_link/:1:0","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"1.gcc 和 g++ 的关系 gcc 和 g++都是GNU(组织)的一个编译器。 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的 宏__cplusplus只是标志着编译器将会把代码按 C 还是 C++ 语法来解释，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义 编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++ gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价 ","date":"2021-05-19","objectID":"/compile_link/:1:1","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"2.gcc 常用编译参数 -E 预处理指定的源文件，不进行编译 -S 编译指定的源文件，但是不进行汇编 -c 编译、汇编指定的源文件，但是不进行链接 -o [file1] [file2] /[file2] -o [file1] 将文件 file2 编译成可执行文件 file1 -I directory 指定 include 包含文件的搜索目录 -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -On n的取值范围：0~3。编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高 -l 在程序编译的时候，指定使用的库 -L 指定编译的时候，搜索的库的路径。 -fPIC/fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 指定C方言，如:-std=c99，gcc默认的方言是GNU C ","date":"2021-05-19","objectID":"/compile_link/:1:2","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"3.GCC 工作流程 GCC工作流程也就是一个c/c++语言程序从编译到生成可执行程序的过程，如下图所示。 下面分别介绍各个阶段,我们的示例代码如下： . ├── include │ ├── mymath.c │ └── mymath.h └── test.c test.c #include \u003cstdio.h\u003e#include \"mymath.h\" int main(int argc, char **argv) { int a = 2, b = 3; int sum = add(a, b); printf(\"a=%d, b=%d, a+b=%d\", a, b, sum); return 0; } mymath.h #ifndef MYMATH_H #define MYMATH_H int add(int a, int b); int sub(int a, int b); int mul(int a, int b); double div(int a, int b); #endif mymath.c int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } int mul(int a, int b) { return a * b; } double div(int a, int b) { return a * 1.0 / b; } ","date":"2021-05-19","objectID":"/compile_link/:1:3","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"1.预处理（Preprocessing） 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。 预处理器的主要作用就是: 把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有: 文件包含，条件编译、布局控制和宏替换4种。 文件包含: #include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。 条件编译: #if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。 布局控制: #pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。 宏定义展开: #define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。 gcc的预处理是预处理器cpp来完成的，你可以通过如下命令对test.c进行预处理 : # -I 指定头文件目录 # -E 指定编译器在预处理后就退出，不再进行后续编译过程 # -o 指定输出的文件名 gcc -E test.c -I ./include -o test.i # 或者直接用cpp命令 cpp test.c -I ./include -o test.i 执行结果为： -rw-r--r-- 1 lwy lwy 106 Apr 6 20:56 test.c -rw-r--r-- 1 lwy lwy 16349 Apr 6 21:14 test.i 看得出来经过预处理后的文件比源文件要大很多，预处理之后的程序还是文本，可以用文本编辑器打开。其内容大致如下： # 1 \"test.c\" # 1 \"\u003cbuilt-in\u003e\" # 1 \"\u003ccommand-line\u003e\" # 31 \"\u003ccommand-line\u003e\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4# 32 \"\u003ccommand-line\u003e\" 2 # 1 \"test.c\" # 1 \"/usr/include/stdio.h\" 1 3 4# 27 \"/usr/include/stdio.h\" 3 4 ... typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; ... # 4 \"test.c\" int main(int argc, char **argv) { printf(\"hello world\"); return 0; } ","date":"2021-05-19","objectID":"/compile_link/:2:0","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"2.编译（Compilation） 这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。编译的指令如下： gcc -S -I ./include test.c -o test.s 上述命令中-S让编译器在编译之后停止，不进行后续过程。编译过程完成后，将生成程序的汇编代码test.s，内容如下： .file \"test.c\" .text .section .rodata .LC0: .string \"hello world\" .text .globl main .type main, @function main: .LFB0: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl %edi, -4(%rbp) movq %rsi, -16(%rbp) leaq .LC0(%rip), %rdi movl $0, %eax call printf@PLT movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident \"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04) 9.4.0\" .section .note.GNU-stack,\"\",@progbits .section .note.gnu.property,\"a\" .align 8 .long 1f - 0f .long 4f - 1f .long 5 0: .string \"GNU\" 1: .align 8 .long 0xc0000002 .long 3f - 2f 2: .long 0x3 3: .align 8 4: ","date":"2021-05-19","objectID":"/compile_link/:3:0","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"3.汇编（Assemble） 汇编过程将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。gcc汇编过程通过gcc -c命令完成： gcc -c test.s -o test.o gcc -c ./include/mymath.c -o ./include/mymath.o 这一步会为每一个源文件产生一个目标文件。因此mymath.c也需要产生一个mymath.o文件 . ├── include │ ├── mymath.c │ ├── mymath.h │ └── mymath.o ├── test.c ├── test.i ├── test.o └── test.s ","date":"2021-05-19","objectID":"/compile_link/:4:0","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["C/C++"],"content":"4.链接（Linking） 链接过程将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file),其命令如下 gcc -o test.out test.o include/mymath.o # 这里用g++也可，当是c++程序时倾向使用g++ 目录树： . ├── include │ ├── mymath.c │ ├── mymath.h │ └── mymath.o ├── test.c ├── test.i ├── test.o ├── test.out └── test.s 结果为： lwy@lwysLaptop:~/workspace/test$ ./test.out hello world 经过以上分析，我们发现编译过程并不像想象的那么简单，而是要经过预处理、编译、汇编、链接。尽管我们平时使用gcc命令的时候没有关心中间结果，但每次程序的编译都少不了这几个步骤。也不用为上述繁琐过程而烦恼，因为你仍然可以： gcc/g++ -c test.c -o test.out ","date":"2021-05-19","objectID":"/compile_link/:5:0","tags":["C/C++","GNU","Compile"],"title":"程序从编辑到链接简介","uri":"/compile_link/"},{"categories":["Computer Network"],"content":"IO多路复用简介 I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll 100%弄明白5种IO模型 - 知乎 (zhihu.com) 聊聊Linux 五种IO模型 - 简书 (jianshu.com) 本文仅介绍Multiplexing IO。 ","date":"2021-05-12","objectID":"/io_multiplexing/:1:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"select 主旨思想： 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O 操作时，该函数才返回。 这个函数是阻塞 函数对文件描述符的检测的操作是由内核完成的 在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作 // sizeof(fd_set) = 128 1024 #include \u003csys/time.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003csys/select.h\u003eint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); - 参数： - nfds : 委托内核检测的最大文件描述符的值 + 1 - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性 - 一般检测读操作 - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲 区 - 是一个传入传出参数 - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性 - 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写） - exceptfds : 检测发生异常的文件描述符的集合 - timeout : 设置的超时时间 struct timeval { long tv_sec; /* seconds */ long tv_usec; /* microseconds */ }; - NULL : 永久阻塞，直到检测到了文件描述符有变化 - tv_sec = 0 tv_usec = 0， 不阻塞 - tv_sec \u003e 0 tv_usec \u003e 0， 阻塞对应的时间 - 返回值 : - -1 : 失败 - \u003e0(n) : 检测的集合中有n个文件描述符发生了变化 // 将参数文件描述符fd对应的标志位设置为0 void FD_CLR(int fd, fd_set *set); // 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1 int FD_ISSET(int fd, fd_set *set); // 将参数文件描述符fd 对应的标志位，设置为1 void FD_SET(int fd, fd_set *set); // fd_set一共有1024 bit, 全部初始化为0 void FD_ZERO(fd_set *set) ","date":"2021-05-12","objectID":"/io_multiplexing/:2:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"poll #include \u003cpoll.h\u003estruct pollfd { int fd; /* 委托内核检测的文件描述符 */ short events; /* 委托内核检测文件描述符的什么事件 */ short revents; /* 文件描述符实际发生的事件 */ }; struct pollfd myfd; myfd.fd = 5; myfd.events = POLLIN | POLLOUT; int poll(struct pollfd *fds, nfds_t nfds, int timeout); - 参数： - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合 - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1 - timeout : 阻塞时长 0 : 不阻塞 -1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞 \u003e0 : 阻塞的时长 - 返回值： \u003e0（n） : 成功,n表示检测到集合中有n个文件描述符发生变化 ","date":"2021-05-12","objectID":"/io_multiplexing/:3:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"epoll #include \u003csys/epoll.h\u003e// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向 链表）。 int epoll_create(int size); - 参数： size : 目前没有意义了。随便写一个数，必须大于0 - 返回值： -1 : 失败 \u003e 0 : 文件描述符，操作epoll实例的 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; 常见的Epoll检测事件： - EPOLLIN - EPOLLOUT - EPOLLERR // 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); - 参数： - epfd : epoll实例对应的文件描述符 - op : 要进行什么操作 EPOLL_CTL_ADD: 添加 EPOLL_CTL_MOD: 修改 EPOLL_CTL_DEL: 删除 - fd : 要检测的文件描述符 - event : 检测文件描述符什么事情 // 检测函数 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); - 参数： - epfd : epoll实例对应的文件描述符 - events : 传出参数，保存了发送了变化的文件描述符的信息 - maxevents : 第二个参数结构体数组的大小 - timeout : 阻塞时间 - 0 : 不阻塞 - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞 - \u003e 0 : 阻塞的时长（毫秒） - 返回值： - 成功，返回发送变化的文件描述符的个数 \u003e 0 - 失败 -1 struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; 常见的Epoll检测事件： - EPOLLIN - EPOLLOUT - EPOLLERR - EPOLLET ","date":"2021-05-12","objectID":"/io_multiplexing/:4:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"LT模式（Level Triggerd） 假设委托内核检测读事件 -\u003e 检测fd的读缓冲区 读缓冲区有数据 - \u003e epoll检测到了会给用户通知  a. 用户不读数据，数据一直在缓冲区，epoll 会一直通知  b. 用户只读了一部分数据，epoll会通知  c. 缓冲区的数据读完了，不通知 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的 ","date":"2021-05-12","objectID":"/io_multiplexing/:4:1","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"ET模式（Edge Triggerd） 假设委托内核检测读事件 -\u003e 检测fd的读缓冲区 读缓冲区有数据 -\u003e epoll检测到了会给用户通知  a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了  b.用户只读了一部分数据，epoll不通知  c.缓冲区的数据读完了，不通知 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死 ","date":"2021-05-12","objectID":"/io_multiplexing/:4:2","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"Socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 ","date":"2021-04-17","objectID":"/unix_socket/:1:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序 现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码/译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。 字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 ","date":"2021-04-17","objectID":"/unix_socket/:2:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序举例 ","date":"2021-04-17","objectID":"/unix_socket/:2:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序转换 当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换） 网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。 // h - host 主机，主机字节序 // to - 转换成什么 // n - network 网络字节序 // s - short unsigned short // l - long unsigned in #include \u003carpa/inet.h\u003e// 转换端口 uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序 uint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序 // 转IP uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序 uint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序 ","date":"2021-04-17","objectID":"/unix_socket/:2:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"Socket地址 ","date":"2021-04-17","objectID":"/unix_socket/:3:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"通用Socket地址 socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下： #include \u003cbits/socket.h\u003estruct sockaddr { sa_family_t sa_family; char sa_data[14]; }; typedef unsigned short int sa_family_t; sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示: 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP/IPv4协议族 PF_INET6 AF_INET6 TCP/IPv6协议族 宏 PF_* 和 AF_* 都定义在 bits/socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用 sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示 协议族 地址值的含义和长度 PF_UNIX 文件的路径名，长度可以达到108字节 PF_INET 16bit 端口号和32bit IPv4 地址，共6字节 PF_INET6 16bit 端口号，32bit 流标识，128bit IPv6 地址，32bit范围ID,共26字节 由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的： #include \u003cbits/socket.h\u003estruct sockaddr_storage { sa_family_t sa_family; unsigned long int __ss_align; char __ss_padding[ 128 - sizeof(__ss_align) ]; }; typedef unsigned short int sa_family_t; ","date":"2021-04-17","objectID":"/unix_socket/:3:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"专用Socket地址 很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型 UNIX 本地域协议族使用如下专用的 socket 地址结构体： #include \u003csys/un.h\u003estruct sockaddr_un { sa_family_t sin_family; char sun_path[108]; }; TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6: #include \u003cnetinet/in.h\u003estruct sockaddr_in { sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */ in_port_t sin_port; /* Port number. */ struct in_addr sin_addr; /* Internet address. */ /* Pad to size of `struct sockaddr'. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; }; struct in_addr { in_addr_t s_addr; }; struct sockaddr_in6 { sa_family_t sin6_family; in_port_t sin6_port; /* Transport layer port # */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* IPv6 scope-id */ }; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef uint16_t in_port_t; typedef uint32_t in_addr_t; #define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)) 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。 ","date":"2021-04-17","objectID":"/unix_socket/:3:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"IP地址转换 通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换： #include \u003carpa/inet.h\u003ein_addr_t inet_addr(const char *cp); int inet_aton(const char *cp, struct in_addr *inp); char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址： #include \u003carpa/inet.h\u003e// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 int inet_pton(int af, const char *src, void *dst); af:地址族： AF_INET AF_INET6 src:需要转换的点分十进制的IP字符串 dst:转换后的结果保存在这个里面 // 将网络字节序的整数，转换成点分十进制的IP地址字符串 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); af:地址族： AF_INET AF_INET6 src: 要转换的ip的整数的地址 dst: 转换成IP地址字符串保存的地方 size：第三个参数的大小（数组的大小） 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 ","date":"2021-04-17","objectID":"/unix_socket/:4:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"套接字函数 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e#include \u003carpa/inet.h\u003e // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol); - 功能：创建一个套接字 - 参数： - domain: 协议族 AF_INET : ipv4 AF_INET6 : ipv6 AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信） - type: 通信过程中使用的协议类型 SOCK_STREAM : 流式协议 SOCK_DGRAM : 报式协议 - protocol : 具体的一个协议。一般写0 - SOCK_STREAM : 流式协议默认使用 TCP - SOCK_DGRAM : 报式协议默认使用 UDP - 返回值： - 成功：返回文件描述符，操作的就是内核缓冲区。 - 失败：-1 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命 名 - 功能：绑定，将fd 和本地的IP + 端口进行绑定 - 参数： - sockfd : 通过socket函数得到的文件描述符 - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息 - addrlen : 第二个参数结构体占的内存大小 int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn - 功能：监听这个socket上的连接 - 参数： - sockfd : 通过socket()函数得到的文件描述符 - backlog : 未连接的和已经连接的和的最大值， 5 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接 - 参数： - sockfd : 用于监听的文件描述符 - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port） - addrlen : 指定第二个参数的对应的内存大小 - 返回值： - 成功 ：用于通信的文件描述符 - -1 ： 失败 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); - 功能： 客户端连接服务器 - 参数： - sockfd : 用于通信的文件描述符 - addr : 客户端要连接的服务器的地址信息 - addrlen : 第二个参数的内存大小 - 返回值：成功 0， 失败 -1 ssize_t write(int fd, const void *buf, size_t count); // 写数据 ssize_t read(int fd, void *buf, size_t count); // 读数 示例如下： 服务器端 #include \u003carpa/inet.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e int main() { // 1 创建socket， 用于监听 int lfd = socket(AF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 绑定端口 struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_pton(AF_INET, \"172.25.93.158\", \u0026sockaddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr *)\u0026saddr, sizeof(saddr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 监听 ret = listen(lfd, 8); if (ret == -1) { perror(\"listen\"); exit(-1); } // 4 接受连接 struct sockaddr_in clientaddr; socklen_t len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr *)\u0026clientaddr, \u0026len); if (cfd == -1) { perror(\"accept\"); exit(-1); } // 输出客户端信息 char clientIP[16]; inet_ntop(AF_INET, \u0026clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(\"client Ip is %s, client port is %d\\n\", clientIP, clientPort); // 5 通信 // 获取客户端数据 char recvBuf[1024] = {0}; while (1) { ret = read(cfd, recvBuf, sizeof(recvBuf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"receive client data : %s\\n\", recvBuf); } else if (ret == 0) { printf(\"client closed...\\n\"); break; } // 给客户端发送数据 char sendBuf[] = \"hello I am server\"; ret = write(cfd, sendBuf, sizeof(sendBuf) - 1); if (ret == -1) { perror(\"write\"); exit(-1); } } // 6 关闭连接 close(cfd); close(lfd); return 0; } 客户端 #include \u003carpa/inet.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e int main() { // 1 创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { perror(\"socket\"); exit(-1); } // 2 连接服务器 struct sockaddr_in serverAddr; serverAddr.sin_family = PF_INET; inet_pton(AF_INET, \"172.25.93.158\", \u0026serverAddr.sin_addr.s_addr); serverAddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr *)\u0026serverAddr, sizeof(serverAddr)); if (ret == -1) { perror(\"connect\"); exit(-1); } // 3 通信 char recvBuf[1024] = {0}; while (1) { char sendBuf[] = \"hello I am client\"; ret = write(fd, sendBuf, sizeof(sendBuf) - 1); if (ret == -1) { perror(\"write\"); exit(-1); } sleep(1); ret = read(fd, recvBuf, sizeof(recvBuf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"receive server data : %s\\n\", recvBuf); } else if (ret == 0) { printf(\"server closed...\\n\"); break; } } // 4 关闭连接 close(fd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:5:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"TCP通信流程 ","date":"2021-04-17","objectID":"/unix_socket/:6:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"服务器端 （被动接受连接的角色） 创建一个用于监听的套接字 （监听：监听有客户端的连接；套接字：这个套接字其实就是一个文件描述符 ） 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）客户端连接服务器的时候使用的就是这个IP和端口 设置监听，监听的fd开始工作 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd） 通信 接收数据、发送数据 通信结束，断开 ","date":"2021-04-17","objectID":"/unix_socket/:6:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"客户端 创建一个用于通信的套接字（fd） 连接服务器，需要指定连接的服务器的 IP 和 端口 连接成功了，客户端可以直接和服务器通信 接收数据 发送数据 通信结束，断开 ","date":"2021-04-17","objectID":"/unix_socket/:6:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"多进程TCP通信 服务端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e #include \u003csignal.h\u003e#include \u003cwait.h\u003e#include \u003cerrno.h\u003e void recyleChild(int arg) { // SIGCHILD信号处理函数 // 用于回收资源 while (1) { int ret = waitpid(-1, NULL, WNOHANG); if (ret == -1) { // 所有子进程都被回收 break; } else if (ret == 0) { // 还有子进程 break; } else if (ret \u003e 0) { printf(\"子进程 %d 被回收了\\n\", ret); } } return; } int main() { // 注册信号，当子进程退出时，回收资源 struct sigaction act; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; act.sa_handler = recyleChild; sigaction(SIGCHLD, \u0026act, NULL); // 1 创建监听socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 为监听socket绑定端口 bind struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr.s_addr); int ret = bind(lfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 开始监听 listen ret = listen(lfd, 128); if (ret == -1) { perror(\"listen\"); exit(-1); } // 4 循环等待接受请求 accept while (1) { struct sockaddr_in client_add r; socklen_t client_socket_len = sizeof(client_addr); // 这里的第三个参数要传长度的指针 int cfd = accept(lfd, (struct sockaddr *)\u0026client_addr, \u0026client_socket_len); if (cfd == -1) { // 这里为了避免因为accept被回收资源函数中断而退出程序 if(errno == EINTR) { continue; } perror(\"accept\"); exit(-1); } printf(\"client connected, clientSockedFd: %d\\n\", cfd); // 5 创建新进程 pid_t pid = fork(); if (pid == 0) { // 6 新进程与客户socket通信 char buf[1024] = {0}; while (1) { // 循环从客户端读取 ret = read(cfd, buf, sizeof(buf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"server read data: %s \\n\", buf); } else if (ret == 0) { // 读完了 printf(\"client closed...\\n\"); break; } // 向客户端写入 ret = write(cfd, buf, sizeof(buf)); if (ret == -1) { perror(\"write\"); exit(-1); } } close(cfd); exit(0); // 子进程退出 } } // 7 回收子进程资源 // 8 关闭连接 close(lfd); return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e int main() { // 1 创建socket int cfd = socket(PF_INET, SOCK_STREAM, 0); if (cfd == -1) { perror(\"socket\"); exit(-1); } // 2 建立连接 connect struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr.s_addr); // 注意要类型转换 int ret = connect(cfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); if (ret == -1) { perror(\"connect\"); exit(-1); } // 3 通信 char buf[1024] = {0}; while (1) { scanf(\"%s\", buf); write(cfd, buf, sizeof(buf)); int len = read(cfd, buf, sizeof(buf)); if (len == -1) { perror(\"read\"); exit(-1); } else if (len \u003e 0) { if (strcmp(buf, \"quit\") == 0) { printf(\"client quit... \\n\"); break; } else { printf(\"receive server data: %s\\n\", buf); } } else if (len == 0){ // 读取完了服务器断开连接 printf(\"server closed\"); break; } } // 4 关闭连接 close(cfd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:6:3","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"多线程TCP通信 服务端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003cunistd.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e struct sockInfo { // 线程号 pthread_t tid; // 通信的文件描述符 int fd; struct sockaddr_in addr; }; struct sockInfo sockinfos[128]; void* work(void * arg) { // 6 在新线程中通信 struct sockInfo* pinfo = (struct sockInfo*) arg; int cfd = pinfo-\u003efd; // 打印客户端的IP和端口 char clientIp[16]; inet_ntop(AF_INET, \u0026pinfo-\u003eaddr.sin_addr.s_addr, clientIp, sizeof(clientIp)); unsigned short clientPort = ntohs(pinfo-\u003eaddr.sin_port); printf(\"client ip is : %s, port is : %d\\n\", clientIp, clientPort); char buf[1024]; while (1) { // 循环从客户端读取 int len = read(cfd, buf, sizeof(buf)); if (len == -1) { perror(\"read\"); exit(-1); } else if (len \u003e 0) { // 接收到了数据 printf(\"server reveiced data: %s\\n\", buf); } else if (len == 0) { // 读完了，关闭连接 printf(\"client closed\\n\"); break; } // 往客户端写数据 write(pinfo-\u003efd, buf, sizeof(buf)); } close(pinfo-\u003efd); return NULL; } int main() { // 1 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 为socket绑定IP端口 bind struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr.s_addr); int ret = bind(lfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 开启监听 listen ret = listen(lfd, 128); if (ret == -1) { perror(\"listen\"); exit(-1); } // 初始化线程池 int max = sizeof(sockinfos) / sizeof(sockinfos[0]); for (int i = 0; i \u003c max; ++i) { bzero(\u0026sockinfos[i], sizeof(sockinfos[i])); sockinfos[i].fd = -1; sockinfos[i].tid = -1; } while (1) { // 4 循环监听 接受连接 accept struct sockaddr_in client_addr; int len = sizeof(client_addr); int cfd = accept(lfd, (struct sockaddr*)\u0026client_addr, \u0026len); if (cfd == -1) { perror(\"accept\"); exit(-1); } // 5 开启新线程 // 寻找可用线程 struct sockInfo *pinfo; for (int i = 0; i \u003c max; ++i) { if (sockinfos[i].fd == -1) { pinfo = \u0026sockinfos[i]; break; } else { // 线程池满 if (i == max - 1) { sleep(1); --i; } } } // 记录客户端文件描述符 pinfo-\u003efd = cfd; // 记录客户端地址信息 memcpy(\u0026pinfo-\u003eaddr, \u0026client_addr, sizeof(client_addr)); // 创建线程 pthread_create(\u0026pinfo-\u003etid, NULL, work, pinfo); // 分离线程 pthread_detach(pinfo-\u003etid); } // 7 关闭 close(lfd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:6:4","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"UDP通信流程 #include \u003csys/types.h\u003e#include \u003csys/socket.h\u003essize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); - 参数： - sockfd : 通信的fd - buf : 要发送的数据 - len : 发送数据的长度 - flags : 0 - dest_addr : 通信的另外一端的地址信息 - addrlen : 地址的内存大小 ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); - 参数： - sockfd : 通信的fd - buf : 接收数据的数组 - len : 数组的大小 - flags : 0 - src_addr : 用来保存另外一端的地址信息，不需要可以指定为NULL - addrlen : 地址的内存大 ","date":"2021-04-17","objectID":"/unix_socket/:7:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"服务端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003carpa/inet.h\u003e int main() { // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\"socket\"); exit(-1); } struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; // 2.绑定 int ret = bind(fd, (struct sockaddr *)\u0026addr, sizeof(addr)); if(ret == -1) { perror(\"bind\"); exit(-1); } // 3.通信 while(1) { char recvbuf[128]; char ipbuf[16]; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接收数据 int num = recvfrom(fd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr *)\u0026cliaddr, \u0026len); printf(\"client IP : %s, Port : %d\\n\", inet_ntop(AF_INET, \u0026cliaddr.sin_addr.s_addr, ipbuf, sizeof(ipbuf)), ntohs(cliaddr.sin_port)); printf(\"client say : %s\\n\", recvbuf); // 发送数据 sendto(fd, recvbuf, strlen(recvbuf) + 1, 0, (struct sockaddr *)\u0026cliaddr, sizeof(cliaddr)); } close(fd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:7:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"客户端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003carpa/inet.h\u003e int main() { // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\"socket\"); exit(-1); } // 服务器的地址信息 struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026saddr.sin_addr.s_addr); int num = 0; // 3.通信 while(1) { // 发送数据 char sendBuf[128]; sprintf(sendBuf, \"hello , i am client %d \\n\", num++); sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr *)\u0026saddr, sizeof(saddr)); // 接收数据 int num = recvfrom(fd, sendBuf, sizeof(sendBuf), 0, NULL, NULL); printf(\"server say : %s\\n\", sendBuf); sleep(1); } close(fd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:7:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"参考 Socket原理详解 - 编程宝库 (codebaoku.com) ","date":"2021-04-17","objectID":"/unix_socket/:8:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Tools"],"content":"CMake 介绍 参考：【使用CMake组织C++工程】2：CMake 常用命令和变量 (elloop.github.io) cmake的定义是什么 ？—–高级编译配置工具 当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！ 所有操作都是通过编译CMakeLists.txt来完成的—简单 官 方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息 学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备 ","date":"2021-04-17","objectID":"/cmake_tutorial/:1:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMake安装 1、绝大多数的linux系统已经安装了CMake 2、Windows或某些没有安装过的linux系统，去http://www.cmake.org/HTML/Download.html 可以下载安装 ","date":"2021-04-17","objectID":"/cmake_tutorial/:2:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMake一个HelloWord 1、步骤一，写一个HelloWord #main.cpp #include \u003ciostream\u003e int main(){ std::cout \u003c\u003c \"hello word\" \u003c\u003c std::endl; } 2、步骤二，写CMakeLists.txt #CMakeLists.txt PROJECT (HELLO) SET(SRC_LIST main.cpp) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \"${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) 3、步骤三、使用cmake，生成makefile文件 cmake . 输出： [root@localhost cmake]# cmake . CMake Warning (dev) in CMakeLists.txt: Syntax Warning in cmake code at /root/cmake/CMakeLists.txt:7:37 Argument not separated from preceding token by whitespace. This warning is for project developers. Use -Wno-dev to suppress it. -- The C compiler identification is GNU 10.2.1 -- The CXX compiler identification is GNU 10.2.1 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- This is BINARY dir /root/cmake -- This is SOURCE dir /root/cmake -- Configuring done -- Generating done -- Build files have been written to: /root/cmake 目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile. 4、使用make命令编译 root@localhost cmake]# make Scanning dependencies of target hello [100%] Building CXX object CMakeFiles/hello.dir/main.cpp.o Linking CXX executable hello [100%] Built target hello 5、最终生成了Hello的可执行程序 ","date":"2021-04-17","objectID":"/cmake_tutorial/:3:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMakeLists基础指令 ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"PROJECT关键字 可以用来指定工程的名字和支持的语言，默认支持所有语言 PROJECT (HELLO) 指定了工程的名字，并且支持所有语言—建议 PROJECT (HELLO CXX) 指定了工程的名字，并且支持语言是C++ PROJECT (HELLO C CXX) 指定了工程的名字，并且支持语言是C和C++ 该指定隐式定义了两个CMAKE的变量 \u003cprojectname\u003e_BINARY_DIR，本例中是 HELLO_BINARY_DIR \u003cprojectname\u003e_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译 问题：如果改了工程名，这两个变量名也会改变 解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系 ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"SET关键字 用来显示的指定变量的 SET(SRC_LIST main.cpp) SRC_LIST变量就包含了main.cpp 也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp) ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"MESSAGE关键字 向终端输出用户自定义的信息 主要包含三种信息： SEND_ERROR，产生错误，生成过程被跳过。 SATUS，输出前缀为—的信息。 FATAL_ERROR，立即终止所有 cmake 过程. ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"ADD_EXECUTABLE关键字 生成可执行文件 ADD_EXECUTABLE(hello ${SRC_LIST}) 生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容 也可以直接写 ADD_EXECUTABLE(hello main.cpp) 上述例子可以简化的写成 PROJECT(HELLO)ADD_EXECUTABLE(hello main.cpp) 注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的 ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:4","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMakeLists语法的基本原则 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件 就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp) 指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令 ","date":"2021-04-17","objectID":"/cmake_tutorial/:5:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"语法注意事项 SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号 ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main ","date":"2021-04-17","objectID":"/cmake_tutorial/:5:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"内部构建和外部构建 上述例子就是内部构建，他生产的临时文件特别多，不方便清理 外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式 ","date":"2021-04-17","objectID":"/cmake_tutorial/:6:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"外部构建方式举例 //例子目录，CMakeLists.txt和上面例子一致 [root@localhost cmake]# pwd /root/cmake [root@localhost cmake]# ll total 8 -rw-r--r--. 1 root root 198 Dec 28 20:59 CMakeLists.txt -rw-r--r--. 1 root root 76 Dec 28 00:18 main.cpp 1、建立一个build目录，可以在任何地方，建议在当前目录下 2、进入build，运行cmake .. 当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了 3、在build目录下，运行make来构建工程 注意外部构建的两个变量 1、HELLO_SOURCE_DIR 还是工程路径 2、HELLO_BINARY_DIR 编译路径 也就是 /root/cmake/bulid ","date":"2021-04-17","objectID":"/cmake_tutorial/:6:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"一般Cmake工程结构 为工程添加一个子目录 src，用来放置工程源代码 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 在工程目录添加文本文件 COPYRIGHT, README 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 将构建后的目标文件放入构建目录的 bin 子目录 将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/ ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"将目标文件放入构建目录的 bin 子目录 每个目录下都要有一个CMakeLists.txt说明 [root@localhost cmake]# tree . ├── build ├── CMakeLists.txt └── src ├── CMakeLists.txt └── main.cpp 外层CMakeLists.txt PROJECT(HELLO)ADD_SUBDIRECTORY(src bin) src下的CMakeLists.txt ADD_EXECUTABLE(hello main.cpp) ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"ADD_SUBDIRECTORY 指令 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置 EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example ADD_SUBDIRECTORY(src bin) 将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录 如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录 ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"更改二进制的保存路径 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 思考：加载哪个CMakeLists.txt当中 哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写 ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"源码编译安装 一种是从代码编译后直接 make install 安装 一种是打包时的指定 目录安装。 简单的可以这样指定目录：make install DESTDIR=/tmp/test 稍微复杂一点可以这样指定目录：./configure –prefix=/usr ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"如何安装HelloWord 使用CMAKE一个新的指令：INSTALL INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等 使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX // 目录树结构 [root@localhost cmake]# tree . ├── build ├── CMakeLists.txt ├── COPYRIGHT ├── doc │ └── hello.txt ├── README ├── runhello.sh └── src ├── CMakeLists.txt └── main.cpp 3 directories, 7 files ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装文件COPYRIGHT和README INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/) FILES：文件 DESTINATION： 1、写绝对路径 2、可以写相对路径，相对路径实际路径是： ${CMAKE_INSTALL_PREFIX}/\u003cDESTINATION 定义的路径\u003e CMAKE_INSTALL_PREFIX 默认是在 /usr/local/ cmake -DCMAKE_INSTALL_PREFIX=/usr 在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径 ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装脚本runhello.sh PROGRAMS：非目标文件的可执行程序安装(比如脚本之类) INSTALL(PROGRAMS runhello.sh DESTINATION bin) 说明：实际安装到的是 /usr/bin ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装 doc 中的 hello.txt 一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file 二、是直接在工程目录通过 INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake) DIRECTORY 后面连接的是所在 Source 目录的相对路径 注意：abc 和 abc/有很大的区别 目录名不以/结尾：这个目录将被安装为目标路径下的 目录名以/结尾：将这个目录中的内容安装到目标路径 ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:4","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装过程 cmake .. make make install ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:5","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"静态库和动态库的构建 任务： １，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 ２，安装头文件与共享库。 静态库和动态库的区别 静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。 静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行 动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。 ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"构建实例 [root@localhost cmake2]# tree . ├── build ├── CMakeLists.txt └── lib ├── CMakeLists.txt ├── hello.cpp └── hello.h hello.h中的内容 #ifndef HELLO_H #define Hello_H void HelloFunc(); #endif hello.cpp中的内容 #include \"hello.h\"#include \u003ciostream\u003evoid HelloFunc(){ std::cout \u003c\u003c \"Hello World\" \u003c\u003c std::endl; } 项目中的cmake内容 PROJECT(HELLO)ADD_SUBDIRECTORY(lib bin) lib中CMakeLists.txt中的内容 SET(LIBHELLO_SRC hello.cpp)ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"ADD_LIBRARY ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so SHARED，动态库 STATIC，静态库 ${LIBHELLO_SRC} ：源文件 ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"同时构建静态和动态库 // 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已 ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"SET_TARGET_PROPERTIES 这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本 同时构建静态和动态库 SET(LIBHELLO_SRC hello.cpp)ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})//对hello_static的重名为hello SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\")//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库， // 因为，在构建 libhello.so 时， 就会清理掉 libhello.a SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})SET_TARGET_PROPERTIES(hello PROPERTIES OUTPUT_NAME \"hello\")SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:4","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"动态库的版本号 一般动态库都有一个版本号的关联 libhello.so.1.2 libhello.so -\u003elibhello.so.1 libhello.so.1-\u003elibhello.so.1.2 CMakeLists.txt 插入如下 SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION 指代动态库版本，SOVERSION 指代 API 版本。 ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:5","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装共享库和头文件 本例中我们将 hello 的共享库安装到\u003cprefix\u003e/lib目录， 将 hello.h 安装到\u003cprefix\u003e/include/hello 目录 //文件放到该目录下 INSTALL(FILES hello.h DESTINATION include/hello)//二进制，静态库，动态库安装都用TARGETS //ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。 INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 注意： 安装的时候，指定一下路径，放到系统下 cmake -DCMAKE_INSTALL_PREFIX=/usr .. ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:6","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"使用外部共享库和头文件 准备工作，新建一个目录来使用外部共享库和头文件 [root@MiWiFi-R4CM-srv cmake3]# tree . ├── build ├── CMakeLists.txt └── src ├── CMakeLists.txt └── main.cpp main.cpp #include \u003chello.h\u003e int main(){ HelloFunc(); } ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:7","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"若干问题 ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"解决：make后头文件找不到的问题 PS：include \u003chello/hello.h\u003e 这样include是可以，这么做的话，就没啥好讲的了 关键字：INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割 在CMakeLists.txt中加入头文件搜索路径 INCLUDE_DIRECTORIES(/usr/include/hello) ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"解决：找不到引用的函数问题 报错信息：undefined reference to HelloFunc()'` 关键字：LINK_DIRECTORIES 添加非标准的共享库搜索路径 指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs) 关键字：TARGET_LINK_LIBRARIES 添加需要链接的共享库 TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。 在CMakeLists.txt中插入链接共享库，主要要插在executable的后面 查看main的链接情况 [root@MiWiFi-R4CM-srv bin]# ldd main linux-vdso.so.1 =\u003e (0x00007ffedfda4000) libhello.so =\u003e /lib64/libhello.so (0x00007f41c0d8f000) libstdc++.so.6 =\u003e /lib64/libstdc++.so.6 (0x00007f41c0874000) libm.so.6 =\u003e /lib64/libm.so.6 (0x00007f41c0572000) libgcc_s.so.1 =\u003e /lib64/libgcc_s.so.1 (0x00007f41c035c000) libc.so.6 =\u003e /lib64/libc.so.6 (0x00007f41bff8e000) /lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000) 链接静态库 TARGET_LINK_LIBRARIES(main libhello.a) ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置 我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置 我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello 补充：生产debug版本的方法： cmake .. -DCMAKE_BUILD_TYPE=debug ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Operating System"],"content":"线程概述 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP 号：ps –Lf pi ◼ 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的 一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 ◼ 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始 来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 ◼ NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。 ◼ 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION ","date":"2021-04-12","objectID":"/linux_multi_threads/:1:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"进程与线程之间的区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用 一些进程间通信方式，在进程间进行信息交换。 调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表 ","date":"2021-04-12","objectID":"/linux_multi_threads/:1:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程基本操作 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_t pthread_self(void); int pthread_equal(pthread_t t1, pthread_t t2); void pthread_exit(void *retval); int pthread_join(pthread_t thread, void **retval); int pthread_detach(pthread_t thread); int pthread_cancel(pthread_t thread); ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程创建（create） /* 一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程 称之为子线程。 程序中默认只有一个进程，fork()函数调用，2进行 程序中默认只有一个线程，pthread_create()函数调用，2个线程。 #include \u003cpthread.h\u003e int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); - 功能：创建一个子线程 - 参数： - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。 - attr : 设置线程的属性，一般使用默认值，NULL - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码 - arg : 给第三个参数使用，传参 - 返回值： 成功：0 失败：返回错误号。这个错误号和之前errno不太一样。 获取错误号的信息： char * strerror(int errnum); */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"child thread...\\n\"); printf(\"arg value: %d\\n\", *(int *)arg); return NULL; } int main() { pthread_t tid; int num = 10; // 创建一个子线程 int ret = pthread_create(\u0026tid, NULL, callback, (void *)\u0026num); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } sleep(1); return 0; // exit(0); } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程终止（exit） /* #include \u003cpthread.h\u003e void pthread_exit(void *retval); 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程 参数： retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。 pthread_t pthread_self(void); 功能：获取当前的线程的线程ID int pthread_equal(pthread_t t1, pthread_t t2); 功能：比较两个线程ID是否相等 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的 是使用结构体去实现的。 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e void * callback(void * arg) { printf(\"child thread id : %ld\\n\", pthread_self()); return NULL; // pthread_exit(NULL); } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } // 主线程 for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self()); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); printf(\"main thread exit\\n\"); return 0; // exit(0); } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:2","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程汇合（join） /* #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **retval); - 功能：和一个已经终止的线程进行连接 回收子线程的资源 这个函数是阻塞函数，调用一次只能回收一个子线程 一般在主线程中使用 - 参数： - thread：需要回收的子线程的ID - retval: 接收子线程退出时的返回值 - 返回值： 0 : 成功 非0 : 失败，返回的错误号 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e int value = 10; void * callback(void * arg) { printf(\"child thread id : %ld\\n\", pthread_self()); // sleep(3); // return NULL; // int value = 10; // 局部变量 pthread_exit((void *)\u0026value); // return (void *)\u0026value; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } // 主线程 for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self()); // 主线程调用pthread_join()回收子线程的资源 int * thread_retval; ret = pthread_join(tid, (void **)\u0026thread_retval); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } printf(\"exit data : %d\\n\", *thread_retval); printf(\"回收子线程资源成功！\\n\"); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:3","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程分离（detach） /* #include \u003cpthread.h\u003e int pthread_detach(pthread_t thread); - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 1.不能多次分离，会产生不可预料的行为。 2.不能去连接一个已经分离的线程，会报错。 - 参数：需要分离的线程的ID - 返回值： 成功：0 失败：返回错误号 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); return NULL; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); // 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if(ret != 0) { char * errstr = strerror(ret); printf(\"error2 : %s\\n\", errstr); } // 设置分离后，对分离的子线程进行连接 pthread_join() // ret = pthread_join(tid, NULL); // if(ret != 0) { // char * errstr = strerror(ret); // printf(\"error3 : %s\\n\", errstr); // } pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:4","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程取消（cancel） /* #include \u003cpthread.h\u003e int pthread_cancel(pthread_t thread); - 功能：取消线程（让线程终止） 取消某个线程，可以终止某个线程的运行， 但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); for(int i = 0; i \u003c 5; i++) { printf(\"child : %d\\n\", i); } return NULL; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 取消线程 pthread_cancel(tid); for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:5","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程属性（attr） /* int pthread_attr_init(pthread_attr_t *attr); - 初始化线程属性变量 int pthread_attr_destroy(pthread_attr_t *attr); - 释放线程属性的资源 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); - 获取线程分离的状态属性 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); - 设置线程分离的状态属性 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); return NULL; } int main() { // 创建一个线程属性变量 pthread_attr_t attr; // 初始化属性变量 pthread_attr_init(\u0026attr); // 设置属性 pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, \u0026attr, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 获取线程的栈的大小 size_t size; pthread_attr_getstacksize(\u0026attr, \u0026size); printf(\"thread stack size : %ld\\n\", size); // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); // 释放线程属性资源 pthread_attr_destroy(\u0026attr); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:6","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程同步（synchronization） ◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 ◼ 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。 ◼ 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"互斥量（锁） 互斥量基本原理 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 ◼ 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 ◼ 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 ◼ 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示： 互斥量示例 /* 互斥量的类型 pthread_mutex_t int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); - 初始化互斥量 - 参数 ： - mutex ： 需要初始化的互斥量变量 - attr ： 互斥量相关的属性，NULL - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。 pthread_mutex_t *restrict mutex = xxx; pthread_mutex_t * mutex1 = mutex; int pthread_mutex_destroy(pthread_mutex_t *mutex); - 释放互斥量的资源 int pthread_mutex_lock(pthread_mutex_t *mutex); - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待 int pthread_mutex_trylock(pthread_mutex_t *mutex); - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。 int pthread_mutex_unlock(pthread_mutex_t *mutex); - 解锁 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 全局变量，所有的线程都共享这一份资源。 int tickets = 1000; // 创建一个互斥量 pthread_mutex_t mutex; void * sellticket(void * arg) { // 卖票 while(1) { // 加锁 pthread_mutex_lock(\u0026mutex); if(tickets \u003e 0) { usleep(6000); printf(\"%ld 正在卖第 %d 张门票\\n\", pthread_self(), tickets); tickets--; }else { // 解锁 pthread_mutex_unlock(\u0026mutex); break; } // 解锁 pthread_mutex_unlock(\u0026mutex); } return NULL; } int main() { // 初始化互斥量 pthread_mutex_init(\u0026mutex, NULL); // 创建3个子线程 pthread_t tid1, tid2, tid3; pthread_create(\u0026tid1, NULL, sellticket, NULL); pthread_create(\u0026tid2, NULL, sellticket, NULL); pthread_create(\u0026tid3, NULL, sellticket, NULL); // 回收子线程的资源,阻塞 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); pthread_exit(NULL); // 退出主线程 // 释放互斥量资源 pthread_mutex_destroy(\u0026mutex); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"死锁 ◼ 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 ◼ 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁 死锁的几种场景 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 更多关于死锁的内容将在操作系统的相关理论文章中介绍，本文不再继续讨论。 死锁产生的四个必要条件 虽然进程在运行过程中，可能发生死锁，但死锁的发生必须具备一定的条件，死锁的发生必须具有以下四个必要条件。 （1）互斥条件：指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。 （2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 （3）不剥夺条件：指进程已获得的资源，在未使用之前，不能被剥夺，只能在使用完时由自己释放。 （4）循环等待条件：指在发生死锁时，必然在一个进程 – 资源的环形链，即进程集合{P0， P1， P2 …， Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，….，Pn正在等待已被 P0 占用的资源。 死锁处理方法 在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁 （1）预防死锁 ：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 （2）避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。 （3）检测和解除死锁：先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。 这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。 死锁示例 #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 创建2个互斥量 pthread_mutex_t mutex1, mutex2; void * workA(void * arg) { pthread_mutex_lock(\u0026mutex1); sleep(1); pthread_mutex_lock(\u0026mutex2); printf(\"workA....\\n\"); pthread_mutex_unlock(\u0026mutex2); pthread_mutex_unlock(\u0026mutex1); return NULL; } void * workB(void * arg) { pthread_mutex_lock(\u0026mutex2); sleep(1); pthread_mutex_lock(\u0026mutex1); printf(\"workB....\\n\"); pthread_mutex_unlock(\u0026mutex1); pthread_mutex_unlock(\u0026mutex2); return NULL; } int main() { // 初始化互斥量 pthread_mutex_init(\u0026mutex1, NULL); pthread_mutex_init(\u0026mutex2, NULL); // 创建2个子线程 pthread_t tid1, tid2; pthread_create(\u0026tid1, NULL, workA, NULL); pthread_create(\u0026tid2, NULL, workB, NULL); // 回收子线程资源 pthread_join(tid1, NULL); pthread_join(tid2, NULL); // 释放互斥量资源 pthread_mutex_destroy(\u0026mutex1); pthread_mutex_destroy(\u0026mutex2); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:2","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 ◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 ◼ 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高。 示例 /* 读写锁的类型 pthread_rwlock_t int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 案例：8个线程操作同一个全局变量。 3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 创建一个共享数据 int num = 1; // pthread_mutex_t mutex; pthread_rwlock_t rwlock; void * writeNum(void * arg) { while(1) { pthread_rwlock_wrlock(\u0026rwlock); num++; printf(\"++write, tid : %ld, num : %d\\n\", pthread_self(), num); pthread_rwlock_unlock(\u0026rwlock); usleep(100); } return NULL; } void * readNum(void * arg) { while(1) { pthread_rwlock_rdlock(\u0026rwlock); printf(\"===read, tid : %ld, num : %d\\n\", pthread_self(), num); pthread_rwlock_unlock(\u0026rwlock); usleep(100); } return NULL; } int main() { pthread_rwlock_init(\u0026rwlock, NULL); // 创建3个写线程，5个读线程 pthread_t wtids[3], rtids[5]; for(int i = 0; i \u003c 3; i++) { pthread_create(\u0026wtids[i], NULL, writeNum, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026rtids[i], NULL, readNum, NULL); } // 设置线程分离 for(int i = 0; i \u003c 3; i++) { pthread_detach(wtids[i]); } for(int i = 0; i \u003c 5; i++) { pthread_detach(rtids[i]); } pthread_exit(NULL); pthread_rwlock_destroy(\u0026rwlock); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:3","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"条件变量 互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。 条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。 两个线程操作同一临界区时，通过互斥锁保护，若A线程已经加锁，B线程再加锁时候会被阻塞，直到A释放锁，B再获得锁运行，进程B必须不停的主动获得锁、检查条件、释放锁、再获得锁、再检查、再释放，一直到满足运行的条件的时候才可以（而此过程中其他线程一直在等待该线程的结束），这种方式是比较消耗系统的资源的。而条件变量同样是阻塞，还需要通知才能唤醒，线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，该线程就休眠了，应该仍阻塞在这里，等待条件满足后被唤醒，节省了线程不断运行浪费的资源。这个过程一般用while语句实现。当线程B发现被锁定的变量不满足条件时会自动的释放锁并把自身置于等待状态，让出CPU的控制权给其它线程。其它线程 此时就有机会去进行操作，当修改完成后再通知那些由于条件不满足而陷入等待状态的线程。这是一种通知模型的同步方式，大大的节省了CPU的计算资源，减少了线程之间的竞争，而且提高了线程之间的系统工作的效率。这种同步方式就是条件变量。 示例（生产者-消费者模型） /* 条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); - 等待，调用了该函数，线程会阻塞。 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。 int pthread_cond_signal(pthread_cond_t *cond); - 唤醒一个或者多个等待的线程 int pthread_cond_broadcast(pthread_cond_t *cond); - 唤醒所有的等待的线程 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建条件变量 pthread_cond_t cond; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); // 只要生产了一个，就通知消费者消费 pthread_cond_signal(\u0026cond); pthread_mutex_unlock(\u0026mutex); usleep(100); } return NULL; } void * customer(void * arg) { while(1) { pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; // 判断是否有数据 if(head != NULL) { // 有数据 head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); usleep(100); } else { // 没有数据，需要等待 // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。 pthread_cond_wait(\u0026cond, \u0026mutex); pthread_mutex_unlock(\u0026mutex); } } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); pthread_cond_init(\u0026cond, NULL); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_cond_destroy(\u0026cond); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:4","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"信号量 信号量又称为信号灯（semaphore），其与自旋锁不同的地方是它可以引起调用者休眠，也就是信号量本质上是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放后），处于等待队列中的那个任务将被唤醒，并将获得该信号量。 信号量一个有用的特性是它可以同时允许任意数量的锁持有者，而自旋锁和互斥锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为使用者数量（usage count）或简单的叫做数量（count）。通常情况下，信号量和自旋锁一样，在一个时刻仅允许有一个锁持有者。这时计数等于1，这样的信号量被称为二值信号量或者称为互斥信号量。另一方面，初始化时也可以把数量设置为大于1的非0值。这种情况，信号量被称为计数信号量（counting semaphore），它允许在同一时刻至多有count个锁持有者。 示例（生产者-消费者模型） /* 信号量的类型 sem_t int sem_init(sem_t *sem, int pshared, unsigned int value); - 初始化信号量 - 参数： - sem : 信号量变量的地址 - pshared : 0 用在线程间 ，非0 用在进程间 - value : 信号量中的值 int sem_destroy(sem_t *sem); - 释放资源 int sem_wait(sem_t *sem); - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞 int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); - 对信号量解锁，调用一次对信号量的值+1 int sem_getvalue(sem_t *sem, int *sval); sem_t psem; sem_t csem; init(psem, 0, 8); init(csem, 0, 0); producer() { sem_wait(\u0026psem); sem_post(\u0026csem) } customer() { sem_wait(\u0026csem); sem_post(\u0026psem) } */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003csemaphore.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建两个信号量 sem_t psem; sem_t csem; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { sem_wait(\u0026psem); pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026csem); } return NULL; } void * customer(void * arg) { while(1) { sem_wait(\u0026csem); pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026psem); } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); sem_init(\u0026psem, 0, 8); sem_init(\u0026csem, 0, 0); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:5","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"多进程通信（IPC） 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变 ","date":"2021-04-10","objectID":"/ipc/:1:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"管道（PIPE） 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式， 所有的 UNIX 系统都支持这种通信机制。 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行ls和 wc。 ","date":"2021-04-10","objectID":"/ipc/:2:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用 ","date":"2021-04-10","objectID":"/ipc/:2:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"管道的读写特点 使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作） 所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。 ","date":"2021-04-10","objectID":"/ipc/:2:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* #include \u003cunistd.h\u003e int pipe(int pipefd[2]); 功能：创建一个匿名管道，用来进程间通信。 参数：int pipefd[2] 这个数组是一个传出参数。 pipefd[0] 对应的是管道的读端 pipefd[1] 对应的是管道的写端 返回值： 成功 0 失败 -1 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞 注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程） */ // 子进程发送数据给父进程，父进程读取到数据输出 #include \u003cunistd.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e int main() { // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) { perror(\"pipe\"); exit(0); } // 创建子进程 pid_t pid = fork(); if(pid \u003e 0) { // 父进程 printf(\"i am parent process, pid : %d\\n\", getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = {0}; while(1) { int len = read(pipefd[0], buf, sizeof(buf)); printf(\"parent recv : %s, pid : %d\\n\", buf, getpid()); // 向管道中写入数据 //char * str = \"hello,i am parent\"; //write(pipefd[1], str, strlen(str)); //sleep(1); } } else if(pid == 0){ // 子进程 printf(\"i am child process, pid : %d\\n\", getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = {0}; while(1) { // 向管道中写入数据 char * str = \"hello,i am child\"; write(pipefd[1], str, strlen(str)); //sleep(1); // int len = read(pipefd[0], buf, sizeof(buf)); // printf(\"child recv : %s, pid : %d\\n\", buf, getpid()); // bzero(buf, 1024); } } return 0; } ","date":"2021-04-10","objectID":"/ipc/:2:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"命名管道（Named Pipe） 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件 ","date":"2021-04-10","objectID":"/ipc/:3:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 文件定位操作。 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 ","date":"2021-04-10","objectID":"/ipc/:3:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* 创建fifo文件 1.通过命令： mkfifo 名字 2.通过函数：int mkfifo(const char *pathname, mode_t mode); #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e int mkfifo(const char *pathname, mode_t mode); 参数： - pathname: 管道名称的路径 - mode: 文件的权限 和 open 的 mode 是一样的 是一个八进制的数 返回值：成功返回0，失败返回-1，并设置错误号 */ #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e int main() { // 判断文件是否存在 int ret = access(\"fifo1\", F_OK); if(ret == -1) { printf(\"管道不存在，创建管道\\n\"); ret = mkfifo(\"fifo1\", 0664); if(ret == -1) { perror(\"mkfifo\"); exit(0); } } return 0; } ","date":"2021-04-10","objectID":"/ipc/:3:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"内存映射（Memory Map） ","date":"2021-04-10","objectID":"/ipc/:4:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功? void * ptr = mmap(...); ptr++; 可以对其进行++操作 munmap(ptr, len); // 错误,要保存地址 如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? 错误，返回MAP_FAILED open()函数中的权限建议和prot参数的权限保持一致。 如果文件偏移量为1000会怎样? 偏移量必须是4K的整数倍，返回MAP_FAILED mmap什么情况下会调用失败? 第2个参数：length = 0 第3个参数：prot 只指定了写权限 prot PROT_READ | PROT_WRITE 第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗? 可以的，但是创建的文件的大小如果为0的话，肯定不行 可以对新的文件进行扩展（lseek()，truncate()） mmap后关闭文件描述符，对mmap映射有没有影响？ int fd = open(\"XXX\"); mmap(,,,,fd,0); close(fd); 映射区还存在，创建映射区的fd被关闭，没有任何影响。 对ptr越界操作会怎样？ void * ptr = mmap(NULL, 100,,,,,); 4K 越界操作操作的是非法的内存 -\u003e 段错误 ","date":"2021-04-10","objectID":"/ipc/:4:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* #include \u003csys/mman.h\u003e void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); - 功能：将一个文件或者设备的数据映射到内存中 - 参数： - void *addr: NULL, 由内核指定 - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。 获取文件的长度：stat lseek - prot : 对申请的内存映射区的操作权限 -PROT_EXEC ：可执行的权限 -PROT_READ ：读权限 -PROT_WRITE ：写权限 -PROT_NONE ：没有权限 要操作映射内存，必须要有读的权限。 PROT_READ、PROT_READ|PROT_WRITE - flags : - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项 - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write） - fd: 需要映射的那个文件的文件描述符 - 通过open得到，open的是一个磁盘文件 - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。 prot: PROT_READ open:只读/读写 prot: PROT_READ | PROT_WRITE open:读写 - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。 - 返回值：返回创建的内存的首地址 失败返回MAP_FAILED，(void *) -1 int munmap(void *addr, size_t length); - 功能：释放内存映射 - 参数： - addr : 要释放的内存的首地址 - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。 */ /* 使用内存映射实现进程间通信： 1.有关系的进程（父子进程） - 还没有子进程的时候 - 通过唯一的父进程，先创建内存映射区 - 有了内存映射区以后，创建子进程 - 父子进程共享创建的内存映射区 2.没有关系的进程间通信 - 准备一个大小不是0的磁盘文件 - 进程1 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 进程2 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 使用内存映射区通信 注意：内存映射区通信，是非阻塞。 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cwait.h\u003e // 作业:使用内存映射实现没有关系的进程间的通信。 int main() { // 1.打开一个文件 int fd = open(\"test.txt\", O_RDWR); int size = lseek(fd, 0, SEEK_END); // 获取文件的大小 // 2.创建内存映射区 void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 3.创建子进程 pid_t pid = fork(); if(pid \u003e 0) { wait(NULL); // 父进程 char buf[64]; strcpy(buf, (char *)ptr); printf(\"read data : %s\\n\", buf); }else if(pid == 0){ // 子进程 strcpy((char *)ptr, \"nihao a, son!!!\"); } // 关闭内存映射区 munmap(ptr, size); return 0; } /* 匿名映射：不需要文件实体进程一个内存映射 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/wait.h\u003e int main() { // 1.创建匿名内存映射区 int len = 4096; void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 父子进程间通信 pid_t pid = fork(); if(pid \u003e 0) { // 父进程 strcpy((char *) ptr, \"hello, world\"); wait(NULL); }else if(pid == 0) { // 子进程 sleep(1); printf(\"%s\\n\", (char *)ptr); } // 释放内存映射区 int ret = munmap(ptr, len); if(ret == -1) { perror(\"munmap\"); exit(0); } return 0; } // 使用内存映射实现文件拷贝的功能 /* 思路： 1.对原始的文件进行内存映射 2.创建一个新文件（拓展该文件） 3.把新文件的数据映射到内存中 4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中 5.释放资源 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e int main() { // 1.对原始的文件进行内存映射 int fd = open(\"english.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); exit(0); } // 获取原始文件的大小 int len = lseek(fd, 0, SEEK_END); // 2.创建一个新文件（拓展该文件） int fd1 = open(\"cpy.txt\", O_RDWR | O_CREAT, 0664); if(fd1 == -1) { perror(\"open\"); exit(0); } // 对新创建的文件进行拓展 truncate(\"cpy.txt\", len); write(fd1, \" \", 1); // 3.分别做内存映射 void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); void * ptr1 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } if(ptr1 == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 内存拷贝 memcpy(ptr1, ptr, len); // 释放资源 munmap(ptr1, len); munmap(ptr, len); close(fd1); close(fd); return 0; } ","date":"2021-04-10","objectID":"/ipc/:4:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号（Signal） 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也 称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下： 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数 ","date":"2021-04-10","objectID":"/ipc/:5:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"使用信号的目的： 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 ","date":"2021-04-10","objectID":"/ipc/:5:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号的特点 简单 不能携带大量信息 满足某个特定条件才发送 优先级比较高 查看系统定义的信号列表：kill –l ，前 31 个信号为常规信号，其余为实时信号。 查看信号的详细信息：man 7 signal 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。 ","date":"2021-04-10","objectID":"/ipc/:5:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号示例 /* #include \u003csys/types.h\u003e #include \u003csignal.h\u003e int kill(pid_t pid, int sig); - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig - 参数： - pid ： \u003e 0 : 将信号发送给指定的进程 = 0 : 将信号发送给当前的进程组 = -1 : 将信号发送给每一个有权限接收这个信号的进程 \u003c -1 : 这个pid=某个进程组的ID取反 （-12345） - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号 kill(getppid(), 9); kill(getpid(), 9); int raise(int sig); - 功能：给当前进程发送信号 - 参数： - sig : 要发送的信号 - 返回值： - 成功 0 - 失败 非0 kill(getpid(), sig); void abort(void); - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程 kill(getpid(), SIGABRT); */ #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csignal.h\u003e#include \u003cunistd.h\u003e int main() { pid_t pid = fork(); if(pid == 0) { // 子进程 int i = 0; for(i = 0; i \u003c 5; i++) { printf(\"child process\\n\"); sleep(1); } } else if(pid \u003e 0) { // 父进程 printf(\"parent process\\n\"); sleep(2); printf(\"kill child process now\\n\"); kill(pid, SIGINT); } return 0; } /* #include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候， 函数会给当前的进程发送一个信号：SIGALARM - 参数： seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。 取消一个定时器，通过alarm(0)。 - 返回值： - 之前没有定时器，返回0 - 之前有定时器，返回之前的定时器剩余的时间 - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。 alarm(10); -\u003e 返回0 过了1秒 alarm(5); -\u003e 返回9 alarm(100) -\u003e 该函数是不阻塞的 */ #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { int seconds = alarm(5); printf(\"seconds = %d\\n\", seconds); // 0 sleep(2); seconds = alarm(2); // 不阻塞 printf(\"seconds = %d\\n\", seconds); // 3 while(1) { } return 0; } /* #include \u003csys/time.h\u003e int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时 - 参数： - which : 定时器以什么时间计时 ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用 ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF - new_value: 设置定时器的属性 struct itimerval { // 定时器的结构体 struct timeval it_interval; // 每个阶段的时间，间隔时间 struct timeval it_value; // 延迟多长时间执行定时器 }; struct timeval { // 时间的结构体 time_t tv_sec; // 秒数 suseconds_t tv_usec; // 微秒 }; 过10秒后，每个2秒定时一次 - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL - 返回值： 成功 0 失败 -1 并设置错误号 */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e // 过3秒以后，每隔2秒钟定时一次 int main() { struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026new_value, NULL); // 非阻塞的 printf(\"定时器开始了...\\n\"); if(ret == -1) { perror(\"setitimer\"); exit(0); } getchar(); return 0; } /* #include \u003csignal.h\u003e typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); - 功能：设置某个信号的捕捉行为 - 参数： - signum: 要捕捉的信号 - handler: 捕捉到信号要如何处理 - SIG_IGN ： 忽略信号 - SIG_DFL ： 使用信号默认的行为 - 回调函数 : 这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。 回调函数： - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义 - 不是程序员调用，而是当信号产生，由内核调用 - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。 - 返回值： 成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL 失败，返回SIG_ERR，设置错误号 SIGKILL SIGSTOP不能被捕捉，不能被忽略。 */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e void myalarm(int num) { printf(\"捕捉到了信号的编号是：%d\\n\", num); printf(\"xxxxxxx\\n\"); } // 过3秒以后，每隔2秒钟定时一次 int main() { // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。 signal(SIGALRM, myalarm); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026new_value, NULL); // 非阻塞的 printf(\"定时器开始了...\\n\"); if(ret == -1) { perror(\"setitimer\"); exit(0); } getchar(); return 0; } ","date":"2021-04-10","objectID":"/ipc/:5:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号集 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 ","date":"2021-04-10","objectID":"/ipc/:5:4","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号集示例 场景： 用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）\r- SIGINT信号状态被存储在第二个标志位上\r- 这个标志位的值为0， 说明信号不是未决状态\r- 这个标志位的值为1， 说明信号处于未决状态\r 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号\r- 如果想要阻塞某些信号需要用户调用系统的API\r 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 - 如果没有阻塞，这个信号就被处理\r- 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理\r /* 以下信号集相关的函数都是对自定义的信号集进行操作。 int sigemptyset(sigset_t *set); - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigfillset(sigset_t *set); - 功能：将信号集中的所有的标志位置为1 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigaddset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigdelset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置不阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigismember(const sigset_t *set, int signum); - 功能：判断某个信号是否阻塞 - 参数： - set：需要操作的信号集 - signum：需要判断的那个信号 - 返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 */ #include \u003csignal.h\u003e#include \u003cstdio.h\u003e int main() { // 创建一个信号集 sigset_t set; // 清空信号集的内容 sigemptyset(\u0026set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(\u0026set, SIGINT); if(ret == 0) { printf(\"SIGINT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGINT 阻塞\\n\"); } // 添加几个信号到信号集中 sigaddset(\u0026set, SIGINT); sigaddset(\u0026set, SIGQUIT); // 判断SIGINT是否在信号集中 ret = sigismember(\u0026set, SIGINT); if(ret == 0) { printf(\"SIGINT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGINT 阻塞\\n\"); } // 判断SIGQUIT是否在信号集中 ret = sigismember(\u0026set, SIGQUIT); if(ret == 0) { printf(\"SIGQUIT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGQUIT 阻塞\\n\"); } // 从信号集中删除一个信号 sigdelset(\u0026set, SIGQUIT); // 判断SIGQUIT是否在信号集中 ret = sigismember(\u0026set, SIGQUIT); if(ret == 0) { printf(\"SIGQUIT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGQUIT 阻塞\\n\"); } return 0; } /* int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换） - 参数： - how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， mask | set SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞 mask \u0026= ~set SIG_SETMASK:覆盖内核中原来的值 - set ：已经初始化好的用户自定义的信号集 - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL - 返回值： 成功：0 失败：-1 设置错误号：EFAULT、EINVAL int sigpending(sigset_t *set); - 功能：获取内核中的未决信号集 - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。 */ // 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕 // 设置某些信号是阻塞的，通过键盘产生这些信号 #include \u003cstdio.h\u003e#include \u003csignal.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e int main() { // 设置2、3号信号阻塞 sigset_t set; sigemptyset(\u0026set); // 将2号和3号信号添加到信号集中 sigaddset(\u0026set, SIGINT); sigaddset(\u0026set, SIGQUIT); // 修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, \u0026set, NULL); int num = 0; while(1) { num++; // 获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(\u0026pendingset); sigpending(\u0026pendingset); // 遍历前32位 for(int i = 1; i \u003c= 31; i++) { if(sigismember(\u0026pendingset, i) == 1) { printf(\"1\"); }else if(sigismember(\u0026pendingset, i) == 0) { printf(\"0\"); }else { perror(\"sigismember\"); exit(0); } } printf(\"\\n\"); sleep(1); if(num == 10) { // 解除阻塞 sigprocmask(SIG_UNBLOCK, \u0026set, NULL); } } return 0; } /* #include \u003csignal.h\u003e int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); - 功能：检查或者改变信号的处理。信号捕捉 - 参数： - signum : 需要捕捉的信号的编号或者宏值（信号的名称） - act ：捕捉到信号之后的处理动作 - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL - 返回值： 成功 0 失败 -1 struct sigaction { // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void); }; */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e void myalarm(int num) { printf(\"捕捉到了信号的编号是：%d\\n\", num); printf(\"xxxxxxx\\n\"); } // 过3秒以后，每隔2秒钟定时一次 int main() { struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; sigemptyset(\u0026act.sa_mask); // 清空临时阻塞信号集 // 注册信号捕捉 sigaction(SIGALRM, \u0026act, NULL); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_i","date":"2021-04-10","objectID":"/ipc/:5:5","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"共享内存（Shared Memory） 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 ◼ 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 ◼ 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 ◼ 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 ◼ 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步 ipcs 用法 ipcs -a // 打印当前系统中所有的进程间通信方式的信息 ipcs -m // 打印出使用共享内存进行进程间通信的信息 ipcs -q // 打印出使用消息队列进行进程间通信的信息 ipcs -s // 打印出使用信号进行进程间通信的信息 ipcrm 用法 ipcrm -M shmkey // 移除用shmkey创建的共享内存段 ipcrm -m shmid // 移除用shmid标识的共享内存段 ipcrm -Q msgkey // 移除用msqkey创建的消息队列 ipcrm -q msqid // 移除用msqid标识的消息队列 ipcrm -S semkey // 移除用semkey创建的信号 ipcrm -s semid // 移除用semid标识的信号 ","date":"2021-04-10","objectID":"/ipc/:6:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"问题 操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch，shm_nattach 记录了关联的进程个数 可不可以对共享内存进行多次删除 shmctl 可以的，因为shmctl 标记删除共享内存，不是直接删除，当和共享内存关联的进程数为0的时候，就真正被删除，当共享内存的key为0的时候，表示共享内存被标记删除了，如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 ","date":"2021-04-10","objectID":"/ipc/:6:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效率更高 共享内存方式所有的进程操作的是同一块共享内存。而内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全：当进程突然退出，共享内存还存在，而内存映射区消失；当运行进程的电脑死机，宕机了，数据存在在共享内存中，没有了，而内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期：内存映射区：进程退出，内存映射区销毁；共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机，如果一个进程退出，会自动和共享内存进行取消关联。 ","date":"2021-04-10","objectID":"/ipc/:6:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 共享内存相关的函数 #include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e int shmget(key_t key, size_t size, int shmflg); - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 新创建的内存段中的数据都会被初始化为0 - 参数： - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 一般使用16进制表示，非0值 - size: 共享内存的大小 - shmflg: 属性 - 访问权限 - 附加属性：创建/判断共享内存是不是存在 - 创建：IPC_CREAT - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值： 失败：-1 并设置错误号 成功：\u003e0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。 void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能：和当前的进程进行关联 - 参数： - shmid : 共享内存的标识（ID）,由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 - shmflg : 对共享内存的操作 - 读 ： SHM_RDONLY, 必须要有读权限 - 读写： 0 - 返回值： 成功：返回共享内存的首（起始）地址。 失败(void *) -1 int shmdt(const void *shmaddr); - 功能：解除当前进程和共享内存的关联 - 参数： shmaddr：共享内存的首地址 - 返回值：成功 0， 失败 -1 int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。 - 参数： - shmid: 共享内存的ID - cmd : 要做的操作 - IPC_STAT : 获取共享内存的当前的状态 - IPC_SET : 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf：需要设置或者获取的共享内存的属性信息 - IPC_STAT : buf存储数据 - IPC_SET : buf中需要初始化数据，设置到内核中 - IPC_RMID : 没有用，NULL key_t ftok(const char *pathname, int proj_id); - 功能：根据指定的路径名，和int值，生成一个共享内存的key - 参数： - pathname:指定一个存在的路径 /home/nowcoder/Linux/a.txt / - proj_id: int类型的值，但是这系统调区销毁 - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 #include \u003cstdio.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e#include \u003cstring.h\u003e int main() { // 1.获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(\"shmid : %d\\n\", shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); // 3.读数据 printf(\"%s\\n\", (char *)ptr); printf(\"按任意键继续\\n\"); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0; } #include \u003cstdio.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e#include \u003cstring.h\u003e int main() { // 1.创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT|0664); printf(\"shmid : %d\\n\", shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); char * str = \"helloworld\"; // 3.写数据 memcpy(ptr, str, strlen(str) + 1); printf(\"按任意键继续\\n\"); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0; } ","date":"2021-04-10","objectID":"/ipc/:6:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号量（Semaphore Array） ","date":"2021-04-10","objectID":"/ipc/:7:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"套接字（Socket） ","date":"2021-04-10","objectID":"/ipc/:8:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"本地套接字 本地套接字的作用：本地的进程间通信, 适用于有关系的进程间的通信和没有关系的进程间的通信 本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流 // 本地套接字通信的流程 - tcp // 服务器端 1. 创建监听的套接字 int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); 2. 监听的套接字绑定本地的套接字文件 -\u003e server端 struct sockaddr_un addr; // 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 bind(lfd, addr, len); 3. 监听 listen(lfd, 100); 4. 等待并接受连接请求 struct sockaddr_un cliaddr; int cfd = accept(lfd, \u0026cliaddr, len); 5. 通信 接收数据：read/recv 发送数据：write/send 6. 关闭连接 close(); // 客户端的流程 1. 创建通信的套接字 int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); 2. 监听的套接字绑定本地的IP 端口 struct sockaddr_un addr; // 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 bind(lfd, addr, len); 3. 连接服务器 struct sockaddr_un serveraddr; connect(fd, \u0026serveraddr, sizeof(serveraddr)); 4. 通信 接收数据：read/recv 发送数据：write/send 5. 关闭连接 close(); // 头文件: sys/un.h #define UNIX_PATH_MAX 108 struct sockaddr_un { sa_family_t sun_family; // 地址族协议 af_local char sun_path[UNIX_PATH_MAX]; // 套接字文件的路径, 这是一个伪文件, 大小永远=0 }; 服务端 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/un.h\u003e int main() { unlink(\"server.sock\"); // 1.创建监听的套接字 int lfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(lfd == -1) { perror(\"socket\"); exit(-1); } // 2.绑定本地套接字文件 struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, \"server.sock\"); int ret = bind(lfd, (struct sockaddr *)\u0026addr, sizeof(addr)); if(ret == -1) { perror(\"bind\"); exit(-1); } // 3.监听 ret = listen(lfd, 100); if(ret == -1) { perror(\"listen\"); exit(-1); } // 4.等待客户端连接 struct sockaddr_un cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)\u0026cliaddr, \u0026len); if(cfd == -1) { perror(\"accept\"); exit(-1); } printf(\"client socket filename: %s\\n\", cliaddr.sun_path); // 5.通信 while(1) { char buf[128]; int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) { perror(\"recv\"); exit(-1); } else if(len == 0) { printf(\"client closed....\\n\"); break; } else if(len \u003e 0) { printf(\"client say : %s\\n\", buf); send(cfd, buf, len, 0); } } close(cfd); close(lfd); return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/un.h\u003e int main() { unlink(\"client.sock\"); // 1.创建套接字 int cfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(cfd == -1) { perror(\"socket\"); exit(-1); } // 2.绑定本地套接字文件 struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, \"client.sock\"); int ret = bind(cfd, (struct sockaddr *)\u0026addr, sizeof(addr)); if(ret == -1) { perror(\"bind\"); exit(-1); } // 3.连接服务器 struct sockaddr_un seraddr; seraddr.sun_family = AF_LOCAL; strcpy(seraddr.sun_path, \"server.sock\"); ret = connect(cfd, (struct sockaddr *)\u0026seraddr, sizeof(seraddr)); if(ret == -1) { perror(\"connect\"); exit(-1); } // 4.通信 int num = 0; while(1) { // 发送数据 char buf[128]; sprintf(buf, \"hello, i am client %d\\n\", num++); send(cfd, buf, strlen(buf) + 1, 0); printf(\"client say : %s\\n\", buf); // 接收数据 int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) { perror(\"recv\"); exit(-1); } else if(len == 0) { printf(\"server closed....\\n\"); break; } else if(len \u003e 0) { printf(\"server say : %s\\n\", buf); } sleep(1); } close(cfd); return 0; } ","date":"2021-04-10","objectID":"/ipc/:8:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"远程过程调用（RPC, Remote Procedure Call） ","date":"2021-04-10","objectID":"/ipc/:9:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":" 本文介绍文件IO与标准IO的相关概念，以及一些常用的文件IO函数 ","date":"2021-04-08","objectID":"/fileio/:0:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"基本概念 文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。 标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。 （1）全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 （2）行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 （3）不带缓存：stderr就是了。 ","date":"2021-04-08","objectID":"/fileio/:1:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"原理 文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。（Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。  ","date":"2021-04-08","objectID":"/fileio/:2:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"栈与堆的扩展方向 早期的微弱优势 早期的系统需要考虑有限内存下的内存布局问题。具体来说，内存的一端放置了静态代码和静态数据之后，剩余的区域，既需要动态数据，又需要可增长的栈，那么合理的方案就是各放一端向中间生长。现在的问题就是两个选项：静态内存放在哪端；栈是在静态内存的同端还是对端。 考虑下面的一些条件： 早期的部分机器，从0地址启动[1]。想象一下磁带机的编址。 动态数据从概念上来说，和静态数据比较像 所以从内存布局来说，一个自然的方案是，从0地址依次放置代码、静态数据、动态数据，高地址放置栈。 但是，从安全性来说，向低地址扩展也有微弱劣势： 数组、字符串越界时会覆盖过去栈帧的数据，黑客更容易找到缓冲区溢出攻击的漏洞 历史的实际情况 大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。 主流1：向低地址扩展：x86，MIPS 主流2：自由选择：Arm（但个别指令仅支持向低） 罕见：向高地址扩展：PA-RISC，操作系统Multics 非主流：System z，栈是个链表[2] 如果CPU同时支持向上和向下，例如arm，那么编译器需要指定程序的调用方向，一般还是选择向下。比较罕见的极端的案例是Multics操作系统，这是Unix的巨无霸前身，设计者刻意选用向高地址扩展，因为该架构有助于防御缓冲区溢出攻击[3]。 现代的情况 现代程序的下列特征，导致内存布局问题中的单个栈增长方向无所谓。 使用线性虚拟地址，进程空间为4G或者更高 现代程序写法，栈的大小1M左右已经足够使用。编译器一般都直接限制栈的大小 多线程导致有多个栈，所以堆-栈的两端分割模式是不合适的，每个栈应当有界 引用 作者：刘源 链接：https://www.zhihu.com/question/29520755/answer/373320074 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-04-08","objectID":"/fileio/:2:1","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"open /* #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e // 打开一个已经存在的文件 int open(const char *pathname, int flags); 参数： - pathname：要打开的文件路径 - flags：对文件的操作权限设置还有其他的设置 O_RDONLY, O_WRONLY, O_RDWR 这三个设置是互斥的 返回值：返回一个新的文件描述符，如果调用失败，返回-1 errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。 #include \u003cstdio.h\u003e void perror(const char *s);作用：打印errno对应的错误描述 s参数：用户描述，比如hello,最终输出的内容是 hello:xxx(实际的错误描述) // 创建一个新的文件 int open(const char *pathname, int flags, mode_t mode); 参数： - pathname：要创建的文件的路径 - flags：对文件的操作权限和其他的设置 - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个之间是互斥的 - 可选项：O_CREAT 文件不存在，创建新文件 - mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775 最终的权限是：mode \u0026 ~umask 0777 -\u003e 111111111 \u0026 0775 -\u003e 111111101 ---------------------------- 111111101 按位与：0和任何数都为0 umask的作用就是抹去某些权限。 flags参数是一个int类型的数据，占4个字节，32位。 flags 32个位，每一位就是一个标志位。 */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { // 打开一个文件 int fd = open(\"a.txt\", O_RDONLY); if(fd == -1) { perror(\"open\"); } // 读写操作 // 关闭 close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:3:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"read \u0026 write /* #include \u003cunistd.h\u003e ssize_t read(int fd, void *buf, size_t count); 参数： - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件 - buf：需要读取数据存放的地方，数组的地址（传出参数） - count：指定的数组的大小 返回值： - 成功： \u003e0: 返回实际的读取到的字节数 =0：文件已经读取完了 - 失败：-1 ，并且设置errno #include \u003cunistd.h\u003e ssize_t write(int fd, const void *buf, size_t count); 参数： - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件 - buf：要往磁盘写入的数据，数据 - count：要写的数据的实际的大小 返回值： 成功：实际写入的字节数 失败：返回-1，并设置errno */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e int main() { // 1.通过open打开english.txt文件 int srcfd = open(\"english.txt\", O_RDONLY); if(srcfd == -1) { perror(\"open\"); return -1; } // 2.创建一个新的文件（拷贝文件） int destfd = open(\"cpy.txt\", O_WRONLY | O_CREAT, 0664); if(destfd == -1) { perror(\"open\"); return -1; } // 3.频繁的读写操作 char buf[1024] = {0}; int len = 0; while((len = read(srcfd, buf, sizeof(buf))) \u003e 0) { write(destfd, buf, len); } // 4.关闭文件 close(destfd); close(srcfd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:4:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"lseek /* 标准C库的函数 #include \u003cstdio.h\u003e int fseek(FILE *stream, long offset, int whence); Linux系统函数 #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e off_t lseek(int fd, off_t offset, int whence); 参数： - fd：文件描述符，通过open得到的，通过这个fd操作某个文件 - offset：偏移量 - whence: SEEK_SET 设置文件指针的偏移量 SEEK_CUR 设置偏移量：当前位置 + 第二个参数offset的值 SEEK_END 设置偏移量：文件大小 + 第二个参数offset的值 返回值：返回文件指针的位置 作用： 1.移动文件指针到文件头 lseek(fd, 0, SEEK_SET); 2.获取当前文件指针的位置 lseek(fd, 0, SEEK_CUR); 3.获取文件长度 lseek(fd, 0, SEEK_END); 4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节 lseek(fd, 100, SEEK_END) 注意：需要写一次数据 */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int fd = open(\"hello.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); return -1; } // 扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if(ret == -1) { perror(\"lseek\"); return -1; } // 写入一个空数据 write(fd, \" \", 1); // 关闭文件 close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:5:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"stat /* #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cunistd.h\u003e int stat(const char *pathname, struct stat *statbuf); 作用：获取一个文件相关的一些信息 参数: - pathname：操作的文件的路径 - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息 返回值： 成功：返回0 失败：返回-1 设置errno int lstat(const char *pathname, struct stat *statbuf); 参数: - pathname：操作的文件的路径 - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息 返回值： 成功：返回0 失败：返回-1 设置errno */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { struct stat statbuf; int ret = stat(\"a.txt\", \u0026statbuf); if(ret == -1) { perror(\"stat\"); return -1; } printf(\"size: %ld\\n\", statbuf.st_size); return 0; }access ","date":"2021-04-08","objectID":"/fileio/:6:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"access /* #include \u003cunistd.h\u003e int access(const char *pathname, int mode); 作用：判断某个文件是否有某个权限，或者判断文件是否存在 参数： - pathname: 判断的文件路径 - mode: R_OK: 判断是否有读权限 W_OK: 判断是否有写权限 X_OK: 判断是否有执行权限 F_OK: 判断文件是否存在 返回值：成功返回0， 失败返回-1 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int ret = access(\"a.txt\", F_OK); if(ret == -1) { perror(\"access\"); } printf(\"文件存在！！!\\n\"); return 0; } ","date":"2021-04-08","objectID":"/fileio/:7:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"chmod /* #include \u003csys/stat.h\u003e int chmod(const char *pathname, mode_t mode); 修改文件的权限 参数： - pathname: 需要修改的文件的路径 - mode:需要修改的权限值，八进制的数 返回值：成功返回0，失败返回-1 */ #include \u003csys/stat.h\u003e#include \u003cstdio.h\u003eint main() { int ret = chmod(\"a.txt\", 0777); if(ret == -1) { perror(\"chmod\"); return -1; } return 0; } ","date":"2021-04-08","objectID":"/fileio/:8:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"truncate /* #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int truncate(const char *path, off_t length); 作用：缩减或者扩展文件的尺寸至指定的大小 参数： - path: 需要修改的文件的路径 - length: 需要最终文件变成的大小 返回值： 成功返回0， 失败返回-1 */ #include \u003cunistd.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e int main() { int ret = truncate(\"b.txt\", 5); if(ret == -1) { perror(\"truncate\"); return -1; } return 0; }  ","date":"2021-04-08","objectID":"/fileio/:9:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"chdir \u0026 getcwd /* #include \u003cunistd.h\u003e int chdir(const char *path); 作用：修改进程的工作目录 比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder 参数： path : 需要修改的工作目录 #include \u003cunistd.h\u003e char *getcwd(char *buf, size_t size); 作用：获取当前工作目录 参数： - buf : 存储的路径，指向的是一个数组（传出参数） - size: 数组的大小 返回值： 返回的指向的一块内存，这个数据就是第一个参数 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cfcntl.h\u003e int main() { // 获取当前的工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(\"当前的工作目录是：%s\\n\", buf); // 修改工作目录 int ret = chdir(\"/home/nowcoder/Linux/lesson13\"); if(ret == -1) { perror(\"chdir\"); return -1; } // 创建一个新的文件 int fd = open(\"chdir.txt\", O_CREAT | O_RDWR, 0664); if(fd == -1) { perror(\"open\"); return -1; } close(fd); // 获取当前的工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(\"当前的工作目录是：%s\\n\", buf1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:10:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"mkdir /* #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e int mkdir(const char *pathname, mode_t mode); 作用：创建一个目录 参数： pathname: 创建的目录的路径 mode: 权限，八进制的数 返回值： 成功返回0， 失败返回-1 */ #include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e int main() { int ret = mkdir(\"aaa\", 0777); if(ret == -1) { perror(\"mkdir\"); return -1; } return 0; } ","date":"2021-04-08","objectID":"/fileio/:11:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"opendir \u0026 readdir \u0026 closedir /* // 打开一个目录 #include \u003csys/types.h\u003e #include \u003cdirent.h\u003e DIR *opendir(const char *name); 参数： - name: 需要打开的目录的名称 返回值： DIR * 类型，理解为目录流 错误返回NULL // 读取目录中的数据 #include \u003cdirent.h\u003e struct dirent *readdir(DIR *dirp); - 参数：dirp是opendir返回的结果 - 返回值： struct dirent，代表读取到的文件的信息 读取到了末尾或者失败了，返回NULL // 关闭目录 #include \u003csys/types.h\u003e #include \u003cdirent.h\u003e int closedir(DIR *dirp); */ #include \u003csys/types.h\u003e#include \u003cdirent.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e int getFileNum(const char * path); // 读取某个目录下所有的普通文件的个数 int main(int argc, char * argv[]) { if(argc \u003c 2) { printf(\"%s path\\n\", argv[0]); return -1; } int num = getFileNum(argv[1]); printf(\"普通文件的个数为：%d\\n\", num); return 0; } // 用于获取目录下所有普通文件的个数 int getFileNum(const char * path) { // 1.打开目录 DIR * dir = opendir(path); if(dir == NULL) { perror(\"opendir\"); exit(0); } struct dirent *ptr; // 记录普通文件的个数 int total = 0; while((ptr = readdir(dir)) != NULL) { // 获取名称 char * dname = ptr-\u003ed_name; // 忽略掉. 和.. if(strcmp(dname, \".\") == 0 || strcmp(dname, \"..\") == 0) { continue; } // 判断是否是普通文件还是目录 if(ptr-\u003ed_type == DT_DIR) { // 目录,需要继续读取这个目录 char newpath[256]; sprintf(newpath, \"%s/%s\", path, dname); total += getFileNum(newpath); } if(ptr-\u003ed_type == DT_REG) { // 普通文件 total++; } } // 关闭目录 closedir(dir); return total; } ","date":"2021-04-08","objectID":"/fileio/:12:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"dup /* #include \u003cunistd.h\u003e int dup(int oldfd); 作用：复制一个新的文件描述符 fd=3, int fd1 = dup(fd), fd指向的是a.txt, fd1也是指向a.txt 从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstring.h\u003e int main() { int fd = open(\"a.txt\", O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if(fd1 == -1) { perror(\"dup\"); return -1; } printf(\"fd : %d , fd1 : %d\\n\", fd, fd1); close(fd); char * str = \"hello,world\"; int ret = write(fd1, str, strlen(str)); if(ret == -1) { perror(\"write\"); return -1; } close(fd1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:13:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"dup2 /* #include \u003cunistd.h\u003e int dup2(int oldfd, int newfd); 作用：重定向文件描述符 oldfd 指向 a.txt, newfd 指向 b.txt 调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt oldfd 必须是一个有效的文件描述符 oldfd和newfd值相同，相当于什么都没有做 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cfcntl.h\u003e int main() { int fd = open(\"1.txt\", O_RDWR | O_CREAT, 0664); if(fd == -1) { perror(\"open\"); return -1; } int fd1 = open(\"2.txt\", O_RDWR | O_CREAT, 0664); if(fd1 == -1) { perror(\"open\"); return -1; } printf(\"fd : %d, fd1 : %d\\n\", fd, fd1); int fd2 = dup2(fd, fd1); if(fd2 == -1) { perror(\"dup2\"); return -1; } // 通过fd1去写数据，实际操作的是1.txt，而不是2.txt char * str = \"hello, dup2\"; int len = write(fd1, str, strlen(str)); if(len == -1) { perror(\"write\"); return -1; } printf(\"fd : %d, fd1 : %d, fd2 : %d\\n\", fd, fd1, fd2); close(fd); close(fd1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:14:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Operating System"],"content":"fcntl /* #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, ...); 参数： fd : 表示需要操作的文件描述符 cmd: 表示对文件描述符进行如何操作 - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值） int ret = fcntl(fd, F_DUPFD); - F_GETFL : 获取指定的文件描述符文件状态flag 获取的flag和我们通过open函数传递的flag是一个东西。 - F_SETFL : 设置文件描述符文件状态flag 必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改 可选性：O_APPEND, O)NONBLOCK O_APPEND 表示追加数据 NONBLOK 设置成非阻塞 阻塞和非阻塞：描述的是函数调用的行为。 */ #include \u003cunistd.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e int main() { // 1.复制文件描述符 // int fd = open(\"1.txt\", O_RDONLY); // int ret = fcntl(fd, F_DUPFD); // 2.修改或者获取文件状态flag int fd = open(\"1.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); return -1; } // 获取文件描述符状态flag int flag = fcntl(fd, F_GETFL); if(flag == -1) { perror(\"fcntl\"); return -1; } flag |= O_APPEND; // flag = flag | O_APPEND // 修改文件描述符状态的flag，给flag加入O_APPEND这个标记 int ret = fcntl(fd, F_SETFL, flag); if(ret == -1) { perror(\"fcntl\"); return -1; } char * str = \"nihao\"; write(fd, str, strlen(str)); close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:15:0","tags":["C/C++","Unix"],"title":"Unix FileIO","uri":"/fileio/"},{"categories":["Tools"],"content":" GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境 GDB调试的三种方式： 目标板直接使用GDB进行调试。 目标板使用gdbserver，主机使用xxx-linux-gdb作为客户端。 目标板使用ulimit -c unlimited，生成core文件；然后主机使用xxx-linux-gdb ./test ./core。 ","date":"2021-04-07","objectID":"/gdb/:0:0","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"GDB 调试 构造测试程序如下main.c和sum.c如下: // main.c: #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e extern int sum(int value); struct inout { int value; int result; }; int main(int argc, char * argv[]) { struct inout * io = (struct inout * ) malloc(sizeof(struct inout)); if (NULL == io) { printf(\"Malloc failed.\\n\"); return -1; } if (argc != 2) { printf(\"Wrong para!\\n\"); return -1; } io -\u003e value = *argv[1] - '0'; io -\u003e result = sum(io -\u003e value); printf(\"Your enter: %d, result:%d\\n\", io -\u003e value, io -\u003e result); return 0; } // sum.c: int sum(int value) { int result = 0; int i = 0; for (i = 0; i \u003c value; i++) result += (i + 1); return result; } 然后gcc main.c sum.c -o main -g, 得到main可执行文件， 输入gdb main可进入调试. 下面介绍了gdb大部分功能，1.1 设置断点以及 1.3显示栈帧是常用功能；调试过程中可以需要1.6 单步执行，并且1.4 显示变量、1.5显示寄存器、1.8 监视点、1.9 改变变量的值。 如果进程已经运行中，需要1.11 attach到进程，或者1.10 生成转储文件进行分析。当然为了提高效率可以自定义1.13 初始化文件。 ","date":"2021-04-07","objectID":"/gdb/:1:0","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"设置断点* 设置断点可以通过b或者break设置断点，断点的设置可以通过函数名、行号、文件名+函数名、文件名+行号以及偏移量、地址等进行设置。 格式为： break 函数名 break 行号 break 文件名:函数名 break 文件名:行号 break +偏移量 break -偏移量 break *地址 查看断点，通过info break查看断点列表。 (gdb) b 13 Breakpoint 1 at 0x11aa: file main.c, line 13. (gdb) b sum.c:2 Breakpoint 2 at 0x123d: file sum.c, line 2. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000000011aa in main at main.c:13 2 breakpoint keep y 0x000000000000123d in sum at sum.c:2 删除断点通过命令包括： delete \u003c断点id\u003e：删除指定断点 delete：删除所有断点 clear clear 函数名 clear 行号 clear 文件名：行号 clear 文件名：函数名 断点还可以条件断住 break 断点 if 条件；比如break sum if value==9，当输入的value为9的时候才会断住。 condition 断点编号：给指定断点删除触发条件 condition 断点编号 条件：给指定断点添加触发条件 断点还可以通过disable/enable临时停用启用。 disable disable 断点编号 disable display 显示编号 disable mem 内存区域 enable enable 断点编号 enable once 断点编号：该断点只启用一次，程序运行到该断点并暂停后，该断点即被禁用。 enable delete 断点编号 enable display 显示编号 enable mem 内存区域 断点commands高级功能 大多数时候需要在断点处执行一系列动作，gdb提供了在断点处执行命令的高级功能commands。 #include \u003cstdio.h\u003e int total = 0; int square(int i) { int result=0; result = i*i; return result; } int main(int argc, char **argv) { int i; for(i=0; i\u003c10; i++) { total += square(i); } return 0; } 比如需要对如上程序square参数i为5的时候断点，并在此时打印栈、局部变量以及total的值 编写gdb.init如下： set logging on gdb.log b square if i == 5 commands bt full i locals p total print \"Hit break when i == 5\" end 在gdb shell中source gdb.init，然后r执行命令，结果如下： (gdb) source gdb.init Breakpoint 1 at 0x1129: file commands.c, line 6. (gdb) r Starting program: /home/lwy/workspace/gdbtest/commands Breakpoint 1, square (i=5) at commands.c:6 6 { #0 square (i=5) at commands.c:6 result = 25 #1 0x000055555555516f in main (argc=1, argv=0x7fffffffe048) at commands.c:20 i = 6 result = 25 $1 = 55 $2 = \"Hit break when i == 5\" 可以看出断点在i==5的时候断住了，并且此时打印了正确的值。 ","date":"2021-04-07","objectID":"/gdb/:1:1","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"运行 “gdb 命令”之后，run可以在gdb下运行命令；如果命令需要参数则跟在run之后。 (gdb) run 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Your enter: 9, result:45 [Inferior 1 (process 12362) exited normally] 如果需要断点在main()处，直接执行start就可以。 (gdb) start Temporary breakpoint 1 at 0x555555555189: file main.c, line 11. Starting program: /home/lwy/workspace/gdbtest/main 9 Temporary breakpoint 1, main (argc=21845, argv=0x0) at main.c:11 ","date":"2021-04-07","objectID":"/gdb/:1:2","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示栈帧* 如果遇到断点而暂停执行，或者coredump可以显示栈帧。 通过bt可以显示栈帧，bt full可以显示局部变量。 (gdb) r 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Breakpoint 2, sum (value=9) at sum.c:3 3 int i = 0; (gdb) bt #0 sum (value=9) at sum.c:3 #1 0x0000555555555204 in main (argc=2, argv=0x7fffffffe048) at main.c:24 (gdb) bt full #0 sum (value=9) at sum.c:3 result = 0 i = 32767 #1 0x0000555555555204 in main (argc=2, argv=0x7fffffffe048) at main.c:24 io = 0x5555555592a0 命令格式如下： bt bt full：不仅显示backtrace，还显示局部变量 bt N：显示开头N个栈帧 bt full N ","date":"2021-04-07","objectID":"/gdb/:1:3","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示变量* print 变量名可以显示变量内容。 ptype 变量名 可以打印变量类型 如果需要一行监控多个变量，可以通过p {var1, var2, var3}。 如果要跟踪自动显示，可以使用display {var1, var2, var3} 取消跟踪用 undisplay 编号 查看文件代码：list/l [文件名:][行号/函数名] 设置显示的行数：show list/listsize , set list/listsize 行数 ","date":"2021-04-07","objectID":"/gdb/:1:4","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示寄存器* info reg可以显示寄存器内容。 (gdb) i r rax 0x9 9 rbx 0x555555555270 93824992236144 rcx 0x5555555592b0 93824992252592 rdx 0x9 9 rsi 0x0 0 rdi 0x9 9 rbp 0x7fffffffdf20 0x7fffffffdf20 rsp 0x7fffffffdf20 0x7fffffffdf20 r8 0x5555555592a0 93824992252576 r9 0x7ffff7dd1070 140737351848048 r10 0x7ffff7fb9be0 140737353849824 r11 0x7ffff7fb9be0 140737353849824 r12 0x5555555550a0 93824992235680 r13 0x7fffffffe040 140737488347200 r14 0x0 0 r15 0x0 0 rip 0x55555555524b 0x55555555524b \u003csum+25\u003e eflags 0x216 [ PF AF IF ] cs 0x33 51 ss 0x2b 43 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 在寄存器名之前加$可以显示寄存器内容， p $寄存器：显示寄存器内容 p/x $寄存器：十六进制显示寄存器内容。 (gdb) p $ss $2 = 43 (gdb) p/x $pc $3 = 0x55555555524b 用x命令可以显示内容内容，x/格式 地址。 x $pc：显示程序指针内容 x/i $pc：显示程序指针汇编。 x/10i $pc：显示程序指针之后10条指令。 x/128wx 0xfc207000：从0xfc20700开始以16进制打印128个word。 (gdb) x $pc 0x55555555524b \u003csum+25\u003e: 0x00fc45c7 (gdb) x/i $pc =\u003e 0x55555555524b \u003csum+25\u003e: movl $0x0,-0x4(%rbp) (gdb) x/10i $pc =\u003e 0x55555555524b \u003csum+25\u003e: movl $0x0,-0x4(%rbp) 0x555555555252 \u003csum+32\u003e: jmp 0x555555555261 \u003csum+47\u003e 0x555555555254 \u003csum+34\u003e: mov -0x4(%rbp),%eax 0x555555555257 \u003csum+37\u003e: add $0x1,%eax 0x55555555525a \u003csum+40\u003e: add %eax,-0x8(%rbp) 0x55555555525d \u003csum+43\u003e: addl $0x1,-0x4(%rbp) 0x555555555261 \u003csum+47\u003e: mov -0x4(%rbp),%eax 0x555555555264 \u003csum+50\u003e: cmp -0x14(%rbp),%eax 0x555555555267 \u003csum+53\u003e: jl 0x555555555254 \u003csum+34\u003e 0x555555555269 \u003csum+55\u003e: mov -0x8(%rbp),%eax 还可以通过disassemble指令来反汇编。 disassemble disassemble 程序计数器 ：反汇编pc所在函数的整个函数。 disassemble addr-0x40,addr+0x40：反汇编addr前后0x40大小。 ","date":"2021-04-07","objectID":"/gdb/:1:5","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"单步执行* 单步执行有两个命令next和step，缩写为n和s，两者的区别是next遇到函数不会进入函数内部，step会执行到函数内部。 finish （跳出函数体） 如果需要逐条汇编指令执行，可以分别使用nexti和stepi。 ","date":"2021-04-07","objectID":"/gdb/:1:6","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"继续执行*  调试时，使用continue命令(缩写：c)继续执行程序。程序遇到断电后再次暂停执行；如果没有断点，就会一直执行到结束。 continue：继续执行 continue 次数：继续执行一定次数。 ","date":"2021-04-07","objectID":"/gdb/:1:7","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"监视点* 要想找到变量在何处被改变，可以使用watch命令设置监视点watchpoint。 watch \u003c表达式\u003e：表达式发生变化时暂停运行 awatch \u003c表达式\u003e：表达式被访问、改变是暂停执行 rwatch \u003c表达式\u003e：表达式被访问时暂停执行 (gdb) watch i Hardware watchpoint 3: i (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000555555555244 in sum at sum.c:3 stop only if value==9 breakpoint already hit 1 time 3 hw watchpoint keep y ","date":"2021-04-07","objectID":"/gdb/:1:8","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"改变变量的值* 通过set variable \u003c变量\u003e=\u003c表达式\u003e来修改变量的值。 简写set var 变量名=变量值 （循环中用的多） until (跳出循环) (gdb) b main Breakpoint 4 at 0x555555555189: file main.c, line 11. (gdb) r 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Breakpoint 4, main (argc=21845, argv=0x0) at main.c:11 11 { (gdb) n 12 struct inout * io = (struct inout * ) malloc(sizeof(struct inout)); (gdb) n 13 if (NULL == io) { (gdb) n 18 if (argc != 2) { (gdb) n 23 io -\u003e value = *argv[1] - '0'; (gdb) n 24 io -\u003e result = sum(io -\u003e value); (gdb) print io-\u003evalue $4 = 9 (gdb) set variable io-\u003evalue=10 (gdb) n 25 printf(\"Your enter: %d, result:%d\\n\", io -\u003e value, io -\u003e result); (gdb) n Your enter: 10, result:55 26 return 0; set $r0=xxx：设置r0寄存器的值为xxx。 ","date":"2021-04-07","objectID":"/gdb/:1:9","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"生成内核转储文件* 通过generate-core-file生成core.xxxx转储文件。 然后gdb ./main ./core.xxxx查看恢复的现场。 (gdb) generate-core-file warning: target file /proc/14188/cmdline contained unexpected null characters Saved corefile core.14188 lwy@lwysLaptop:~/workspace/gdbtest$ gdb ./main ./core.14188 Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from ./main... [New LWP 14188] Core was generated by `/home/lwy/workspace/gdbtest/main 9'. Program terminated with signal SIGTRAP, Trace/breakpoint trap. #0 main (argc=2, argv=0x7fffffffe048) at main.c:26 26 return 0; 另一命令gcore可以从命令行直接生成内核转储文件。 gcore pidof 命令：无需停止正在执行的程序以获得转储文件。 ","date":"2021-04-07","objectID":"/gdb/:1:10","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"attach到进程* 如果程序已经运行，或者是调试陷入死循环而无法返回控制台进程，可以使用attach命令。 attach pid 通过ps aux可以查看进程的pid，然后使用bt查看栈帧。 以top为例操作步骤为： ps -aux查看进程pid，为16974. sudo gdb attach 16974，使用gdb 附着到top命令。 使用bt full查看，当前栈帧。此时使用print等查看信息。 还可以通过info proc查看进程信息。 ","date":"2021-04-07","objectID":"/gdb/:1:11","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"反复执行 continue、step、stepi、next、nexti都可以指定重复执行的次数。 ignore 断点编号 次数：可以忽略指定次数断点。 ","date":"2021-04-07","objectID":"/gdb/:1:12","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"dump内存到指定文件 在gdb调试中可能需要将一段内存导出到文件中，可以借助dump命令。 命令格式： dump binary memory FILE START STOP 比如dump binary memory ./dump.bin 0x0 0x008000000，将内存区间从0x0到0x00800000导出到dump.bin中。 ","date":"2021-04-07","objectID":"/gdb/:1:13","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"多进程调试 使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child] 设置调试模式：set detach-on-fork [on | off] 默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。 查看调试的进程：info inferiors 切换当前调试的进程：inferior id 使进程脱离 GDB 调试：detach inferiors id ","date":"2021-04-07","objectID":"/gdb/:1:14","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Operating System"],"content":"进程的概念 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。  一个进程在CPU上运行可以有两种运行模式（进程状态）：用户模式和内核模式。如果当前运行的是用户程序（用户代码），那么对应进程就处于用户模式（用户态），如果出现系统调用或者发生中断，那么对应进程就处于内核模式（核心态） ","date":"2021-04-06","objectID":"/process/:1:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程的状态模型 下图为进程的7状态模型，常用的5状态模型在该图的基础上去掉了挂起状态。其中包括如下状态： New State：New state is the state when the process is under creation Ready State: When the process is created new state comes, which is called ready state. After creation process comes under ready state. In ready state more than one process can also come. For example: One process is created at the same time second process is created then both the process will come under ready state. Running State: From ready state we have to select a process, and then have to allot CPU to that process for run. When CPU is allotted to process in ready state that process comes in running state. In running state only one process can stay at a time. Because CPU can be allotted to single process at a time. Wait State: When a process request for input/output than that process will left the running state, and will join new state known as wait state. In wait state more than one process can stay. After completion of I/O request process will go to ready state. Termination State: When process comes in running state, there is no more input output request by the process, because it’s already get completed. So process will go to termination state. Suspend Ready State: When ready state is not able to occupy more states in it, than some states are suspended in suspended state. Suspend ready state will be in secondary memory not in primary memory. When ready state get space for new processes than, processes from suspended ready state gets switch back to ready state. Such transaction is known as resume. Suspend Wait State: Similarly suspend wait state is also reside in process state diagram. ","date":"2021-04-06","objectID":"/process/:2:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"Linux进程组织 Linux进程通过一个task_struct结构体描述，在linux/sched.h中定义，通过理解该结构，可更清楚的理解linux进程模型。包含进程所有信息的task_struct数据结构是比较庞大的，但是该数据结构本身并不复杂，我们将它的所有域按其功能可做如下划分：  进程状态（State）  进程调度信息（Scheduling Information）  各种标识符（Identifiers）  进程通信有关信息（IPC：Inter_Process Communication）  时间和定时器信息（Times and Timers）  进程链接信息（Links）  文件系统信息（File System）  虚拟内存信息（Virtual Memory）  页面管理信息（page）  对称多处理器（SMP）信息  和处理器相关的环境（上下文）信息（Processor Specific Context）  其他信息 ","date":"2021-04-06","objectID":"/process/:3:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程状态 为了对进程从产生到消亡的整个过程进行跟踪和描述，就需要定义各种进程的各种状态并制定相应的状态转换策略，以此来控制进程的运行。 Linux系统中，进程状态在 task_struct 中定义如下： volatile long state; /* -1 unrunnable, 0 runnable, \u003e0 stopped */ 其状态取值如下： #define TASK_RUNNING 0 #define TASK_INTERRUPTIBLE 1 #define TASK_UNINTERRUPTIBLE 2 #define __TASK_STOPPED 4 #define __TASK_TRACED 8 /* in tsk-\u003eexit_state */ #define EXIT_ZOMBIE 16 #define EXIT_DEAD 32 /* in tsk-\u003estate again */ #define TASK_DEAD 64 #define TASK_WAKEKILL 128 #define TASK_WAKING 256 #define TASK_STATE_MAX 512 对进程每个状态简析如下： TASK_RUNNING （可运行状态）：处于这种状态的进程，要么正在运行、要么正准备运行。正在运行的进程就是当前进程（由current所指向的进程），而准备运行的进程只要得到CPU就可以立即投入运行，CPU是这些进程唯一等待的系统资源。 TASK_INTERRUPTIBLE（可中断的等待状态）：表示进程被阻塞（睡眠），直到某个条件达成，进程的状态就被设置为TASK_RUNNING。处于该状态的进程正在等待某个事件（event）或某个资源，而被挂起。对应的task_struct结构被放入对应事件的等待队列中。处于可中断等待态的进程可以被信号（外部中断触发或者其他进程触发）唤醒，如果收到信号，该进程就从等待状态进入可运行状态，并且加入到运行队列中，等待被调度。 TASK_UNINTERRUPTIBLE（不可中断的等待状态）：该状态与 TASK_INTERRUPTIBLE 状态类似，也表示进程被阻塞，处于睡眠状态。当进程等待的某些条件被满足了之后，内核也会将该进程的状态设置为 TASK_RUNNING。但是，处于这个状态下的进程不能在接收到某个信号之后立即被唤醒。这时该状态与 TASK_INTERRUPTIBLE 状态唯一的区别。 __TASK_STOPPED（暂停状态）：此时的进程暂时停止运行来接受某种特殊处理。通常当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后就处于这种状态。例如，正接受调试的进程就处于这种状态。 __TASK_TRACED（跟踪状态）：当前进程正在被另一个进程所监视。 EXIT_ZOMBIE（僵死状态）：进程虽然已经终止，但由于某种原因，父进程还没有执行wait()系统调用，终止进程的信息也还没有回收。顾名思义，处于该状态的进程就是死进程，这种进程实际上是系统中的垃圾，必须进行相应处理以释放其占用的资源。 EXIT_DEAD：一个进程的最终状态。 以下是LINUX进程间状态转换和内核调用图解 ","date":"2021-04-06","objectID":"/process/:3:1","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程内存布局 每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”： 文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。 初始化数据段：包含显示初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。 未初始化数据段：包含了未进行显示初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。出于历史原因，此段常被称为BSS段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配空间。 栈（stack）：是一个动态增长和收缩的段，有栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。 堆（heap）：是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称为program break。 对于初始化和未初始化的数据段而言，不太常用、但表达更清晰的称为分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。 在大多数Unix（包括Linux）中的C语言编程环境提供了3个全局符号（symbol）：etext、edata、end，可以在程序中使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。 使用这些符号，必须显式声明如下： // For example, \u0026etext gives the address of the end of the program text / start of initialized data extern char etext, edata, end; 图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。 ","date":"2021-04-06","objectID":"/process/:3:2","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"孤儿进程（orphan） 我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main () { /*fpid表示fork函数返回的值,fork会返回两次， 一次是父进程，返回值是子进程的Pid，在子进程会返回0*/ pid_t fpid; fpid=fork();//fork后会出现两个分支执行下面的代码，一个父进程，一个新的子进程 if (fpid \u003c 0) printf(\"fork error!\"); else if (fpid == 0) { // printf(\"child id is %dn\",getpid()); sleep(100); } else { //父进程 printf(\"parent id is %dn\",getpid()); sleep(30);//睡眠30s，在子进程之前退出 printf(\"parend finally...\"); } } ","date":"2021-04-06","objectID":"/process/:3:3","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"僵尸进程（zombie） 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。 unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。 任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。 僵尸进程危害场景： 例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main () { /*fpid表示fork函数返回的值,fork会返回两次， 一次是父进程，返回值是子进程的Pid，在子进程会返回0*/ pid_t fpid; fpid=fork();//fork后会出现两个分支执行下面的代码，一个父进程，一个新的子进程 if (fpid \u003c 0) printf(\"fork error!\"); else if (fpid == 0) { // printf(\"child id is %dn\",getpid()); sleep(30);//睡眠30s，在父进程之前退出 printf(\"child finally...\"); } else { //父进程 printf(\"parent id is %dn\",getpid()); sleep(60); printf(\"parend finally...\"); } } 僵尸进程解决办法 通过信号机制 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示： #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e static void sig_child(int signo); int main() { pid_t pid; //创建捕捉子进程退出信号 signal(SIGCHLD,sig_child); pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } else if (pid == 0) { printf(\"I am child process,pid id %d.I am exiting.\\n\",getpid()); exit(0); } printf(\"I am father process.I will sleep two seconds\\n\"); //等待子进程先退出 sleep(2); //输出进程信息 system(\"ps -o pid,ppid,state,tty,command\"); printf(\"father process is exiting.\\n\"); return 0; } static void sig_child(int signo) { pid_t pid; int stat; //处理僵尸进程 while ((pid = waitpid(-1, \u0026stat, WNOHANG)) \u003e0) printf(\"child %d terminated.\\n\", pid); } fork两次 《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e int main() { pid_t pid; //创建第一个子进程 pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } //第一个子进程 else if (pid == 0) { //子进程再创建子进程 printf(\"I am the first child process.pid:%d\\tppid:%d\\n\",getpid(),getppid()); pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } //第一个子进程退出 else if (pid \u003e0) { printf(\"first procee is exited.\\n\"); exit(0); } //第二个子进程 //睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里 sleep(3); printf(\"I am the second child process.pid: %d\\tppid:%d\\n\",getpid(),getppid()); exit(0); } //父进程处理第一个子进程退出 if (waitpid(pid, NULL, 0) != pid) { perror(\"waitepid error:\"); exit(1); } exit(0); return 0; } ","date":"2021-04-06","objectID":"/process/:3:4","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"守护进程 控制终端 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl + C会产生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 进程组 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员 会话 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程 守护进程 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程特征 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事： 该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID 该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断 如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。我认为创建新会话的进程不能是组长进程的原因：在新创建的会话中，创建会话的进程成为了会话首进程，同时，该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID，如果其已经是一个组长进程，那么就会产生矛盾。 一般守护进程创建步骤 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。 执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（/）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。 核心业务逻辑 示例 /* 写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。 */ #include \u003cstdio.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/time.h\u003e#include \u003csignal.h\u003e#include \u003ctime.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e void work(int num) { // 捕捉到信号之后，获取系统时间，写入磁盘文件 time_t tm = time(NULL); struct tm * loc = localtime(\u0026tm); // char buf[1024]; // sprintf(buf, \"%d-%d-%d %d:%d:%d\\n\",loc-\u003etm_year,loc-\u003etm_mon // ,loc-\u003etm_mday, loc-\u003etm_hour, loc-\u003etm_min, loc-\u003etm_sec); // printf(\"%s\\n\", buf); char * str = asctime(loc); int fd = open(\"time.txt\", O_RDWR | O_CREAT | O_APPEND, 0664); write(fd ,str, strlen(str)); close(fd); } int main() { // 1.创建子进程，退出父进程 pid_t pid = fork(); if(pid \u003e 0) { exit(0); } // 2.将子进程重新创建一个会话 setsid(); // 3.设置掩码 umask(022); // 4.更改工作目录 chdir(\"/home/nowcoder/\"); // 5. 关闭、重定向文件描述符 int fd = open(\"/dev/null\", O_RDWR); dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); // 6.业务逻辑 // 捕捉定时信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(\u0026act.sa_mask); sigaction(SIGALRM, \u0026act, NULL); struct itimerval val; val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // 创建定时器 setitimer(ITIMER_REAL, \u0026val, NULL); // 不让进程结束 while(1) { sleep(10); } return 0; } ","date":"2021-04-06","objectID":"/process/:3:5","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程管理命令 ps ps命令（Processes Statistic）时Linux系统中最为常用的进程查看工具，主要用于显示包含当前运行的各进程完整信息的静态快照。通过不同的命令选项，可以有选择性地查看进程信息。 ■ a：显示当前终端下的所有进程信息，包括其他用户的进程。与“x”选项结合时将显示系统中所有的进程信息。 ■ u：使用以用户为主的格式输出进程信息。 ■ x：显示当前用户在所有终端下的进程信息。 ■ –e：显示系统内的所有进程信息。 ■ –l：使用长格式显示进程信息。 ■ –f：使用完整的格式显示进程信息。 以上是ps命令中几个常用的选项，需要注意的是，有一部分选项时不带“-”前缀的。习惯上将上述选项组合在一起使用，如执行“ps aux”或“ps -elf” 上述输出信息中，第一行为列表标题，其各字段的含义描述如下。 ■ USER：启动该进程的户账号的名称。 ■ PID：该进程在系统中的数字ID号，在当前系统中是唯一的。 ■ TTY：表明该进程在哪个终端上运行。“？”表示未知或不需要终端。 ■ STAT:显示了进程当前的状态，如S（休眠）、R（运行）、Z（僵死）、\u003c（高优先级）、N（低优先级）、s（父进程）、+（前台进程）。 ■ START：启动该进程的时间。 ■ TIME：该进程占用的CPU时间。 ■ COMMAND：启动该进程的命令的名称。 ■ %CPU：CPU占用的百分比。 ■ %MEM：内存占用的百分比。 ■ VSZ：占用虚拟内存（swap空间）的大小。 ■ RSS：占用常驻内存（物理内存）的大小。 top top命令将会在当前终端以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次。作用类似Windows系统中的“任务管理器”。 上述输出信息中，开头的部分显示了系统任务（Tasks）、CPU占用、内存占用（Mem）、交换空间（Swap）等汇总信息；汇总信息下方依次显示当前进程的排名情况。相关信息的含义表述如下。 系统任务（Tasks）信息：total，总进程数; running,正在运行的进程数；sleeping，休眠的进程数；stopped，终止的进程数；zombie，僵死无响应的进程数。 CPU占用信息：us，用户占用；sy，内核占用；ni，优先级调度占用；id，空闲CPU；wa，1/0等占用； hi，硬件中断占用，si，软件中断占用；st，虚拟化占用。 内存占用（Mem）信息：total，总内存空间；used，已用内存；free，空闲内存；buffers，缓冲区域。 交换空间（Swap）占用：total，总内存空间；used，已用内存；free，空闲内存； buffers，缓冲区域。 在top命令的全屏操作界面中：可以按P键根据CPU占用情况对进程列表进行排序。 按M键根据内存占用情况进行排序。 按N键根据启动时间进行排序。 按h键可以获得top程序的在线帮助。 按q键可以正常的退出top程序。 按k键在列表上方会出现“PID to kill：”的提示信息，根据提示输入指定进程的PID并按Enter键确认即可终止对应的进程。 pgrep 使用pgrep命令可以根据进程的名称、运行该进程的用户、进程所在的终端等多种属性查询特定进程的PID号。 通过pgrep命令，可以只指定进程的一部分名称进行查询，结合“-l”选项可同时输出对应的进程名（否则只输PID号，不便于理解）。例如，查询进程中包含“log”的进程及其PID号，可以执行以下操作。 [root@lwy~]# pgrep -l “log” 2538 rsyslog 2113 mcelog 还可以结合“-U”选项查询特定用户的进程、“-t”选项查询在特定终端运行的进程。例如，若要查询用户zhangsan在tty3终端上运行的进程及PID号，可以执行以下操作。 [root@lwy~]# pgrep -l -U zhangsan-t tty3 2105 bash 2122 vim pstree pstree命令可以输出Linux系统中各进程的树形结构，以更加直观地判断出各进程之间的相互关系（父、子进程）。 pstree命令默认情况下只显示个进程的名称，结合“-p”选项使用时可以同时列出对应的PID号，结合“-u”选项可以列出对应的用户名，结合“-a”选项可以列出完整的命令信息。例如，执行“pstree -aup”命令可以查看当前系统的进程树，包括个进程对应的PID号、用户名、完整命令等信息。从出输出结果中可以看出，init进程确实是Linux系统中所有进程的“始祖” 改变进程的运行方式 挂起当前的进程  当Linux系统中的命令正在前台执行时（运行尚未结束），按Ctrl+Z组合键可以将当前进程挂起（调入后台并停止执行），这种操作在需要暂停当前进程并进行其他操作时特别有用。 [root@lwy~]# cp /dev/cdrom/mnt/Redhat6.0.iso [1]+ Stopped cp -i/dev/cdrom /mnt/Redhat6.0.iso 查看后台的进程 查看当前终端中在后台运行的进程任务时，可以使用jobs命令，结合“-l”选项可以同时显示出该进程对应的PID号。 [root@lwy~]# jobs -l [1]+ 2193 Stopped cp -i /dev/cdrom /mnt/Redhat6.0.iso 将后台的进程恢复运行 ■ 使用bg（BackGround，后台）命令，可以将后台中暂定执行（如按Ctrl+Z组合键挂起）的任务恢复运行，继续在后台执行操作、 ■ 使用fg命令（ForeGround，前台）命令，可以将后台任务重新恢复到前台运行。 除非后台中的任务只有一个，否则bg和fg命令都需要指定后台进程的任务编号作为参数。 例如，执行“fg 1”命令可以将之前挂起至后台的cp进程重新调入前台执行。 [root@lwy/]# jobs [1]+ Stopped cp -i/dev/cdrom /mnt/Redhat6.0.iso [root@lwy/]# fg 1 cp -i /dev/cdrom /mnt/Redhat6.0.iso 用pkill命令终止进程 使用pkill命令可以根据进程的名称、运行该进程的用户、进程所在的终端等多种属性终止特定的进程，大部分选项与pgrep命令基本类似，如“-U”（指定用户）、“-t”（指定终端）等选项。 例如，若要终止由用户zhangsan启动的进程（包括登陆Shell），可以执行以下操作。 [root@lwy/]# pgrep -l -U\"zhangsan\" 2105 bash [root@lwy/]# pkill -9 -U\"zhangsan\" [root@lwy/]# pgrep -l -U\"zhangsan\" ","date":"2021-04-06","objectID":"/process/:3:6","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Tools"],"content":"静态库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。 库的好处：1.代码保密 2.方便部署和分发 ","date":"2021-04-04","objectID":"/make_lib/:1:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"静态库的使用 通过gcc的-L命令指定库的路径，通过-l命令指定库的名字，注意这里库的名字不加lib,例如库的文件名为libxxx.lib那么库名就是xxx。 ","date":"2021-04-04","objectID":"/make_lib/:1:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"动态库 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic dependencies）命令检查动态库依赖关系 如何定位共享库文件呢？ 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——\u003e 环境变量LD_LIBRARY_PATH ——\u003e /etc/ld.so.cache文件列表 ——\u003e /lib/，/usr/lib 目录找到库文件后将其载入内存。 ","date":"2021-04-04","objectID":"/make_lib/:2:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"动态库的使用 程序在执行的时候是如何定位共享库文件的呢？ 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—\u003e环境变量LD_LIBRARY_PATH—\u003e/etc/ld.so.cache文件列表—\u003e/lib/,/usr/lib 目录找到库文件后将其载入内存。 如何让系统能够找到它： 如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。 如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下： 编辑/etc/ld.so.conf文件，加入库文件所在目录的路径 运行ldconfig ，该命令会重建/etc/ld.so.cache文件 ","date":"2021-04-04","objectID":"/make_lib/:2:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"静态库与动态库对比 静态库特点总结： 静态库对函数库的链接是放在编译时期完成的。 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件 动态库特点总结： 动态库把对一些库函数的链接载入推迟到程序运行的时期。 可以实现进程之间的资源共享。（因此动态库也称为共享库） 将一些程序升级变得简单。 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。 静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。 ","date":"2021-04-04","objectID":"/make_lib/:3:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"Makefile 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编 译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就 像一个 Shell 脚本一样，也可以执行操作系统的命令。 Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整 个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个 解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如 Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。 ","date":"2021-04-04","objectID":"/make_lib/:4:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"Makefile规则 一个 Makefile 文件中可以有一个或者多个规则 目标 ...: 依赖 ... 命令（Shell 命令） ... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或是目标 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进） Makefile 中的其它规则一般都是为第一条规则服务的 ","date":"2021-04-04","objectID":"/make_lib/:4:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"依赖检查与更新检测 命令在执行之前，需要先检查规则中的依赖是否存在 ，如果存在，执行命令 ，如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的， 如果找到了，则执行该规则中的命令 在执行规则中的命令时，会比较目标和依赖文件的时间 。如果依赖的时间比目标的时间晚，需要重新生成目标 ，如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 ","date":"2021-04-04","objectID":"/make_lib/:4:2","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"变量 自定义变量 变量名=变量值 var=hello 预定义变量 AR : 归档维护程序的名称，默认值为 ar CC : C 编译器的名称，默认值为 cc CXX : C++ 编译器的名称，默认值为 g++ @ : 目标的完整名称 \u003c : 第一个依赖文件的名称 ^ : 所有的依赖文件 特殊命令 $(wildcard PATTERN...) 功能：获取指定目录下指定类型的文件列表 参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔 示例： $(wildcard *.c ./sub/*.c) 返回值格式: a.c b.c c.c d.c e.c f.c $(patsubst ,,) 功能：查找中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式，如果匹配的话，则以替换。 可以包括通配符%，表示任意长度的字串。如果 中也包含%，那么，中的这个%将是中的那个% 所代表的字串。(可以用\\来转义，以\\%来表示真实含义的%字符) 返回：函数返回被替换过后的字符串 示例：$(patsubst %.c, %.o, x.c bar.c) 返回值格式: x.o bar.o ","date":"2021-04-04","objectID":"/make_lib/:4:3","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"简单示例 #定义变量 src=sub.o add.o mult.o div.o main.o target=app $(target):$(src) $(CC) $(src) -o $(target) %.o:%.c $(CC) -c $\u003c -o $@ ","date":"2021-04-04","objectID":"/make_lib/:4:4","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Operating System"],"content":"POSIX简介 ","date":"2021-03-29","objectID":"/posix/:1:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1. 概念 POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ） ","date":"2021-03-29","objectID":"/posix/:1:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.发布者-IEEE 发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。 IEEE，总部位于美国纽约，是一个国际性的电子技术与信息科学工程师的协会，也是目前全球最大的非营利性专业技术学会。IEEE致力于电气、电子、计算机工程和与科学有关的领域的开发和研究，在太空、计算机、电信、生物医学、电力及消费性电子产品等领域已制定了1300多个行业标准，现已发展成为具有较大影响力的国际学术组织 POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。 POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。 ","date":"2021-03-29","objectID":"/posix/:1:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.POSIX标准相关文件 Single UNIX Specification V3，IEEE Std 1003.1,2004 Edition 标准线上地址： The UNIX System 注册后可以在线阅读或者下载。 IEEE和Open Group 的POSIX认证： POSIX Certified by IEEE and The Open Group 相关页面： IEEE Std 1003.1, 2004 Edition ","date":"2021-03-29","objectID":"/posix/:1:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"POSIX历史 ","date":"2021-03-29","objectID":"/posix/:2:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1.起源 POSIX是Unix的标准。 1974年，贝尔实验室正式对外发布Unix。因为涉及到反垄断等各种原因，加上早期的Unix不够完善，于是贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。 于是出现了好些独立开发的与Unix基本兼容但又不完全兼容的OS，通称Unix-like OS。 包括： 美国加州大学伯克利分校的Unix4.xBSD(Berkeley Software Distribution)。 贝尔实验室发布的自己的版本，称为System V Unix。 其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。 20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同。 局面非常混乱，麻烦也就随之而来了。 为了提高兼容性和应用程序的可移植性，阻止这种趋势， IEEE(电气和电子工程师协会)开始努力标准化Unix的开发，后来由 Richard Stallman命名为“Posix”。 这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。 ","date":"2021-03-29","objectID":"/posix/:2:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.标准覆盖 市面上绝大多数操作系统厂家都支持该标准，首先就是大名鼎鼎的Unix和Linux了，除此之外还有苹果的操作系统也是Unix-based的。有了这个规范，你就可以调用通用的API了，Linux提供的POSIX系统调用在Unix上也能执行，因此学习Linux的底层接口最好就是理解POSIX标准。Windows从WinNT开始就有兼容POSIX的考虑。这是因为当年在要求严格的领域，Unix地位比Windows高。为了把Unix用户拉到Windows阵营，被迫支持POSIX。 现在Win10对 Linux/POSIX 支持好，则是因为Linux已经统治了廉价服务器市场。为了提高Windows的竞争力搞的。所以一切都是以市场为主导。 ","date":"2021-03-29","objectID":"/posix/:2:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.支持POSIX-Linux成功的最重要一个因素 Linux之所以能够成功，有很多因素，但是支持POSIX标准无疑是它能够快速发展的最重要的一个因素。 POSIX 标准的制定最后投票敲定阶段大概是 1991~1993 年间，而此时正是Linux 刚刚起步的时候，这个 UNIX 标准为 Linux 提供了极为重要的信息，使得 Linux 能够在标准的指导下进行开发，并能够与绝大多数 UNIX 操作系统兼容。 在最初的 Linux 内核源码（0.01版、0.11版）中就已经为 Linux 系统与 POSIX 标准的兼容做好了准备工作。 在 Linux 0.01 版内核 /include/unistd.h 文件中就已经定义了几个有关 POSIX 标准要求的符号常数，而且 Linus 在注释中已写道：“OK，这也许是个玩笑，但我正在着手研究它呢”。 正是由于Linux支持POSIX标准，无数可以在unix上运行的程序都陆续的移植到Linux上，而此时unix因为版权问题，官司打的不可开交，使得Linux后来者居上。 而Linus也在《知识为了好玩》中讲述了POSIX的重要性： POSIX标准是一个可以适用于数以百计的UNIX系统调用中的任意一个的一套冗长规则， 计算机要执行任务（从读、 写、 开机和关机开始） 就需要这个标准。 POSIX则是指一个UNIX的标准体系， 或一个由来自不同公司的代表所组成的一个组织， 希望按照一个共同的标准进行运作。 对于程序员开发的在该操作系统下的新应用软件或开发应用软件的新版本而言， 标准是极其重要的。 从POSIX这样的系统调用（system call） ， 尤其是重要的调用（call） 中， 我可以获得一个操作系统应该具有哪些功能的一个单子； 然后我就可以通过自己的方式在自己的系统中实现每一个功能。 通过编写出这些标准， 我的系统软件的源代码将可以被别人使用， 以开发新的应用软件。 当时我并不知道我本可以直接从POSIX公司买到这些规则的软盘， 但这无所谓。 哪怕我能买得起， 什么东西运到芬兰， 往往会需要很长的时间。 我不愿等上那么久， 因此我四处搜求一个能从FTP地址上直接下载的版本。 没有人给我提供能找到POSI标准的来源。 于是我开始了计划B。 我从学校找到运行sun器(sun server)的sun微系统版的UNIX手册。 该手册中有一个完全可以凑合使用的系统呼叫的基本版本。 从用户手册中能看出系统呼叫的主要功能， 以及为完成这些功能所需要完成的步骤。 但是， 从中看不出具体的方法， 而只是标明了最终的结果。 于是我便着手从安德鲁·塔南鲍姆的书中和别的材料中收集一些系统呼叫。 最终有人给我寄来了那几卷厚厚的POSIX标准。 ","date":"2021-03-29","objectID":"/posix/:2:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"可移植性 聊到POSIX，那我们就不得不说说到底什么是可移植性，在讲可移植性之前，我们先来了解库函数和系统调用的区别。 Linux下对文件操作有两种方式：系统调用（system call）和库函数调用（Library functions）。 ","date":"2021-03-29","objectID":"/posix/:3:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1.系统调用 系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。 ","date":"2021-03-29","objectID":"/posix/:3:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.库函数 库函数（Library function）是把函数放到库里，供别人使用的一种方式。 方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。 库函数调用则是面向应用开发的，库函数可分为两类， 一类是C语言标准规定的库函数， 一类是编译器特定的库函数。 (由于版权原因，库函数的源代码一般是不可见的，但在头文件中你可以看到它对外的接口)。 glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的。 glibc 为程序员提供丰富的 API（Application Programming Interface），这些API都是遵循POSIX标准的，API的函数名，返回值，参数类型等都必须按照POSIX标准来定义。 POSIX兼容也就指定这些接口函数兼容，但是并不管API具体如何实现。 ","date":"2021-03-29","objectID":"/posix/:3:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.库函数API和系统调用的区别 如上图所示： (1) 库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分 (2) 库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大 (3) 系统调用依赖于平台，库函数并不依赖 系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。 库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性好。 ","date":"2021-03-29","objectID":"/posix/:3:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"4.程序的可移植性及其本质 程序在不同的机器上会生成不同的目标代码，那么目标代码和启动代码是怎么生成的呢？ 答案是编译器。 编程语言编写的程序首先要被编译器编译成目标代码（0、1代码），然后在目标代码的前面插入启动代码，最终生成了一个完整的程序。 要注意的是，程序中为访问特定设备（如显示器）或者操作系统（如windows xp 的API)的特殊功能而专门编写的部分通常是不能移植的。 综上所述，一个编程语言的可移植性取决于 不同平台编译器的数量 对特殊硬件或操作系统的依赖性 移植是基于操作系统的。但是这个时候，我们需要注意一点：基于各种操作系统平台不同，应用程序在二级制级别是不能直接移植的。 我们只能在代码层去思考可移植问题，在API层面上由于各个操作系统的命名规范、系统调用等自身原因，在API层面上实现可移植也是不大可能的。 在各个平台下，我们默认C标准库中的函数都是一样的，这样基本可以实现可移植。但是对于C库本身而言，在各种操作系统平台下其内部实现是完全不同的，也就是说C库封装了操作系统API在其内部的实现细节。 因此，C语言提供了我们在代码级的可移植性，即这种可移植是通过C语言这个中间层来完成的。 例如在我们的代码中下功夫。以下代码可以帮助我们实现各平台之间的可移植： #ifdef _WINDOWS_ CreateThread(); //windows下线程的创建 #else Pthread_create(); //Linux下线程的创建 #endif 对于头文件，也使用同样的预编译宏来实现。如： #ifndef _WINDOWS_ #include \u003cwindows.h\u003e#else #include \u003cthread.h\u003e#endif 这样就可以实现代码的可移植了。在编译的时候只要通过#define就可以选择在那个平台下完成程序的编译。 综上所述，我们都是将C，C++等各种语言当作中间层，以实现其一定程度上的可移植。如今，语言的跨平台的程序都是以这样的方式实现的。但是在不同的平台下，仍需要重新编译。 ","date":"2021-03-29","objectID":"/posix/:3:4","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"5.系统开销 使用系统调用会影响系统的性能，在执行调用时的从用户态切换到内核态，再返回用户态会有系统开销。 为了减少开销，因此需要减少系统调用的次数，并且让每次系统调用尽可能的完成多的任务。 硬件也会限制对底层系统调用一次所能写的数据块的大小。 为了给设备和文件提供更高层的接口，Linux系统提供了一系列的标准函数库。 使用标准库函数，可以高效的写任意长度的数据块，库函数在数据满足数据块长度要求时安排执行底层系统调用。 一般地，操作系统为了考虑实现的难度和管理的方便，它只提供一少部分的系统调用，这些系统调用一般都是由C和汇编混合编写实现的，其接口用C来定义，而具体的实现则是汇编，这样的好处就是执行效率高，而且，极大的方便了上层调用。 随着系统提供的这些库函数把系统调用进行封装或者组合，可以实现更多的功能，这样的库函数能够实现一些对内核来说比较复杂的操作。 比如，read()函数根据参数，直接就能读文件，而背后隐藏的比如文件在硬盘的哪个磁道，哪个扇区，加载到内存的哪个位置等等这些操作，程序员是不必关心的，这些操作里面自然也包含了系统调用。 而对于第三方的库，它其实和系统库一样，只是它直接利用系统调用的可能性要小一些，而是利用系统提供的API接口来实现功能(API的接口是开放的)。 ","date":"2021-03-29","objectID":"/posix/:3:5","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"例子 如下图是Linux系统调用的大概流程。 当应用程序调用printf()函数时，printf函数会调用C库中的printf，继而调用C库中的write，C库最后调用内核的write()。 而另一些则不会使用系统调用，比如strlen, strcat, memcpy等。 printf函数执行过程中，程序运行状态切换如下： 用户态–\u003e系统调用–\u003e内核态–\u003e返回用户态 printf函数、glibc库和系统调用在系统中关系图如下 实例代码如下： #include \u003cstdio.h\u003e int main(int argc, char **argv) { printf(\"hello world\"); return 0; } 编译执行 lwy@lwysLaptop:~/workspace$ gcc test.c -o test \u0026\u0026 strace ./test 运行程序前加上strace，可以追踪到函数库调用过程 如执行结果可知： 我们的程序虽然只有一个printf函数，但是在执行过程中，我们前后调用了execve、access、open、fstat、mmap、brk、write等系统调用。 其中write系统调用会把字符串：hello world通过设备文件1，发送到驱动，该设备节点对应终端stdout。 ","date":"2021-03-29","objectID":"/posix/:4:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["C/C++"],"content":"IFNDEF ifndef的含义是If not define, 其搭配使用如下 // xxx.h #ifndef __INCxxx.h #define __INCxxx.h #ifndef __cpluscplus extern \"C\" { #endif /*...*/ #ifndef } #endif #endif ","date":"2021-03-19","objectID":"/ifndef/:1:0","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"1.多次包含的情况 include xxx 就是将xxx的内容原地展开 假设有： a.h， 内容是 A b.h， 内容是： #include \"a.h\" B c.h， 内容是： #include \"a.h\" C 如果有一个文件x.c， 内容是： #include \"b.h\" #include \"c.h\" X b.h和c.h的内容就会被插入到X之前， 也就是这个样子： A B A C X A的内容就出现了2次。 在更复杂的环境中， A的内容还可能出现多次。 ","date":"2021-03-19","objectID":"/ifndef/:1:1","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"2.多次出现是有问题的 一般来说， 重复声明没什么问题。 所以， 如果A.h中止包含一些声明， 那重复了也没什么关系。 比如： int f(int); int f(int); int f(int); extern int i; extern int i; extern int i; struct x; struct x; struct x; 重复写N次也没关系。 但头文件中会出现一类\"定义\"， 在同一翻译单元中是不能重复的。 比如： struct x { ... }; struct x { ... }; // 重复定义 #define M ... #define M ... // 重复定义 ","date":"2021-03-19","objectID":"/ifndef/:1:2","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"3.头文件保护符 有时候必须将这些定义放在头文件中， 所以就要用头文件保护符。 另外还有一类\"定义\"， 会产生外部符号。 这类\"定义\"在一个链接过程中只能有唯一一份。 是不可以加入到头文件中的。 这种定义依然有例外…… 就是inline、模板和匿名名字空间， 就不扯远了…… 假设A的内容是： #ifndef A_H #define A_H AA #endif 如果A被展开多次，例如上面的X， 就会变成这个样子 // A_H是a.h的保护符， 必须是一个不冲突的名字。 那么，这里就不会有A_H的定义 // 然后紧接这下一行中的条件编译就会选中#ifndef 和#endif之间的部分， // 也就是#define A_H 和AA #ifndef A_H #define A_H AA #endif B // 在a.h被第一次包含后， A_H就获得定义 // 所以下一行的条件编译部分就被取消， AA就不会重复出现多次 #ifndef A_H #define A_H AA #endif C X 最终交给编译器看到的代码就是： AA B C X 只要A_H是唯一的， AA就不会重复出现。 就解决了这个问题， 一般情况就是这么用的， 是为惯例。 ","date":"2021-03-19","objectID":"/ifndef/:1:3","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"4.外部头文件保护符 上面的用法是\"内部头文件保护符\"。 a.h的保护符是使用在a.h里。 另外一种用法是\"外部头文件保护符\"， 如： ------ a.h ------ AA ------ b.h ------ #ifndef A_H #define A_H #include \"a.h\" #endif B ------ c.h ------ #ifndef A_H #define A_H #include \"a.h\" #endif C 当X同时包含b.h和c.h时， 最终效果和内部头文件保护符差不多。 两者对比， 外部的优势是可以减少打开a.h的次数。 而内部保护符可以降低a.h和b.h, c.h之间的耦合。 ","date":"2021-03-19","objectID":"/ifndef/:1:4","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"5.定义保护符 马上就要到主题了…… 将头文件保护符的用法扩展一下， 就变成了定义保护符（这个名字是我捏造的）。 保护的不是某个\"头文件\" 而是某个\"定义\"， 如： ------ a.h ------ #ifndef A_X #define A_X struct x { ... }; #endif #ifndef A_M #define A_M #define M ... #endif ... b.h和c.h直接包含a.h， 最终效果也是一样。 ","date":"2021-03-19","objectID":"/ifndef/:1:5","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"6.重复的定义保护符 到主题了…… 同样是一个捏造的词。 假设： b.h包含a.h是为了获得struct x的定义。 而c.h包含a.h是为了获得宏M的定义。 除了上面作法， 还有另一种做法： a.h和上面差不多 #ifndef X #define X struct x { ... }; #endif #ifndef M #define M ... #endif 而b.h和c.h并不包含a.h， 而是直接将需要的定义写在b.h和c.h中 ------ b.h ------ #ifndef X #define X struct x { ... }; #endif B ------ c.h ------ #ifndef M #define M ... #endif C 这样做其实耦合比外部头文件保护符还要高， 所以一般是不会采用的。 但C的标准头文件必须这样做。 因为C89有一个要求， 具体我不记得了。 要么是要求标准头文件不能包含其他标准头文件。 要么是要求标准头文件不能包含任何其他文件。 （C++和C99取消了这个要求） stdio.h是C89的标准头文件。 例如， 它需要定义一个size_t， 作为一些函数的参数类型。 而另外有一些标准头文件也会有size_t。 所以这些头文件中的size_t都是这样提供的： #ifndef _SIZE_T_DEFINED #define _SIZE_T_DEFINED typedef unsigned xxx size_t; #endif 或者也可能将若干定义分组， 共用一个保护符。 ","date":"2021-03-19","objectID":"/ifndef/:1:6","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"Pragma once 维基百科定义如下 In the the C and C++ programming languages, # pragma once is a non-standard but widely supported preprocessor directive designed to cause the current source file to be included only once in a single compilation. Thus, #pragma once serves the same purpose as include guards, but with several advantages, including: less code, avoidance of name clashes, and sometimes improvement in compilation speed. On the other hand, #pragma once is not necessarily available in all compilers and its implementation is tricky and might not always be reliable. 意思就是可以用来代替#IFNDEF的的头文件保护符的预编译指令，非标准，看编译器支持情况，目前大多都支持了。 pragma还有更多有用的指令，可以参考： #pragma编译指令大全（上） - 简书 (jianshu.com) ","date":"2021-03-19","objectID":"/ifndef/:2:0","tags":null,"title":"条件编译与保护符","uri":"/ifndef/"},{"categories":["C/C++"],"content":"初学C语言会觉得字符串处理是一件比较繁琐的事情，后来学了C++发现字符串的处理可以这么方便。但是C++又为了兼容C，导致经常有混用的情况。本文就重点介绍C++中的字符串和C风格字符串的区别。 首先，明确一点，C语言中的字符串以及相关的标准库都能完全在C++中兼容使用。所以在介绍C++中的字符串特指C++中特有的。下面介绍几个概念 ","date":"2019-08-15","objectID":"/string/:0:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"字符串字面值(string literal) 字符串字面值是一串常量字符，字符串字面值常量用双引号括起来的零个或多个字符表示，为兼容C语言，C++中所有的字符串字面值都由编译器自动在末尾添加一个空字符。 字符串没有变量名字，自身表示自身 \"Hello World!\" //simple string literal \"\" //empty string literal \"\\nCC\\toptions\\tfile.[cC]\\n\" //string literal using newlines and tabs 字符字面值： 'A' //single quote:character literal 字符串字面值： \"A\" //double quote:character string literal.包含字母A和空字符的字符串 字符串字面值可以赋值给变量，但是与字符串字面值相关联的内存空间位于只读部分，因此它是常量字符数组。 char* ptr = \"hello\"; ptr[1] = 'a';//crash! attemps to write to read-only memory. //只读 因此，当引用字符串字面值的时候使用指向const的字符数组。 const char* ptr = \"hello\"; ptr[1] = 'a';//bug! attempts to write to read-only memory. 当将字符串字面值赋值给字符数组的初始值的时候。由于字符数组存放与栈中，不允许引用其他地方的内存，因此编译器会将字符串字面值复制到栈的数组内存中。因此，可以进行相应的修改。 char stackArray[] = \"hello\"; stackArray[1] = 'a'; ","date":"2019-08-15","objectID":"/string/:1:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"C风格字符串 字符串字面值的类型实质是const char类型的数组。C++从C语言继承下来的一种通用结构是C风格字符串，而字符串字面值就是该类型的实例。C风格字符串是以空字符null结束的字符数组。 char ca1[]={'C', '+', '+'}; // no null, not C-style string char ca2[]={'C', '+', '+', '\\0'}; // explicit null char ca3[]=\"C++\"; // null terminator added automatically const char *cp=\"C++\"; // null terminator added automatically char *cp1=ca1; // points to first element of a array, but not C-style string char *cp2=ca2; // points to first element of a null-terminated char array ca1和cp1都不是C风格字符串：ca1是一个不带结束符null的字符数组，而指针cp1指向ca1，因此，它指向的并不是以null结束的数组。 C++语言通过(const) char *类型的指针来操纵C风格字符串。 C 风格字符串在C语言中有C标准库函数来处理：string.h C 语言中也有对字符进行处理的标准库函数: ctype.h 这些库函数在C++中都有对应的版本，只需要去掉.h前面加上c就行了，这样也能在C++区分出这是C风格的函数 即cstring和cctype C风格字符串中带来困恼的原因是字符数组总要以空字符结尾，这给计算数组空间带来不便，也容易引发安全问题，处理字符串的相关复制，移动情形时，调用者必须保证目标字符串有足够的大小。 另一个苦恼是C风格的字符串的复制，截取等相关操作不能像对待基础数据类型一样方便，这些情况在C++风格的字符串中由重载运算符实现，方便了用户。 所以一般C++不推荐使用C风格字符串，即使要使用，也尽量在C标准库中使用诸如strn前缀的函数处理，以降低风险。 ","date":"2019-08-15","objectID":"/string/:2:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"C++风格字符串 C++使用标准库类型string表示可变长的字符序列，标准库中的名称符号都包含在命名空间呢std中。 在初始化string对象时可以使用多种方式比如： string s1; // 默认初始化，s1是一个空字符串 string s2 = s1; // s2是s1的副本 string s3 = \"hiya\"; // s3是该字符串字面值的副本 string s4(10, 'c'); // s4的内容是cccccccccc string对象可以用标准库中的流直接读写 比如cin，但是读时从非空白开始，即忽略开头的空白，遇到下一处空白结束。 当要读取一整行的时候可以使用getline(cin,line) ，(line是读取后存放的string对象)该函数从给定的输入流中读取内容，直到遇到换行符为止，换行符也被读取进来，然后把读取的内容存放到line中，不包含换行符。 string对象可以使用== 、\u003c、\u003e、\u003e=等比较符号，这个很好理解，不多说。 另外值得注意的是，string对象之间可以相加，字符串字面值和string对象也可以相加，但是字符串字面值之间不能相加！ 最后谈一下C风格的字符串和C++风格字符串怎么转换 C风格字符串转换到C++的string对象很简单，可以将C风格字符串(包括字面值)作为string初始化的参数即可，或者可以用=号。 更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 即允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 string对象转换为C风格字符串则有一个方法c_str() ,直接调用即可。 string s = \"msl\"; string s1(\"dad\"); const char* p = \"dsjka\"; char p1[] = \"das\"; string w = s + \"da\"; string q = s + p; string t = s + p1; string u = p + p1; // wrong string k = p + \"daas\"; // wrong 如上面代码所示，最后两个有错，其余都是允许的。 ","date":"2019-08-15","objectID":"/string/:3:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"字符串与整型的互相转换 先说string对象与int型转换 int转换为string对象有全局函数std::to_string()(C++11)。 当然还可以用其他的stringstream的方式。 string转为int可以利用标准库中的atoi()函数（ ascii to integer），但要先转为C风格串，从C标准库继承过来，举例 std::string str = \"123\"; int n = atoi(str.c_str()); // 先转为C风格 cout\u003c\u003cn; //123 同时除了atoi()还要atof()等一系列函数。 另外用一些C语言中的格式化输入输出函数也可以实现,比如sprintf,sscanf等。 string s1 = \"1234\"; int a = atoi(s1.c_str()); string s2 = to_string(a); ","date":"2019-08-15","objectID":"/string/:4:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"常量const通俗理解 首先先讲一讲常量，为什么要使用常量，因为不变的值更易于理解、跟踪和分析，所以应该尽可能地使用常量代替变量。 C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点： const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 所以本文就针对const 修饰的常量以及其他的类型进行探讨。 在C++的学习过程中，不管是初学者，还是略有了解的人，对const关键字的理解总是或多或少遇到一些问题。本文不妨采用一种通俗的理解方式，另辟蹊径来和大家分享一下理解思路。 先说说技巧，怎么区分const修饰的是什么： 理解的时候，在定义或声明中跳过或者忽略掉数据类型（int，char，double等），const后面的内容即为修饰的内容。 比如： 普通类型： const int p;//忽略int，即 const后面是p，修饰的即为p int const p;//同样的分析方法，这句跟上面的分析一致 指针类型： const int *p1; //去掉int，const修饰的是 * int const *p2; //去掉int，const修饰的是 *，等同于上面一句 int* const p3; //去掉int，const修饰的是p3，区别于上面那种情况 const int* const p4; //去掉int，const即修饰*，又修饰p4，区别上面两种情况 当然还有其他的类型等，放到后面再说。 ","date":"2019-08-03","objectID":"/understand_const/:1:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"const修饰的普通变量 变量名的本质：一段连续内存空间的别名。 比如： 定义了 ：int p = 10； 则系统会分配4个字节的内存，这块内存我们命名为p,其地址是不确定的，这里我们假定是0x2222，于是在p生存的周期内，这块从0x2222开始的地址的内存空间就被命名为p，p = 10 即向这块内存内写入10。 对于普通变量，const修饰时，仅仅改变的是变量的属性，即将原来变量的可读写性变成了只读性。 可以这么理解：普通变量加const修饰是为了防止变量被修改。 但有个例外：如果该变量为全局变量，则不能通过指针修改，但如果是局部变量，则还是可以通过指针修改的。 原因是：全局变量在全局静态区，内容不能被修改，但局部变量本身仍在栈区，可以使用指针修改。 const int a = 10; //const修饰全局变量必须初始化 void fun(){ const int b; //const修饰局部变量可以不初始化 int *p = \u0026b; //可以利用指针指向b对应的内存块，对该内存块修改 *p = 20; printf(\"%d , %d\",*p,b); //结果为 20 ，20 p = \u0026a; //可以利用指针指向a对应的内存块 *p = 20; //（此句运行出错）但不可以通过指针修改全局变量的内容 a = 20; //（此句运行出错）因为a为全局常量，不能修改 } 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同的文件中分别定义了独立的变量。所以如果想要在多个文件中共享const对象，则对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了。 ","date":"2019-08-03","objectID":"/understand_const/:2:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"const 与指针 利用最前面分析的方法，可以知道const修饰指针变量有三种情况： ①const修饰 * 号 ②const修饰变量 ③const既修饰 * 号又修饰变量 只要掌握了前两种情况，最后第三种自然明了。 先说说const修饰 * 号，该情况为（局部变量）： const int *p_a;//与int const *p_a;等价 int a = 10; int b = 20; p_a = \u0026a; *p_a = 20; //错误 a =20; //正确 p_a = \u0026b; //正确 当const修饰*号时，表示不能通过指针p_a修改p_a指向的内容。这句话有3层意思（对应上述代码三种情况）： ①当p_a指向a时,不能通过指针p_a取*号修改a中的内容 ②a中的内容仍可以由a自身修改 ③p_a指向可以改变，即p_a可以指向b 可以这么记忆：* 号是指针用来对指向的内存操作（读写）的，当对 * 加了`修饰，意味着 * 号的操作只剩下只读的功能，也就是只能使用 *号来读取指针指向的内容，而失去了写的特性，这点与普通变量的情况类似。 再说说const修饰变量的情况: void fun(){ int a = 10; int b = 20; int* const p_a = \u0026a; *p_a = 20; //正确 a = 30; //正确 p_a = \u0026b; //错误 } 当const修饰变量p_a时，表示不能改变p_a的内容，即改不了指针的指向。这句话有3层意思（对应上述代码三种情况）： ①当p_a指向a时,能通过指针p_a取*号修改a中的内容 ②a中的内容仍可以由a自身修改 ③p_a指向不可以改变，即p_a不可以修改，指向b或者其他变量 最好的理解便是：指针变量也是变量，变量名的本质：一段连续内存空间的别名。理解好了这句，也就明白了，const修饰了这个变量，也就是修饰了这块内存空间，使得这块内存空间的可读写性改为了可读性，也就是指针指向固定，无法更改。 看到这里，如果前面的都了解了，那么你就会明白了用const修饰，实际上就是将对应的可读写改成了只读性质。 那么，最后一种情况就是，const既修饰 * 号，又修饰变量的情况了： void fun(){ int a = 10; int b = 20; const int* const p = \u0026a; //必须初始化 *p = 20; //错误 p = \u0026b; //错误 a = 20; //正确 } 如果明白了前两种情况，那么最后这种情况就好理解了（对应上述代码三种情况） ①const修饰*号限定了指针对内存的操作只能为只读 ②const修饰变量p限定了指针的指向，p不能指向其他变量 ③a或b本身的变量可以自身修改。 至于为什么必须初始化，如果理解了上述内容，那也就明白了（因为只读）。并且在初始化的过程中，利用一个对象去初始化另一个对象，则它们是不是const都无关紧要，因为拷贝一个对象的值并不会改变它。说下不初始化的情况，编译器（我用的VS2017）仍能通过，但有警告，p没有明确初始化，并不知道其指向哪里，由于该变量既不能修改指向，又不能修改指向的内容，所以此时该指针也就没有作用了，这种做法是不好的。 ","date":"2019-08-03","objectID":"/understand_const/:3:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"const 与引用类型 可以把引用绑定到const对象上，就像绑定到其他对象身上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象： const int ci = 1024; const int \u0026r1 = ci; //正确, 引用及其对应的对象都是常量 r1 = 42; // 错误，r1 是对常量的引用 int \u0026r2 = ci; // 错误，试图让一个非常量引用指向一个常量对象 因为不允许直接为ci 赋值，当然也不可以通过引用去改变ci，因此对r2的初始化是错误的，假设该初始化合法， 就可以通过r2来改变其引用的值，这显然不正确。 “常量引用”是“对const的引用“，严格来说，并不存在常量引用，因为引用不是一个对象，我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上来看所有的引用又都算常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。 引用的类型必须与其所引用的对象保持一致，但是有两个例外：第一个是初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个表达式。 对于以下代码： double dval = 3.14; const int \u0026ri = dval; 此处ri引用了一个Int型的数，对ri的操作应该是整数运算，但dval是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器将代码变成了以下形式： const int temp = dval; // 由双精度浮点数生成一个临时的整型常量 const int \u0026ri = temp; // 让ri绑定这个临时量 这种情况下，ri绑定了一个临时量对象，所谓的临时量对象就是编译器需要一个空间来暂存表达式的求值结果临时创建的一个未命名的对象。 对const的引用可能引用一个并非const 的对象 必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。 ","date":"2019-08-03","objectID":"/understand_const/:4:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"指针、常量和类型别名 针对上述的情况，特别举一例子作为讲解 先看下面的代码 typedef char* VP; const char *data[3] = {\"I\",\"Love\",\"u\"}; // (1) const VP data1[3] = {\"I\",\"Love\",\"u\"}; // (2) data[1] = \"hate\"; //能正常修改 data1[1] = \"hate\"; //编译器报错，提示data1[1]是无法修改的左值 根据编译器报错的提示信息，你可能猜到了在(2)式中的指针变为了常量指针，而(1)没有改变。那为什么会造成这种情况呢，这得从编译器的角度来说明变量的申明顺序问题。 首先，先针对声明语句进行剖析一下。 (a) c和c++中声明包含零个或者多个声明说明符，和一个声明符 例如： static unsigned long int *x[N]; static unsigned long int // 声明说明符 *x[N] // 声明符 一个声明符就是被声明的名称，可能还伴有操作符，如*,(),[],\u0026等，以本例为例，*表示x是一个指针，[]表示序列， *x[N]表明x是含有N个指针的序列。 可能基础比较弱的人一直分不清楚指针数组和数组指针，以及返回指针的函数和函数指针怎么写。其实与运算符一样，操作符也是有优先级的，在本例中[]的优先级要比*的优先级高，所以首先其是一个序列，然后才声明序列中的元素是指针。而(*x)[N]中()的优先级比[]的优先级高，所以首先确定了其是一个指针。 (b) 声明说明符包含类型说明符和与类型无关的说明符，分清楚这个对于理解例子中的两个例子为什么会出现不同的情况至关重要。注意在(1)式中char是类型说明符，而const是与类型无关的说明符，所以1)式中const并不会修饰变量data，应该理解为指向const char的指针序列，而不是指向char的const指针序列。。 (c) 声明说明符在一个声明中出现的顺序并不重要，如： const void *data[N]; void const *data[N]; 这两者实际上是等价的，但是要注意对于指针的声明是从右到左来看的，所以对于在对指针的声明说明符中，正确的写法应该将const放在类型说明符的右边。如： T const *p // const 在T后面， 指向常量的指针 T* const p // const 在T后面，常量指针 上面的式子中表示指向const T的指针，而下面的式子修饰了操作符*则表示指向T类型的const指针，说以对于最开始的问题中的(2)按照正确的写法应该是： VP const data1[3] = {\"I\",\"Love\",\"u\"}； 展开: char* const data1[3] = {\"I\",\"Love\",\"u\"}； 这样对照刚刚的讲解，现在是不是就能理解为什么data1序列中的指针为const类型了。 ","date":"2019-08-03","objectID":"/understand_const/:5:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"constexpr constexpr 是 C++11 引入的，一方面是为了引入更多的编译时计算能力，另一方面也是解决 C++98 的 const 的双重语义问题。 在 C 里面，const 很明确只有 「只读」 一个语义，不会混淆。C++ 在此基础上增加了 「常量」 语义，也由 const 关键字来承担，引出来一些奇怪的问题。C++11 把 「常量」 语义拆出来，交给新引入的 constexpr 关键字。 看如下代码： template\u003cint N\u003e class C{}; constexpr int FivePlus(int x) { return 5 + x; } void f(const int x) { C\u003cx\u003e c1; // Error: x is not compile-time evaluable. C\u003cFivePlus(6)\u003e c2; // OK } void g() { const int x = 5; C\u003cx\u003e c1; // OK!!! 此处用x的「常量」语义 *(int *)(\u0026x) = 6; // Still OK! 只处用x的「只读」语义，去除const后便可写了; (int*)是强制类型转换，有些编译器可能会报错 // 如果上一句报错，就可以写成下面这一句： // *const_cast\u003cint*\u003e(\u0026x) = 6; C\u003cx\u003e c2; // Still OK! c2是C\u003c5\u003e类型（不是C\u003c6\u003e！） C\u003cFivePlus(x)\u003e c3; // Still OK! c3是C\u003c10\u003e类型（不是C\u003c11\u003e！） printf(\"%d\\n\", x); // 此处绝大多数（所有？）C++编译器会输出5！！ // （然而，如果用一个C编译器来编译类似代码，一定输出6） const int* p = \u0026x; printf(\"%d\\n\", *p); // 此处，大多数C++编译器输出6 } 可以看到，f 和 g 都有一个 const int x，但它们的行为却不同。原因在于：f 的 const int x 只是「一个只读的变量」；而 g 的 const int x 既是「一个只读的变量」，又是「一个值为5的常量」，变得飘忽不定。 在 C++11 以后，建议凡是 「常量」 语义的场景都使用 constexpr，只对 「只读」 语义使用 const。 可能有人就会糊涂了，只读变量 难道不就是 常量吗？然则非也。 同样一个内存地址，用常量指针关联时，通过这一路径就无法修改；换用非常量指针 关联时，在这条路径上就是可以修改的。 换句话说，用 const 限定变量时，只是剥夺了通过该变量修改相应内存中内容的可能性，但是有可能其他程序或其他指向该内存地址的变量会改变这块内存中的内容，也就是说这块内存地址空间的内容并不会保证一直不变。所以，从现在开始，就把const理解成只读的限定符，把constexpr理解成常量的限定符 ","date":"2019-08-03","objectID":"/understand_const/:6:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"参考文献 https://blog.csdn.net/rlyhaha/article/details/80397227 https://blog.csdn.net/JayFan_Ma/article/details/82942903 https://blog.csdn.net/qq_40416052/article/details/82655736 https://blog.csdn.net/qq_40399012/article/details/84069983 https://blog.csdn.net/love_gaohz/article/details/7567856 (43条消息) C++ const 和 constexpr 的区别？_Sunny_Jie的博客-CSDN博客_const与constexpr的区别 ","date":"2019-08-03","objectID":"/understand_const/:7:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"声明与定义关系 为了允许把程序拆分为多个逻辑部分来写，C++文件允许分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。 如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是std::cout 和std::cin，它们定义于标准库，却能被我们写的程序使用。 为了支持分离式编译，C++将声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(definition)负责创建与名字关联的实体。 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还是申请存储空间，也可能会为变量赋一个初始值。 如果想要单纯声明一个变量，就在变量名前加关键字extern，而不要显式地初始化变量： 所以，下面的是声明: extern int a; 下面的是定义 int a; //声明并定义a int a = 0; // 声明并定义初始化a extern int a = 0;//// 声明并定义初始化a 在函数体内部，如果试图初始化一个extern关键字标记的变量，将引发错误。总结一下就是： 根据C++标准的规定，一个变量是声明，必须同时满足两个条件，否则就是定义： ① 声明必须使用extern关键字 ② 不能给变量赋初值 函数或变量在声明时，并没有给它实际的物理内存空间，它有时候可保证你的程序编译通过； 函数或变量在定义时，它就在内存中有了实际的物理空间。 如果你在编译单元中引用的外部变量没有在整个工程中任何一个地方定义的话，那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量。 函数或变量可以声明多次，但定义只能有一次。 ","date":"2019-08-01","objectID":"/variable/:1:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"编译单元 在VC或VS上编写完代码，点击编译按钮准备生成exe文件时，编译器做了两步工作： 第一步，将每个.cpp(.c)和相应的.h文件编译成obj文件； 第二步，将工程中所有的obj文件进行LINK，生成最终.exe文件。 那么，错误可能在两个地方产生： 一个，编译时的错误，这个主要是语法错误； 一个，链接时的错误，主要是重复定义变量等。 编译单元指在编译阶段生成的每个obj文件。 一个obj文件就是一个编译单元。 一个.cpp(.c)和它相应的.h文件共同组成了一个编译单元。 一个工程由很多编译单元组成，每个obj文件里包含了变量存储的相对地址等。 ","date":"2019-08-01","objectID":"/variable/:2:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"全局变量(extern) 在函数体外定义的变量，默认是全局变量。 针对上文提到的一个文件的代码可能需要使用另一个文件中定义的变量情况，推荐的做法是在头文件中声明，对应的源文件中定义的做法。因为声明可以多次，定义只能一次，这样头文件被其他许多文件包含时候，不会出现重复定义的错误。如果将全局变量的声明和定义放在一个头文件中，将不能使用头文件的方式在多个文件文件中共享变量，即使在头文件中加#pragma once，或#ifndef也会出现重复定义，因为每个编译单元是单独的，都会对它各自进行定义。这样的情况下，只能使用extern修饰的声明在其他文件中引用该变量。 举个例子： // 1.h 头文件 extern int a; //声明一个全局变量 // 1.cpp 源文件 int a; // 定义该变量，但没有初始化 // 2.cpp 源文件 #include\u003ciostream\u003e#include\"1.h\" // 以包含源文件形式引用变量using namespace std; //a = 1; //在全局中,语句的执行顺序是没有保证的,所以全局变量不能再函数体外赋值 extern void nm(); int main() { a = 2; nm(); cout \u003c\u003c ++a \u003c\u003c endl; return 0; } // 3.cpp 源文件 #include\u003ciostream\u003eusing namespace std; extern int a; // 以extern修饰形式引用变量 void nm() { cout \u003c\u003c a; } 上述程序结果输出为： 23 2.cpp采用包含头文件的形式引用全局变量，3.cpp采用extern 修饰的声明引用。两者都能正确共享变量。但是，如果在1.h中将声明改成定义，就不能使用头文件引用的形式了。 总之变量的使用前必须有声明，有定义。 另外，有一个问题是，在函数体之外，全局变量不能被赋值，因为函数体之外，代码块的执行顺序没有固定要求，视编译器而定，所以如果允许赋值的话，可能会造成先调用后赋值的情况，所以被禁止。 在上述例子中，2.cpp中引用1.h头文件，并且使用extern修饰的声明语句引用函数nm，在main函数体内，对变量a进行赋值，该变量在1.h中声明，1.cpp中定义，由于包含了1.h，所以2.cpp可以引用它。接着调用nm函数，nm函数来自3.cpp，功能是直接输出a,在3.cpp中是用extern关键字引用的该变量。在调用该函数之前，已经对a赋值过了，所以能够正确输出。实际上，在我的PC上用VS运行，假如在赋值之前调用nm，输出是：03，因为编译器给a默认初始化为0了吧。 ","date":"2019-08-01","objectID":"/variable/:3:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"静态全局变量(static) 注意使用static修饰变量，就不能使用extern来修饰，即static和extern不可同时出现。 static修饰的全局变量的声明与定义同时进行，即当你在头文件中使用static声明了全局变量，同时它也被定义了。 static修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其值复制给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并不影响本身在定义时的值。即在其他编译单元A使用它时，它所在的物理地址，和其他编译单元B使用它时，它所在的物理地址不一样，A和B对它所做的修改都不能传递给对方。 多个地方引用静态全局变量所在的头文件，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储。 ","date":"2019-08-01","objectID":"/variable/:4:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"全局常量(const) const单独使用时，其特性与static一样（每个编译单元中地址都不一样，不过因为是常量，也不能修改，所以就没有多大关系）。 const与extern一起使用时，其特性与extern一样。 extern const char g_szBuffer[]; //写入 .h中 const char g_szBuffer[] = \"123456\"; // 写入.cpp中 ","date":"2019-08-01","objectID":"/variable/:5:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["Math"],"content":"假设检验（Hypothesis testing）是推论统计中用于检验统计假设的一种方法。而“统计假设”是可通过观察一组随机变量的模型进行检验的科学假说。一旦能估计未知参数，就会希望根据结果对未知的真正参数值做出适当的推论。 统计上对参数的假设，就是对一个或多个参数的论述。而其中欲检验其正确性的为零假设，零假设通常由研究者决定，反映研究者对未知参数的看法。相对于零假设的其他有关参数之论述是备择假设（Alternative hypothesis，记为或），它通常反应了执行检验的研究者对参数可能数值的另一种（对立的）看法（换句话说，备择假设通常才是研究者最想知道的）。 假设检验的种类包括：t检验，Z检验，卡方检验，F检验等等。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:0:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"假设检验步骤 最初研究假设为真相不明。 提出相关的零假设和备择假设。 考虑检验中对样本做出的统计假设；例如，关于总体资料的分布形式或关于独立性的假设。无效的假设将意味此检验的结果是无效的。 选择一个显著性水平 (α)，若低于这个概率阈值，就会拒绝零假设。最常用的是 5% 和 1%。 选择适合的检验统计量(Test statistic)T。 在设定零假设为真下推导检验统计量的分布。在标准情况下应该会得出一个熟知的结果。比如检验统计量可能会符合正态分布或学生t-分布。 根据在零假设成立时的检验统计量T分布，找到概率为显著性水平 (α)的区域，此区域称为“拒绝域”(记作RR或CR)，即在零假设成立的前提下，落在拒绝域的概率只有α。 针对检验统计量T，根据样本计算其估计值tobs。 若估计值tobs未落在拒绝域，则“不拒绝”零假设（do no reject ）。若估计值tobs落在拒绝域，则拒绝零假设，接受备择假设。 要注意的是一般不会将检验结果称作“接受”零假设，而是因没有显著证据证明零假设为非，所以“不拒绝”零假设。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:1:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"相关概念 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"原假设 也称为零假设（Null Hypothesis），即为你要对其进行检验的断言，除非有足够的证据进行反驳，否则你将接受这个断言。用符号$H_0$表示 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:1","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"备择假设 与原假设对立的断言称为备择假设（Alternative hypothesis），用$H_1$ 表示，如果有足够的证据拒绝$H_0$ ，我们就接受$H_1$ 二者不必涵盖所有可能结果 进行假设检验时，你假定原假设为真；如果有足够证据反驳原假设，则拒绝原假设，接受备择假设 我们根据原假设$H_0$ 选择检验统计量 我们需要检验是否有充足的证据反驳原假设。办法是：首先假设$H_0​$ 为真，然后寻找不利于$H_0​$ 的证据。先看看得出原假设观察结果的可能性多大。也就是说，取样本结果，然后计算发生这个结果的概率——通过求拒绝域实现这个目标 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:2","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"拒绝域 假设检验的拒绝域是一组数值，这组数值给出反驳原假设的最极端证据 问题是：当这些证据的强度达到多大时，我们能够坚决地拒绝原假设？我们需要通过某种方法指出何时能够合理地拒绝原假设——指定一个拒绝域即可实现这一目的 临界值（“c”）：我们把拒绝域的分界点称为临界值 为了求出假设检验的拒绝域，首先需要定下“显著性水平”。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:3","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"显著性水平($\\alpha$) 检验的显著性水平所量度的是一种愿望，即希望在样本结果的不可能程度达到多大时，就拒绝原假设$H_0$ ,像置信区间的置信水平一样，显著性水平用百分数表示 显著性水平常用希腊字母 $\\alpha$ 表示，$\\alpha$ 越小，为了拒绝 $H_0$ ，样本结果需要达到的不可能程度越高 单尾检验：即检验的拒绝域落在数据集的一侧，如果备择假设包括一个\u003c符号，则使用左尾，此时拒绝域位于数据的的极端，\u003e符号则相反 双尾检验：即拒绝域一分为二位于数据集的两侧，你选择检验水平 $\\alpha$ ,然后将拒绝域一分为二，并确保整个拒绝域以相应的概率反映这个检验水平。两侧各占 $\\alpha/2$ ,因此总和为$\\alpha$ ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:4","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"$p$ 值 即某个小于或者等于拒绝域方向上的一个样本数值的概率。具体求法是利用样本进行计算，然后判定样本结果是否落在假设检验的拒绝域以内，也就说我们通过 $p$ 值确定是否拒绝原假设，$p$ 值小于显著性水平 $\\alpha$，拒绝原假设。 已经求得P值的情况下，可以用它来检查我们的样本是否落在拒绝域内。以显著性水平5%的左尾检验为例，这意味着，如果 $p$ 值小于0.05，就能拒绝零假设。 检验统计量：检验统计量就是用于进行检验的变量 一旦确定了检验的显著性水平，就无法改变 第一类错误: 错误地拒绝原假设 第二类错误：错误地接收原假设 发生第一类错误的概率等于你的结果位于拒绝域以内的概率。由于拒绝域由检验水平决定，说明如果检验的显著性水平为$\\alpha$ ， 则发生第一类错误的概率必须也等于$\\alpha$ ，即： $$ P(第一类错误)=\\alpha $$ 其中 $\\alpha$ 为检验的显著性水平 发生第二类错误的概率要比求第一类错误的概率难得多，其通常用希腊字母$\\beta$ 表示， $$ P(第二类错误)=\\beta $$ 求解步骤如下： 检查是否拥有 $H_1$ 的特定数值 没有这个数值则无法计算第二类错误概率 求检验拒绝域以外的数值范围 假设检验统计量已经标准化，则该数值范围要进行逆标准化 假定 $H_1$ 为真，求得到这些数值的概率 也就是说，我们要求出得到拒绝域以外的数值的概率，但这一次用 $H_1$ 而不是 $H_0$ 对检验统计量进行描述 只有在备择假设具有唯一特定值时才能计算第二类错误的发生概率 假设检验的功效即你正确地拒绝一个假原假设的概率 $$ 功效=1-\\beta $$ 方差已知情况下求均值是Z检验。 方差未知求均值是 $t$ 检验（样本标准差 $s$ 代替总体标准差 $\\sigma$，由样本平均数推断总体平均数） 均值方差都未知求方差是 $\\chi^2$检验 两个正态分布样本的均值方差都未知情况下求两个总体的方差比值是 $F$ 检验。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:5","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"Z检验 ","date":"2019-05-14","objectID":"/hypothesis_testing/:3:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"Z检验量(Z-statistic) $$ Z=\\frac{\\overline{X}-\\mu_{\\overline{x}}}{\\sigma/\\sqrt{n}}=\\frac{\\overline{X}-\\mu_{\\overline{x}}}{s/\\sqrt{n}} $$ 当 $n$ 大于等于30时，其分布接近正态分布，否则其分布为 $t $ 分布，因为当样本容量较大时，我们可以通过样本标准差来估计总体标准差，这样相当于总体方差已知。而样本容量较小时，我们不能通过样本来估计总体方差，这时相当于总体方差未知，属于 $t $ 分布 ","date":"2019-05-14","objectID":"/hypothesis_testing/:3:1","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"实例 制药公司宣称他们的新药能够在两周内治愈90%的打鼾患者，外科诊所医生决定对药物进行试验，验证制药公司的说法是否可信，他随机抽取了100名患者，用该药进行了两周的治疗后，有80个人被治愈。现在要通过这个样本来对制药公司的断言进行 $Z$ -检验 确定假设 $H_0:p=0.9, H_1:p\u003c0.9 $ 即原假设为治愈率为90%,备择假设为治愈率小于90% 选择检验统计量 原分布为二项分布，当样本容量较大时，可以用正态分布近似代替二项分布，此时有$X\\sim{N(np,npq)}$ 例子中有 $X\\sim{N(90,9)}$ 经过标准化得到，$Z=\\frac{X-90}{\\sqrt9}=\\frac{X-90}{3}​$ 也就是说，我们的统计量可以是$Z=\\frac{X-90}{3} ,Z\\sim{N(0,1)}$ ,我们将$Z$作为统计量是因为通过它可以轻松查出概率，进而了解在以制药公司断言为前提下，我们的样本结果的不可能程度如何。我们将80代入$X$，这样就能求出治愈人数为80或以下的概率 求出拒绝域 有了检验统计量后我们还要求拒绝域。由于我们的备择假设为 $p\u003c0.9$ ，这表明拒绝域位于左尾，拒绝域还取决与显著性水平，这里取显著性水平为5% 由于$Z$ 统计量符合标准正态分布，于是可以用概率表查出临界值 $c$。 由于我们的显著性水平为5%,于是临界值 $c$ 等于令 $P(Z\u003cc)=0.05$ 的数值，通过概率表可以查到该值为-1.64 这说明只要检验统计量小于-1.64，我们就有足够的证据拒绝原假设 求出p值 拒绝域位于分布的左尾，治愈人数为80，那么80对应的Z 值为(80-90)/3=-3.33 $p$ 值算法为 $P(Z\u003cz)=P(Z\u003c-3.33)$ 查看检验统计量是否位于拒绝域内 如果 $p​$ 值小于0.05(显著性水平)，则检验统计量位于拒绝域中，此例中，检验统计量为0.0004，明显位于拒绝域中 做出决策 拒绝原假设 ","date":"2019-05-14","objectID":"/hypothesis_testing/:3:2","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"t检验 T检验是用于两个样本（或样本与群体）平均值差异程度的检验方法。它是用T分布理论来推断差异发生的概率，从而判定两个平均数的差异是否显著。 T检验的适用条件为样本分布符合正态分布。 T检验的应用条件： 当样本例数较小时，要求样本取自正态总体； 做两样本均数比较时，还要求两样本的总体方差相 等。 T检验的用途：（1）样本均数与群体均数的比较；（2）两样本均数的比较。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:4:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"t检验例子 样本与总体均值的比较 大量检测已知正常人血浆载脂蛋白 $E(apo E)$ 总体平均水平为 $4.15mmol/L$。某医师经抽样测得41例陈旧性心机梗死患者的血浆载脂蛋白E平均浓度为 $5.22mmol/L$，标准差为$1.61mmol/L$。据此能否认为陈旧性心肌梗死患者的血浆载脂蛋白$E$平均浓度与正常人的平均浓度不一致？ 建立检验假设和确定检验水准。 ​ $H_0: \\mu=\\mu_0,H1: \\mu≠\\mu_0,\\alpha=0.05$​，双侧检验； 选定检验方法和计算统计量。用单样本的t检验， $$ t=\\frac{\\overline{x}-\\mu_0}{s_{\\overline{x}}}=\\frac{\\overline{x}-\\mu_0}{s/\\sqrt{n}}=\\frac{5.22-4.15}{1.61/\\sqrt{41}}=4.26 $$ ​ 自由度 $v=41-1=40$ 确定P值和作出推断结论。 查 $t$ 分布表，$ t_{0.05/2,40}=2.021$, $ t=4.26\u003et_{0.05/2, 40}$,$P\u003c0.05$​。按 $\\alpha=0.05​ $水准，拒绝 $H_0$​，接受 $H_1$​，可认为陈旧性心肌梗死患者的血浆载脂蛋白$E$平均浓度与正常人的差别有统计学意义，结合专业可以认为前者平均浓度较高。 配对设计定量资料的 $t$ 检验 • 配对设计的 $t$ 检验研究的是差值均数（样本均数）与理论上的差值总体均数的比较。 • 首先计算出各对差值 $d$ 的均数。当两种处理结果无差别或某种处理不起作用时，理论上差值d的总体均数 $μ_d=0$ • 可将配对设计资料的假设检验视为样本均数与总体均数 $μ_d =0$ 的比较，据定理： $$ t=\\frac{\\overline{d}-\\mu_d}{s_{\\overline{d}}}=\\frac{\\overline{d}-0}{s_d/\\sqrt{n}}=\\frac{\\overline{d}}{s_d/\\sqrt{n}}\\sim{t(n-1)} $$ 将大白鼠配成8对，每对分别饲以正常饲料和缺乏维生素E饲料，测得两组大白鼠肝中维生素A的含量，试比较两组大白鼠中维生素A的含量有无差别。 大白鼠配对号 正常饲料组 维生素E缺乏组 差数d 1 3550 2450 1100 2 2000 2400 -400 3 3000 1800 1200 4 3950 3200 750 5 3800 3250 550 6 3750 2700 1050 7 3450 2500 950 8 3050 1750 1300 Mean 3318.75 2506.25 812.5 建立检验假设和确定检验水准 $H_0: \\mu_d =0,H1: \\mu_d ≠0,\\alpha=0.05$，双侧检验； 选定检验方法和计算统计量 $$ \\overline{d}=\\frac{\\sum d}{n}=\\frac{6500}{8}=812.5(U/g) $$ $$ S_{\\overline{d}}=\\frac{S_d}{\\sqrt{n}}=\\sqrt{\\frac{7370000-(6500)^2/8}{8\\times(8-1)}}=193.1298(U/g) $$ $$ t=\\frac{\\overline{d}-\\mu_d}{S_d-\\sqrt{n}}=\\frac{812.5-0}{193.1298}=4.2070, v=8-1-=7 $$ 确定p值和作出推断结论 查t分布表（双侧），$ t=4.2\u003et _{0.05/2, 7} =2.365,p\u003c0.05$。按$ \\alpha＝ 0.05$水准，拒绝$H_0$ ，接受 $H_1$ ,可以认为两种饲料喂养的两组大白鼠中维生素A的含量有差别。正常饲料组比缺乏维生素Ｅ饲料组的含量要高。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:4:1","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"参考 https://www.jianshu.com/p/46d9b111dffc ","date":"2019-05-14","objectID":"/hypothesis_testing/:5:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":null,"content":"欢迎来到我的小站呀，很高兴遇见你！🤝 ","date":"2018-04-24","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"🏡 关于本站  本博客主要记录一些学习生活，和一些个人觉得值得记录的问题及其解决办法。如果本博客能有哪些内容帮助到了你，那也是极好的。 ","date":"2018-04-24","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"👨‍💻 博主是谁  平平常常的人，做着平平常常的事～～ ","date":"2018-04-24","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"🏹 兴趣爱好  🏸🎵📽️ ","date":"2018-04-24","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"📬 邮箱联系👈 ","date":"2018-04-24","objectID":"/about/:0:4","tags":null,"title":"关于","uri":"/about/"}]