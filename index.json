[{"categories":["Algorithm"],"content":"前序遍历 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。 ","date":"2022-04-23","objectID":"/binary_tree/:1:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法 实际上迭代解法分两种形式： 形式一：模拟栈 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (!root) return ans; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); ans.emplace_back(node-\u003eval); // 注意模拟栈时，首先出栈的要先入栈 if (node-\u003eright) st.push(node-\u003eright); if (node-\u003eleft) st.push(node-\u003eleft); } return ans; } }; 形式二：通用框架 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; TreeNode* node = root; while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { ans.emplace_back(node-\u003eval); st.emplace(node); node = node -\u003e left; } node = st.top(); st.pop(); node = node -\u003e right; } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:1:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 更简单，更易于理解，但不容易体现技术水平 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { if (!node) return; // 先写操作，后遍历左右子树 ans.emplace_back(node-\u003eval); dfs(node-\u003eleft, ans); dfs(node-\u003eright, ans); } }; ","date":"2022-04-23","objectID":"/binary_tree/:1:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"中序遍历 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。 通常来说，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。 ","date":"2022-04-23","objectID":"/binary_tree/:2:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法 class Solution { public: vector\u003cint\u003e midorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; TreeNode* node = root; while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { st.emplace(node); node = node -\u003e left; } node = st.top(); st.pop(); ans.emplace_back(node-\u003eval); node = node -\u003e right; } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:2:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 class Solution { public: vector\u003cint\u003e midorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { if (!node) return; dfs(node-\u003eleft, ans); // 先遍历左子树，再进行操作，再遍历右子树 ans.emplace_back(node-\u003eval); dfs(node-\u003eright, ans); } }; ","date":"2022-04-23","objectID":"/binary_tree/:2:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"后序遍历 值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。 另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。 如上图，您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。 如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。 ","date":"2022-04-23","objectID":"/binary_tree/:3:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法 方法一：反前序迭代再反向输出 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { deque\u003cint\u003e ans; if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; TreeNode* node = root; while (!st.empty() || node != nullptr) { // 先往右走，走到底了就往左，接着重复同样操作 while (node != nullptr) { ans.emplace_front(node-\u003eval); st.emplace(node); node = node -\u003e right; } node = st.top(); st.pop(); node = node -\u003e left; } return ans; } }; 方法二： 硬迭代（较难） ","date":"2022-04-23","objectID":"/binary_tree/:3:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e ans; if (root == nullptr) return ans; dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { if (!node) return; dfs(node-\u003eleft, ans); // 先遍历左子树，再进行操作，再遍历右子树 dfs(node-\u003eright, ans); ans.emplace_back(node-\u003eval); } }; ","date":"2022-04-23","objectID":"/binary_tree/:3:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"层次遍历（广度优先） 此种方法区别于其他的方法的地方，在于其为广度优先搜索，适用于一些树的高度或路径记录的问题，需要用到队列来保存候选结点 class Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { vector\u003cvector\u003cint\u003e\u003e ans; if (!root) return ans; // 定义一个队列 queue\u003cTreeNode*\u003e que; // 初始加入根节点 que.emplace(root); // 可用于计算层数 int level = 0; while (!que.empty()) { // 先记录队列中元素数量,即当前层元素数量 int size = que.size(); vector\u003cint\u003e temp; // 当前层每个元素从队列头部出队后加入其左右的非空子结点 for (int i = 0; i \u003c size; ++i) { TreeNode* cur = que.front(); que.pop(); temp.emplace_back(cur -\u003e val); if (cur -\u003e left) que.emplace(cur -\u003e left); if (cur -\u003e right) que.emplace(cur -\u003e right); } // 将当前层的所有元素加入结果数组 ans.emplace_back(temp); } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:4:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"Morris遍历 本方法适用于前序和中序遍历，当然有了前序，后序自然就有了 morris遍历的思想是，通过记忆当前遍历节点的前继节点，建立一个回溯的通道，避免了栈的开销，空间复杂度为常数级。其原理如下代码注释所示 Morris遍历也有中序版本，只需要将对当前节点的操作放到已经遍历完左子树节点的位置即可。 class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; if (!root) return ans; // 初始化迭代指针p1, p1始终指向需要进行操作的结点 TreeNode* p1 = root; // p2 指针指向p1的前继结点, 一般为p1的左子树的最右下角的结点 TreeNode* p2 = nullptr; // 终止条件为 p1 非空 while (p1 != nullptr) { // p2 初始化为p1的左子树根节点 p2 = p1-\u003eleft; // p2 非空, 才要遍历左子树，否则直接遍历右子树 if (p2 != nullptr) { // p2 往右下角一直走，直到其指向最右下角的结点 while (p2 -\u003e right != nullptr \u0026\u0026 p2 -\u003e right != p1) p2 = p2 -\u003e right; // p2 没有后继（p2-\u003eright）结点, 那么改变其后继为p1 if (p2 -\u003e right == nullptr) { // 前序遍历的操作位置在这里！！！！！！！ ans.emplace_back(p1 -\u003e val); // 建立 p1 的前继结点 p2 -\u003e right = p1; // p1 向左下角继续遍历 p1 = p1 -\u003e left; continue; } else { // p2 的后继为 p1, 说明已经遍历过了当前节点的左子树 // 那么将这种关系删除，恢复原状，接着遍历右子树 // 中序遍历 操作的位置在这里！！！！！！ p2-\u003eright = nullptr; p1 = p1 -\u003e right; } } else { // p2 为空，那么直接对当前遍历结点 p1 操作，然后遍历右子树 ans.emplace_back(p1 -\u003e val); p1 = p1 -\u003e right; } } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:5:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"通用框架 ","date":"2022-04-23","objectID":"/binary_tree/:6:0","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"迭代解法（前、中序统一） class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { vector\u003cint\u003e ans; // 特例判定 if (root == nullptr) return ans; stack\u003cTreeNode*\u003e st; // 当前结点初始化为根节点 TreeNode* node = root; // 循环判断栈非空 或者 当前结点为空 while (!st.empty() || node != nullptr) { // 先往左走，走到底了就往右，接着重复同样操作 while (node != nullptr) { // 前序操作插入位置 st.emplace(node); // 入栈 node = node -\u003e left; // 继续往左下迭代 } node = st.top(); st.pop(); // 出栈 // 中序操作插入位置 node = node -\u003e right; // 往右子树走一次 } return ans; } }; ","date":"2022-04-23","objectID":"/binary_tree/:6:1","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["Algorithm"],"content":"递归解法 (前、中、后序统一) ```cpp class Solution { public: vector\u003cint\u003e traversal(TreeNode* root) { // 定义返回集 vector\u003cint\u003e ans; // 进行特殊条件判断 if (root == nullptr) return ans; // 调用递归函数 dfs(root, ans); return ans; } void dfs(TreeNode* node, vector\u003cint\u003e\u0026 ans) { // 递归终止条件 if (!node) return; // 前序操作插入位置 dfs(node-\u003eleft, ans); // 中序操作插入位置 dfs(node-\u003eright, ans); // 后序操作插入位置 } }; ","date":"2022-04-23","objectID":"/binary_tree/:6:2","tags":["Binary Tree"],"title":"二叉树","uri":"/binary_tree/"},{"categories":["C/C++"],"content":"从4行代码看右值引用 - qicosmos(江南) - 博客园 Value categories - cppreference.com https://www.stroustrup.com/terminology.pdf ","date":"2022-04-21","objectID":"/rvalue_ref/:0:0","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"左值与右值 ","date":"2022-04-21","objectID":"/rvalue_ref/:1:0","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"标准定义 每个 C++ 表达式（一个操作符和它的操作数，一个字面值，一个变量名等等）都代表着两个独立属性：类型+属性分类。，属性分类也叫值类别。 值类别是编译器在表达式计算期间创建、复制和移动临时对象时必须遵循的规则的基础。 C++17 标准定义表达式值类别，如下所示： glvalue (general lvalue)： 泛左值，由(lvalue)和(xvalue)构成。 rvalue 右值，由(xvalue)和(prvalue)构成。右值具有潜在的可移动性 prvalue(pure rvaluue) ： 纯右值，即传统意义上的右值 xvalue : 中间值？将亡值？，指通过“右值引用”产生的对象。 这里x可以理解为即将消失(expiring)，也可理解为中间（横跨左值和右值） lvalue ：传统意义上的左值 详细的定义可以参考：C++ lvalue，prvalue，xvalue，glvalue和rvalue详解（from cppreference） - PhiliAI - 博客园 (cnblogs.com) ","date":"2022-04-21","objectID":"/rvalue_ref/:1:1","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"通俗解释 C/C++ 语言中可以放在赋值符号左边的变量，左值表示存储在计算机内存的对象，左值相当于地址值。右值：当一个符号或者常量放在操作符右边的时候，计算机就读取他们的“右值”，也就是其代表的真实值，右值相当于数据值。 左值是可以取地址的，这也是区分左值和右值的唯一正确的标志 左值(lvalue)：可以出现在 = 左边 右值(rvalue)：只能出现在 = 右边 看一些左值和右值的例子，下面是整型的 int a = 9; int b = 4; // 左值为表达式 (a = 4) += 28; // 左值是一个表达式 a=4，这句话结果为 a=32 // 左值为变量 a = b; // a 和 b 都是左值 a + b = 42; // Error, a + b整体只是右值，出现右边，这句话出错 看一个关于 string 类型的 特别注意，C++规定字符串是左值 string s1(\"Hello\"); string s2(\"World\"); s1 + s2 = s2; // s1 + s2 是右值，但是这里编译成功了，后面看一下 string() = \"World\"; // 编译通过，左边是临时对象， 竟然也可以赋值 在函数中也会用到 int foo() { return 5; } // 函数返回的是一个右值 int x = foo(); int* p = \u0026foo(); //Error，对函数的返回值取地址，但是函数返回值为右值，取地址不行 foo() = 7; // Error，函数返回值为右值，只能出现在右边 简单的来说，能取地址的变量一定是左值，有名字的变量也一定是左值，最经典的void fun(p\u0026\u0026 shit)，其中shit也是左值，因为右值引用是左值（所以才会有move，forward这些函数的产生，其中move出来一定是右值，forward保持变量形式和之前的不变，就是为了解决右值引用是左值的问题）。 至于为什么不能把等号左边看成左值，因为在C++中，等号是可以运算符重载的，等号完全可以重载成为等号左边为右值的形式 纯右值是传统右值的一部分，纯右值是表达式产生的中间值，不能取地址 本质上，消亡值就是通过右值引用产生的值。右值一定会在表达式结束后被销毁，比如return x（x被copy以后会被销毁）, 1+2（3这个中间值会被销毁）。 ","date":"2022-04-21","objectID":"/rvalue_ref/:1:2","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"左值引用与右值引用 当右值出现在operater = (copy assignment) 的右侧，我们认为对其资源进行偷取/搬移（move）而非拷贝是可以的，是合理的。 那么就得有如下机制： 必须有语法让我们在调用端告诉编译器，这是一个”Rvalue“ 必须有语法让我们在被调用端写出一个专门处理”Rvalue“的所谓move assignment函数 ","date":"2022-04-21","objectID":"/rvalue_ref/:2:0","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"左值引用 左值引用根据其修饰符 const 的不同，可以区分为常量左值引用和非常量左值引用。左值引用实际上就是指针。 非常量左值引用只能绑定到非常量左值，不能绑定到常量左值和常量右值，（因为非常左值可以改变其值，但常量不可改变，性质相矛盾） 非常量右值。而如果绑定到非常量右值，就有可能指向一个已经被销毁的对象。 常量左值引用能绑定到非常量左值，常量左值，非常量右值，常量右值。 int a = 9; int \u0026aRef1 = a; // 非常量左值引用 \u003c----\u003e 非常量左值 const int \u0026aRef2 = a; // 常量左值引用 \u003c----\u003e 非常量左值 const int b = 4; int \u0026bRef1 = b; // Error，非常量左值不能绑定常量右值 const int \u0026bRef2 = b; // 常量左值引用 \u003c----\u003e 常量左值 const int \u0026ref1 = 2; // 常量左值引用 \u003c----\u003e 右值（具体某个值） const int \u0026ref2 = a==2; // 常量左值引用 \u003c----\u003e 右值（表达式） ","date":"2022-04-21","objectID":"/rvalue_ref/:2:1","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"右值引用 为什么要用到右值引用？ 从实践角度讲，它能够完美解决 C++ 中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了 C++ 中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 为了区别，C++ 把 \u0026 作为左值引用的声明符，把 \u0026\u0026 作为右值引用的声明符。例如， int GetValue() { return 3; } int main() { int a = 0; int \u0026alRef = a; // 左值引用 int \u0026\u0026rRef1 = 1; // 临时对象是右值 int \u0026\u0026rRef2 = GetValue(); // 调用的函数返回值为右值 } void ProcessValue(int \u0026i) { // 左值引用 cout \u003c\u003c \"lValue processed: \" \u003c\u003c i \u003c\u003c endl; } void ProcessValue(int \u0026\u0026i) { // 右值引用 cout \u003c\u003c \"rValue processed: \" \u003c\u003c i \u003c\u003c endl; } int GetValue() { return 3; } int main() { int a = 0; int b = 1; ProcessValue(a); // 左值 ProcessValue(1); // 临时对象是右值 ProcessValue(GetValue()); // 调用的函数为右值 ProcessValue(a + b); // 左值 } 从内存角度来看，我们给变量 a 分配好了内存，所以它是正统的内存使用者；而像函数的返回值、临时对象这样的右值，我们找不到它的内存，所以是盗版的内存使用者，这就是左值和右值的区别。 关于右值引用： 具名右值引用被视为左值。 无名右值引用被视为x值（将亡值）。 对函数的右值引用无论具名与否都将被视为左值。 struct A { int m; }; A\u0026\u0026 operator+(A, A); A\u0026\u0026 f(); A a; A\u0026\u0026 ar = static_cast\u003cA\u0026\u0026\u003e(a); 这里表达式 f(), f().m, static_cast\u003cA\u0026\u0026\u003e(a), 以及 a + a 都是 x值。 而表达式 ar 为 A 类型的左值。 ","date":"2022-04-21","objectID":"/rvalue_ref/:2:2","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["C/C++"],"content":"move 与 forward move std::move可以获取一个表达式的右值引用在C++11中，标准库在\u003cutility\u003e中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast\u003cT\u0026\u0026\u003e(lvalue); std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。 forward 可参考：聊聊C++中的完美转发 - 知乎 (zhihu.com) std::forward被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。 ","date":"2022-04-21","objectID":"/rvalue_ref/:2:3","tags":["cpp11"],"title":"右值引用与移动语义","uri":"/rvalue_ref/"},{"categories":["Algorithm"],"content":"Donald Knuth（高德纳）曾经说过二分法思路很简单，细节是魔鬼。本文就来探讨下二分法中的那些“魔鬼”细节 Reference 力扣 https://zhuanlan.zhihu.com/p/441033451 ","date":"2022-04-19","objectID":"/binary_search/:0:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"二分查找通用框架 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u003c target) { left = ... } else if (nums[mid] \u003e target) { right = ... } } return ...; } 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。 其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。 另外声明一下，计算 mid 时需要防止溢出，代码中left + (right - left) / 2就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。 这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。 这 3 个模板的不同之处在于： 左、中、右索引的分配。 循环或递归终止条件。 后处理的必要性。 模板 #1 和 #3 是最常用的，几乎所有二分查找问题都可以用其中之一轻松实现。模板 #2 更 高级一些，用于解决某些类型的问题。 这 3 个模板中的每一个都提供了一个特定的用例： 模板 #1 (left \u003c= right) 二分查找的最基础和最基本的形式。 查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。 不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。 模板 #2 (left \u003c right) 一种实现二分查找的高级方法。 查找条件需要访问元素的直接右邻居。 使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。 保证查找空间在每一步中至少有 2 个元素。 需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。 模板 #3 (left + 1 \u003c right) 实现二分查找的另一种方法。 搜索条件需要访问元素的直接左右邻居。 使用元素的邻居来确定它是向右还是向左。 保证查找空间在每个步骤中至少有 3 个元素。 需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。 ","date":"2022-04-19","objectID":"/binary_search/:1:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"第一种模板 本模板while条件采用 \u003c= 符号，索引初始的搜索区间右端点应为nums.length-1 ","date":"2022-04-19","objectID":"/binary_search/:2:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索单个值 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } ","date":"2022-04-19","objectID":"/binary_search/:2:1","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索左端点 最后需要做如下越界检查，左边和右边 left加到nums.length，此时target比所有值都大，不符合条件，所以检查left \u003e= nums.length 可直接返回-1 right会减到 -1，分两种情况 (1) target比所有值都小, 不符合条件， 此时left = 0, 但 nums[left] != target (2) 第一个元素正好为target，符合条件，right也会减到-1,但 nums[left] == target 所以可以直接检查第一个元素即nums[left]是否为目标值来区分两种情况。 当找到target时，right = mid - 1 即目标索引 mid = right + 1 = left ， 所以返回left. int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { // 缩小右边搜索区间 // 锁定左侧边界 right = mid - 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } // 做检查 if (left \u003e= nums.length || nums[left] != target) return -1; return left; } ","date":"2022-04-19","objectID":"/binary_search/:2:2","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索右端点 做如下越界检查 left加到nums.length，分两种情况 （1）target比所有值都大, 不符合条件，此时right = nums.length - 1,但nums[right] != target （2）最后元素正好为target，符合条件，left也会加到nums.length,但nums[right] == target right会减到-1，此时target比所有值都小，不符合条件，所以首先检查左边right \u003c 0可直接返回-1。 所以直接检查最后一个元素即nums[right]是否为目标值来区分上述两种情况。 当找到target时，left = mid + 1 即目标索引 mid = left - 1 = right， 返回right int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { // 缩小左边搜索区间 // 锁定右侧边界 left = mid + 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } // 做检查 if (right \u003c 0 || nums[right] != target) return -1; return right; } ","date":"2022-04-19","objectID":"/binary_search/:2:3","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"第二种模板 本模板while条件采用 \u003c 符号，索引初始的搜索区间右端点应为nums.length ","date":"2022-04-19","objectID":"/binary_search/:3:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索单个值 返回left 或者 righ, 因为此时left == right,其含义是nums种小于target的值数量，所以函数返回值的取值区间为[0, num.length]， 所以最后要做检查 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length; while(left \u003c right) { // 注意 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; // 注意 } } // Post-processing: // End Condition: left == right if(left != nums.length \u0026\u0026 nums[left] == target) return left; return -1; } ","date":"2022-04-19","objectID":"/binary_search/:3:1","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索左端点 直接返回left 是因为找到目标时，有right == mid, 又因为left == right所以返回left 考虑以下两种情况： 当 left 一直向右移动，最终left == nums.length(每次left = mid + 1), 意味着 target比所有数都大。不符合条件,检查这种情况返回-1即可。 当right一直向左移动，最终right == 0, (每次right= mid), 意味着 target 比所有数都小，不符合条件， nums[left] != target 最终剩余的nums[right]未检查，但nums[left] == target, 符合条件 为了区分上述两种情况，直接检查nums[left] == target 即可 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length; while(left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } // 额外检查target比所有数都大 if (left == nums.length) return -1; // 检查区间残留元素 return nums[left] == target ? left : -1; // 或者可以这样写 // if (left != nums.length \u0026\u0026 nums[left] == target) return left; // return -1; // 或者以下统一形式 return (left != nums.length \u0026\u0026 nums[left] == target) left : -1; } ","date":"2022-04-19","objectID":"/binary_search/:3:2","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"搜索右端点 注意这里是返回left - 1, 因为目标找到时有 left = mid + 1; 所以mid = left - 1; 考虑以下两种情况： 因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target 当 left 一直向右移动，最终left == nums.length(每次left = mid + 1), 意味着 target比所有数都大 。不符合条件, nums[left - 1] != target, 检查这种情况返回-1即可 恰好最后一个元素等于target,即 nums[left - 1] == target, 符合条件 为了区分上述两种情况，直接检查nums[left - 1] == target 即可 当right一直向左移动，最终right == 0, (每次right= mid), 意味着target 比所有数都小，不符合条件， nums[left] != target int binarySearch(int[] nums, int target) { int left = 0, right = nums.length; while(left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { left = mid + 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } if (left == 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; } ","date":"2022-04-19","objectID":"/binary_search/:3:3","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"第三种模板 int binarySearch(vector\u003cint\u003e\u0026 nums, int target){ if (nums.size() == 0) return -1; int left = 0, right = nums.size() - 1; while (left + 1 \u003c right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid; } else { right = mid; } } // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1; } ","date":"2022-04-19","objectID":"/binary_search/:4:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"若干条经验 当搜寻单个值时，用模板一，更易于理解，每次二分都直接进行了判断， 当搜寻某个最值或者区间端点时，用模板二 当使用模板一时，whie(left \u003c= right)常常与right = size() - 1 连用 当用模板二时，while (left \u003c right)常常与 right = size() 连用（不确定，有时也看情况） 当使用模板二时，int mid = left + (right - left) / 2 与 left = mid + 1连用，避免死循环，同理int mid = left + (right - left + 1) / 2与`left = mid``连用 当使用模板二时，考虑采用left = mid + 1 还是 left = mid 时，可以做如下思考：当前基于mid判断的nums[mid]是否可能出现在结果区间内，如果可能，考虑二分的那一侧应该包含mid, 即left = mid 或 right = mid,同理，当不可能出现在结果区间内，则应坚决排除，即left = mid + 1 或 right = mid + 1 ","date":"2022-04-19","objectID":"/binary_search/:5:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"实例研究 ","date":"2022-04-19","objectID":"/binary_search/:6:0","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["Algorithm"],"content":"单一值查找情况 力扣-二分查找 模板一 初始时right必须是len - 1, 否则在left = mid + 1时，可能取到left == right 且 left == len， 访问越界数组! class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } }; 模板二 注意： 下面文字说明中 ”=“ 不表示赋值 下面这种情况，初始时right = len - 1, 结束条件为left == right 当target大于区间所有元素时，搜索区间右端点始终固定为len - 1 若最后搜索区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步left = mid + 1 = right = len - 1, 然后有 left == right, 搜索结束。不会出现越界的情况 当target小于区间所有元素时，搜索区间左端点始终固定为0 若最后搜素区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步right = mid = left, 此时left = right, 搜索结束。也不会出现越界 上述两种情况，最后都是left = right时结束，但left下标的值却没有验证检查是否等于target，所以最后要做一个补充检查。此时left取值范围在[0, len - 1], 很安全，所以直接取值判断即可。 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len - 1; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return nums[left] == target ? left : -1; } }; 下面情况， 我们将right初始值取为len，看看会发生什么变化 当target大于区间所有元素时，搜索区间右端点始终固定为len 若最后搜索区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步left = mid + 1 = right = len, 然后有 left == right, 搜索结束。注意这时left = len，下标已经越界了, 如果最后直接取nums[left]会访问越界！ 当target小于区间所有元素时，搜索区间左端点始终固定为0 若最后搜素区间缩小到[left, right]，left = right - 1, 这时，mid = left, 下一步right = mid = left, 此时left = right, 搜索结束。也不会出现越界。 上述两种情况，最后都是left = right时结束，但left下标的值却没有验证检查是否等于target，同样最后要做一个补充检查，但是补充检查时，因为left取值范围为[0, len], 取值范围不安全，所以要多一个排除条件left != len。 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return (left != len \u0026\u0026 nums[left] == target) left : -1; } }; 再看看下面的代码，又在上面的代码上做了点小小的改动，即每次判断后下一搜索区间的取值范围，这里实际上把nums[mid] \u003e target条件下的right更新为了mid - 1, 可以看出没有丝毫影响，因为我们要找的是target, 当指明了target小于某个值，当然可以跳过该mid索引了，想一下，当nums[mid] == target时，我们为什么要取=mid, 因为满足此条件的任何mid索引对应的值都有可能出现在结果区间中，我们不能用left = mid + 1 或 right = mid - 1来跳过。那为什么不能取left=mid，这就是前文所述的死循环问题了，与mid取值有关，不做赘述。 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int len = nums.size(); int left = 0, right = len; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } } return (left != len \u0026\u0026 nums[left] == target) ? left : -1; } }; 小结 可以看出对于寻找单一值得情况，模板二中初始值 right = len 还是 right = len - 1，都是可以找到结果得，只是最后left的取值区间不一致，当right取len时，left取值空间包括了len，应该在后处理中做出排除。 当搜索区间断点时，比如以下搜索出现数字的最小位置和最大位置的代码： int binarySearch(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size(); while(left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return (left != nums.size() \u0026\u0026 nums[left] == target) left : -1; } 下面代码中，区别在于当nums[mid] = target时，所采取的动作，当搜索最大索引时，收紧左边界，但是由于避免死循环，所以left = mid + 1,导致结果区间中，left 为 最大目标索引的下一个位置，所以目标索引应该取left - 1 或right - 1,又由于left的取值区间为[0, nums.size()] ， 但我们只需关心left - 1的取值区间，即[-1, nums.size() - 1],发现这种情况相对于搜索最小位置的代码而言，自然优化了区间右端点，却导致了左端点越界，所以要额外检查左端点越界的情况。 int binarySearch(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size(); while(left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= target) { left = mid + 1; } else (nums[mid] \u003e target) { right = mid; } } return (left != 0 \u0026\u0026 nums[left - 1] == target) ? (left - 1) : -1; } 所以我们又可以考虑，当搜索右端点时，right初始化为nums.size() - 1时，要作何改变，代码如下 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size() - 1; if (left == right) return nums[0] == target ? 0 : -1; while(left \u003c right) { int mid = left + (right - left) /","date":"2022-04-19","objectID":"/binary_search/:6:1","tags":["Binary Search"],"title":"二分查找法之细节","uri":"/binary_search/"},{"categories":["document"],"content":"通用资源集 名校公开课程评价网 (conanhujinming.github.io) ","date":"2022-04-15","objectID":"/learing_resources/:1:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"操作系统 ","date":"2022-04-15","objectID":"/learing_resources/:2:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"推荐书籍 原理类 《操作系统设计与实现》Andrew S.Tanenbaum 《现代操作系统》Andrew S.Tanenbaum 《操作系统概念》Abraham Silberschatz 《Operating Systems: Three Easy Pieces》（OSTEP） 《深入理解计算机系统》（CSAPP） 《操作系统—精髓与设计原理》 《现代操作系统：原理与实现》（陈海波、夏虞斌等著，“银杏书”） 应用类 《Linux内核设计与实现》Robert Love ","date":"2022-04-15","objectID":"/learing_resources/:2:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"MIT6.S081 MIT6.S081操作系统导论 - 名校公开课程评价网 (conanhujinming.github.io) 课程翻译：简介 - MIT6.S081 (gitbook.io) MIT官方课程表： 6.S081 / Fall 2021 (mit.edu) xv6源码：mit-pdos/xv6-riscv: Xv6 for RISC-V (github.com) xv6-book (原版)：Lec01 Introduction and Examples (Robert) - MIT6.S081 (gitbook.io) xv6-book (翻译)：FrankZn/xv6-riscv-book-Chinese (github.com) 学习笔记： Docs (feishu.cn) 交流讨论: Docs (feishu.cn) 道友视频： 阿苏EEer的个人空间_哔哩哔哩_bilibili ","date":"2022-04-15","objectID":"/learing_resources/:2:2","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"ucore 课程地址：操作系统 - 清华大学 - 学堂在线 (xuetangx.com) ","date":"2022-04-15","objectID":"/learing_resources/:2:3","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"南大课程 实验地址：Introduction · GitBook (nju-projectn.github.io) 计算机系统基础实验：2020_spring_pa_0-1_环境配置和简介_哔哩哔哩_bilibili [完结] 2020 南京大学 “操作系统：设计与实现” (蒋炎岩)_哔哩哔哩_bilibili ","date":"2022-04-15","objectID":"/learing_resources/:2:4","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"计算机网络 ","date":"2022-04-15","objectID":"/learing_resources/:3:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"推荐书籍 原理类 《计算机网络 自顶向下方法》 《TCP/IP详解 卷1：协议》 《图解HTTP》 应用类 《Unix网络编程 卷1 Socket API/卷2 IPC》（UNP） 《TCP/IP详解 卷2：实现》 《TCP/IP详解 卷3：实现》 《TCP/IP网络编程》韩-尹圣雨 ","date":"2022-04-15","objectID":"/learing_resources/:3:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"中科大郑烇课程 《高级计算机网络》 中科大郑烇全套《高级计算机网络》_哔哩哔哩_bilibili 《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili ","date":"2022-04-15","objectID":"/learing_resources/:3:2","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"数据结构与算法 ","date":"2022-04-15","objectID":"/learing_resources/:4:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"推荐书籍 《算法导论》 《算法》 ","date":"2022-04-15","objectID":"/learing_resources/:4:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"C++ ","date":"2022-04-15","objectID":"/learing_resources/:5:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"推荐书籍 《Primer C++》 《Essential C++》 《Effective C++》 ","date":"2022-04-15","objectID":"/learing_resources/:5:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"开源项目 ","date":"2022-04-15","objectID":"/learing_resources/:6:0","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["document"],"content":"BRPC incubator-brpc · GitHub 百度内最常使用的工业级RPC框架, 有1,000,000+个实例(不包含client)和上千种多种服务。“brpc\"的含义是\"better RPC”。 重点关注下面几个文件： Task_group.cpp，bthread.cpp，futex.cpp，socket.cpp，channel.cpp 进阶 bvar实现，bthread_t使用 ","date":"2022-04-15","objectID":"/learing_resources/:6:1","tags":["Open Source"],"title":"开源学习资料","uri":"/learing_resources/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2022-04-11","objectID":"/hugo/","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2022-04-11","objectID":"/hugo/:0:0","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"1 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/avatar.png\" caption=\"Lighthouse (`image`)\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\"\rLighthouse (image)\r ","date":"2022-04-11","objectID":"/hugo/:1:0","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"2 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意\r\r一个 注意 横幅\r\r 摘要\r\r一个 摘要 横幅\r\r 信息\r\r一个 信息 横幅\r\r 技巧\r\r一个 技巧 横幅\r\r 成功\r\r一个 成功 横幅\r\r 问题\r\r一个 问题 横幅\r\r 警告\r\r一个 警告 横幅\r\r 失败\r\r一个 失败 横幅\r\r 危险\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r 示例\r\r一个 示例 横幅\r\r 引用\r\r一个 引用 横幅\r\r admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} ","date":"2022-04-11","objectID":"/hugo/:2:0","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"3 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2022-04-11","objectID":"/hugo/:3:0","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2022-04-11","objectID":"/hugo/:3:1","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2022-04-11","objectID":"/hugo/:3:2","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2022-04-11","objectID":"/hugo/:3:3","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2022-04-11","objectID":"/hugo/:3:4","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":["documentation"],"content":"4 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: \r如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2022-04-11","objectID":"/hugo/:4:0","tags":["shortcodes"],"title":"Hugo使用技巧","uri":"/hugo/"},{"categories":[],"content":"C++语言 ","date":"2022-04-09","objectID":"/learning_route/:1:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"C++基础语法 头文件以及宏定义 const 与 constexpr auto 与 decltype using 与 命名空间 enum 枚举类 分离式编译 指针与引用 C++结构体与C结构体 传值方式 静态变量static volatile关键字 隐式类型转换与 explicit 关键字 类型转换 static_cast\u003c\u003e, dynamic_cast\u003c\u003e Lambda表达式 ","date":"2022-04-09","objectID":"/learning_route/:1:1","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"面向对象 面向对象理解：封装、继承、多态 struct 与 class区别 构造函数 初始化列表：顺序 默认构造函数 拷贝构造函数 移动构造函数 重载和重写 运算符重载 拷贝赋值运算符 多态与虚函数 多态：编译器多态（模板），运行时多态（重写） ","date":"2022-04-09","objectID":"/learning_route/:1:2","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"C++标准库 IO库 IO类： iostream 文件输入输出： fstream string流：sstream 标准模板库（STL） 序列容器(vector,list,deque) vector: 扩容 list: 双向列表 deque: 多node组合 关联容器 (multi) unordered_map/set : Hash Table + 链表/红黑树 (multi) map/set : 红黑树，有序 STL6大组成部分 容器(Container)、算法(Algorithm)、迭代器(Iterator) 适配器(Adapter)、分配器(Alloctor)、仿函数(Functor) string类 ","date":"2022-04-09","objectID":"/learning_route/:1:3","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"动态内存与智能指针 shared_ptr unique_ptr new 与 delete 右值引用 (\u0026\u0026) 与 对象移动(std::move) ","date":"2022-04-09","objectID":"/learning_route/:1:4","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"异常处理 抛出异常 捕获异常 异常类层次 ","date":"2022-04-09","objectID":"/learning_route/:1:5","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"数据结构与算法 ","date":"2022-04-09","objectID":"/learning_route/:2:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"数据结构 链表 单向链表 双向链表 队列 环形队列 栈 双栈 堆 建堆、调整堆 大顶堆、小顶堆 二叉树 完全二叉树 先序遍历、中序遍历、后序遍历 二分查找树BST 红黑树 b树、b+树 图 有向图、无向图 邻接表、邻接矩阵、稀疏矩阵 散列表（Hash Table） 跳表 布隆过滤器 ","date":"2022-04-09","objectID":"/learning_route/:2:1","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"算法 排序: 快排、归并、堆排序 、希尔 分治法、减治法，二分查找 图算法：dijkstra算法，最小生成树Kruskal DFS，BFS 贪心算法 动态规划 ","date":"2022-04-09","objectID":"/learning_route/:2:2","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"操作系统 ","date":"2022-04-09","objectID":"/learning_route/:3:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"基本概念 用户态/内核态 系统调用 ","date":"2022-04-09","objectID":"/learning_route/:3:1","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"内存管理 物理内存/虚拟内存 虚拟地址映射 分页，页表 页面置换算法 缺页中断 内存池 ","date":"2022-04-09","objectID":"/learning_route/:3:2","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"进程与线程 进程 孤儿进程 僵尸进程 守护进程 线程 IPC 管道、命名管道 信号Signal 信号量Semaphore Socket 共享内存shared memory 内存映射mman ","date":"2022-04-09","objectID":"/learning_route/:3:3","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"死锁 互斥 互斥锁 读写锁 同步 信号量 条件变量+互斥锁 ","date":"2022-04-09","objectID":"/learning_route/:3:4","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"文件系统 磁盘文件系统 虚拟文件系统 文件系统实现原理 ","date":"2022-04-09","objectID":"/learning_route/:3:5","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"IO ","date":"2022-04-09","objectID":"/learning_route/:3:6","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"Linux系统实操 shell / vi的使用 Linux系统性能监控参数 ps / netstat / df ","date":"2022-04-09","objectID":"/learning_route/:3:7","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"数据库 关系型数据库(MySQL) MySQ安装与配置 sql建表，索引，存储过程 存储引擎，myissam/innodb 数据库连接池 异步数据库请求 数据库集群， 分库分表，读写分离 NoSQL(Redis) Redis编译安全，配置 Redis命令使用 Redis连接池/异步Redis的做法 Redis集群，数据备份 缓存雪崩，缓存击穿 ","date":"2022-04-09","objectID":"/learning_route/:4:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"网络原理 网络体系模型 TCP三次握手，四次挥手，滑动窗口，状态机 UDP的原理 http/https/http2.0/http3.0 Session Cookie application 网络安全，加密，数字签名 wireshark, tcpdump iperf ","date":"2022-04-09","objectID":"/learning_route/:5:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"网络编程 ping, telnet, ifconfig 使用 socket编程， tcp/udp 网络IO模型，阻塞/非阻塞，同步异步 io多路复用 select/poll/epoll epoll reactor, proactor time_wait/close_wait大量 C10K/C1000K/C10M 网络框架 libevent/libv 协程 ntyco, libco ","date":"2022-04-09","objectID":"/learning_route/:6:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"设计模式 设计原则 创建型模式 单例模式 工厂模式 结构型模式 适配器模式 代理模式 组合模式 装饰模式 行为型模式 策略模式 观察者模式 迭代器模式 模板方法模式 命令模式 ","date":"2022-04-09","objectID":"/learning_route/:7:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":[],"content":"并行与分布式系统  ","date":"2022-04-09","objectID":"/learning_route/:8:0","tags":[],"title":"学习路线（持续更新）","uri":"/learning_route/"},{"categories":["Computer Network"],"content":"可靠数据传输原理 可靠数据传输(Reliable Data Transfer)是一个很大的概念，在计算机网络的五层模型中，它可以出现在传输层、数据链路层和应用层。简单点说，可靠数据传输服务保证了通信过程中的数据接收方接收到的数据与其从数据发送方发出的数据一致。而提供这种可靠数据传输服务的协议称为可靠数据传输协议，例如传输层的TCP协议。 可靠数据传输为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。在这条信道中传输的数据bit不会受到损坏和或丢失，而且所有的数据都是按其发送顺序交付。其对应的服务框架如下图所示，TCP协议向调用它的因特网应用所提供的服务模型恰恰如此，所以当谈到可靠数据传输时，不可避免地会涉及大量TCP协议的分析。 那么一个网络协议要实现可靠数据传输需要具备哪些特性呢？或者说，协议中需要设定哪些规则来避免数据传输的不可靠？为了数据传输的可靠，我们就要解决数据不可靠的情况，而数据传输的不可靠的情形最基本的有如下几种： 数据在信道中传输时，比特出现了错误，例如本来该bit为0，到了接收端却成为了1 数据在信道中传输时，比特发生了丢失，例如本来按序发送了16个比特，结果到了接收端只收到了8个比特 数据在信道中传输时，比特流的顺序发生了变化，例如发送端按照序号1，2，3，4，5发送的比特流，结果到了接收端收到是1，3，2，5，4 数据在信道中传输时，接收端接收到了重复的数据，例如发送端按照序号1，2，3发送，到了接收端收到是1，2，2，3 先思考一下，针对上面的若干基本情况，我们要怎么处理。首先数据在接收方出现了不一致的情况，我们如何得知呢？这就需要通过差错检测机制，通过差错检测，我们可以检测到何时何处出现了比特差错。然后，出现了差错该怎么办呢？作为接收方，肯定要告诉发送方我收到的数据有问题，所以就要有接收方反馈功能，也就是接收方发送明确的反馈信息给发送方。那么发送方接收了该反馈信息又该怎么做呢？最基本且有效的情况无非就是重新发送一份错误数据对应的原数据，也就是重传。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:1:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"可靠数据传输特征 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"差错检测 ​ 差错检测主要的实现方式就是在传输的数据流中添加额外的比特信息以增加冗余度，主要分为两大类：奇偶效验和分组检验。其中分组校验中典型的方法有校验和法（IP数据报）和循环冗余校验法。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"接收方反馈 一般是给出肯定确认ACK或否定确认NAK，也可以通过冗余ACK的方式代替否定确认。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"重传 在分组传送时，主要有累积重传和选择重传。 通过上述几个功能，我们可以设计出能够工作的协议，但是，仔细想象一下你就会发现，这个步骤中有一个致命缺陷。在接收方给发送方发送反馈信息时，假设这个反馈信息也出了错误，那么发送方就无法知道接收方是否正确接收上一次发送的数据了。 再思考一下，如果我们是协议设计者，会怎么做？可以考虑以下几种方式： 发送方接收到错误的反馈信息表示无法理解时，便又向接收方发送针对该反馈信息的解释请求，即引入了一种新型的从发送方到接收方的分组。就像打电话时一方不理解另一方时会提问“你说啥？”，另一方则会重复回答。要是这个“你说啥”也产生了差错，岂不又是越陷越深了。 增加足够的检验和比特，使得发送方不但可以检测差错还可以恢复差错，对于只产生错误而没有丢失的分组，就可以直接解决问题。 当发送方收到含糊不清的反馈信息后，只需要重传当前数据分组即可。这种方法在信道中引入了冗余分组。而冗余分组所带来一个问题就是，接收方不知道它上次发送的反馈信息是否被发送方正确接收，也就是说接收方无法事先知道接收到的分组时新的还是一次重传，这很重要，因为如果将重传分组当作新的分组，那么数据包就会出错了。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:3","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"序号 ​为了解决上述冗余分组中的问题，我们就又提出一种协议功能，就是给数据分组编号，这也是包括TCP在内所有的数据分组采用的方法。即在数据分组中添加一个新的字段，让发送方对其数据分组编号，将发送数据分组的序号放在该字段。于是，接收方只需要检查序号就可以确定该分组是否是一次重传了。对于停等协议（Stop and Wait，SW）来说，该字段只需要一个比特即可。因为停等协议中，发送方必须等待接收方传回ACK或NAK才能继续发送下一个数据分组。 除了具备差错检测与恢复外，我们还需要考虑当分组丢失分情况，而上面的协议功能不足以解决分组丢失的问题。当发送方发送一个数据后，在信道中丢失，接收方自然没有收到数据从而不会发送反馈，于是发送方迟迟没有收到确认。这时候，我们一般情况下都是会等待一定时间后重新发送该分组。所以我们又引入一个新的协议功能：倒计数定时器，通过设定一个给定的时间量，当时间量过期后，便重传分组。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:4","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"倒计数定时器 为了容忍数据丢失，我们在发送方引入倒计数定时器。即1. 每次发送一个分组时（包括第一次分组和重传分组），启动一个定时器。2. 响应定时器中断（采取适当动作，比如重传）。3. 终止定时器。 综上，在实现了差错检测，接收方反馈，重传，序号，倒计数定时器这些协议功能后，就可以得到一个可靠数据传输协议了。 具备上述协议功能的协议分为两种，一种是停止-等待协议，一种是流水线协议，后者是前者的加强版，提升了信道的利用率。实际上ARQ协议也是分为了类似的两类。说到ARQ，那么就介绍一下它：  ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。其中，连续ARQ就是一种流水线协议。 我们说到流水线协议相对于停止等待协议增加了信道的利用率，但是也带来了一定程度的局限性。例如： 流水线协议必须增加序号的范围，因为每个传输中的分组必须有一个唯一的序号用来区分分组，而且也许在输送中存在多个未确认的报文。而停止等待协议只需一个比特位来给分组编号（即比特交替协议） 协议的发送方和接收方两端也许必须缓存多个分组。这样做的目的是为了差错恢复，这取决于协议如何处理丢失、损坏以及时延过大的分组所需序号范围i和对缓冲的要求取决于数据传输协议如何 流水线协议中差错恢复的两种方法：回退N步（Go-Back-N,GBN）和选择重传（Selective Repeat,SR）。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:2:5","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"回退N步协议(GBN) 回退N步协议允许发送方发送多个分组而不确认，但是其在流水线中未确认的分组的数量不能超过N。这个协议又被称作滑动窗口协议，是因为流水线中已被发送但还未被确认的分组的许可范围构成了一个在序号范围内长度为N的窗口，N就是窗口的大小，随着协议运行，该窗口的序号空间不断向前滑动。思考一下，为什么要设置这么一个窗口呢？其实是为了流量控制和拥塞控制的需要，我们将在后文介绍。 在GBN中，发送方必须响应的三种类型事件是： 上层的调用。 收到一个ACK，该协议对序号为n的分组的确认采取累积确认的方式，表明接收方已经正确接收到序号为n的以前且包括n在内的所有分组。 超时事件，go-back N行为正来自出现丢失或时延过长分组时发送方采取的差错恢复行为。同样也用到了定时器，出现超时的时候，发送方将重传所有已发送但还未被确认的分组，所以在发送方缓存这些分组是十分必要的。如果收到一个ACk,但仍有已发送但未确认的分组，则定时器会被重新启动，如果没有则会终止。 GBN协议中，接收方会丢弃失序的分组，因为GBN采用累积确认，一次交付给上层一个分组，接收方必须按序将数据交付给上层，丢失分组是一种简单的方法之一，另外的一种就是放在接收方缓存起来，等带下一个按序的分组，最后在组装正确的数据交付。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:3:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"选择重传协议(SR) GBN虽然采用了流水线解决了信道利用率的问题，但是也会存在另外的性能问题，例如当窗口长度很大或者带宽时延积都很大时，在流水线中有更多的分组时更甚。因为在这些情况下，必须重传大量分组，代价太大了，也许只是窗口中诸多分组的一个或几个分组出现错误，便要重传全部已经发送但未确认的分组，未免太浪费了。 而选择重传机制就是让发送方仅仅重传那些它怀疑在接收方出错(丢失或受损)的分组，从而避免了不必要的重传。但是这种方式就不能采用累积确认了，而是要求接收方逐个地确认正确接收的分组。即接收方确认正确的分组不管其是否失序，失序的分组将被缓存直到所有比失序分组序号小的分组都被接收为止，才会将一批分组按序交付。 但是这种方式会带来一个问题，就是接收方和发送方的窗口并不是总是一致的，因为对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不是总能看到一样的结果。这意味着，当序号范围有限时，发送方和接收窗口之间缺乏同步会产生严重的后果。这就要求SR协议中，窗口长度必须小于或等于序号空间大小的一半。后续将证明。 到现在为止，我们介绍了若干可靠传输机制，下表是一个总结。 机制 用途和说明 检验和 用于检测在一个传输分组中的比特错误 定时器 用于超时/重传一个分组,可能因为该分组(或其ACK)在信道中丢失了。由于当一个分组延时但未丢失，或当一个分组已被接收方接收但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本 序号 用于为从发送方流向接收方的数据分组按序号编号。所接受分组的序号的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本 确认 接收方用于告诉发送方一个分组或一组分组已经被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或积累的，这取决于协议 否定确认 接收方用于告诉发送方某个分组未被正确的接收.否则人确定报文通常携带着未被正确接收的分组的序号 窗口、流水线 发送方也许被限制仅发送那些序号落在一个指定范围内的分组.通过允许一次发送多个分组但未被确认,发送方的利用率可以在停等操作模式上得到增加。我们很快将会看到,窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者的情况来进行设置 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:4:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"从TCP协议中看可靠数据传输 介绍了可靠数据传输的基本原理之后，我们再来探讨一种典型的可靠数据传输协议——TCP，TCP是因特网运输层的面向连接的可靠的运输协议。 TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。 TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手来关闭一个连接 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP报文段结构 16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。 32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。 32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。 4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示 15，所以 TCP 头部最长是60 字节 6 位标志位包含如下几项： URG 标志，表示紧急指针（urgent pointer）是否有效。 ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文段。 16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。 这也是 TCP 可靠传输的一个重要保障。 16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP三次握手 1、三次握手是什么？ 概念\r\r三次握手其实就是指在建立TCP连接时需要客户端和服务器端总共发送三个数据包，主要作用是确认服务器端和客户端的发送和接受能力是否正常，指定自己的初始序列号为后面的可靠性传输作准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息\r\r 第一次握手: 客户端向服务器端发送一个SYN报文，并指明自己的初始序列号ISN，此时客户端处于SYN_SEND状态。 注意\r\r首部的同步位SYN=1，初始序列号seq=1，SYN=1的报文段不能携带数据，但要消耗掉一个序号\r\r 第二次握手：服务器端在收到客户端的SYN报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。 注意\r\r在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y\r\r 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接 注意\r\r确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\r\r 2、为什么需要三次握手，两次不行吗？ 弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 因此，需要三次握手才能确认双方的接收与发送能力是否正常。 试想如果是用两次握手，则会出现下面这种情况： 警告\r\r如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源\r\r 3、什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…… 4、ISN(Initial Sequence Number)是固定的吗？ 当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。 三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 5、三次握手过程中可以携带数据吗？ 其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据 为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。 6、SYN攻击是什么？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 netstat -n -p TCP | grep SYN_RECV 常见的防御 SYN 攻击的方法有如下几种： 缩短超时（SYN Timeout）时间 增加最大半连接数 过滤网关防护 SYN cookies技术  ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP滑动窗口 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。 、 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:3","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP四次挥手 1、四次挥手过程? 建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下： 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。 收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。 在socket编程中，任何一方执行close()操作即可产生挥手操作。 2、挥手为什么需要四次？ 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。 3、2MSL等待状态 TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。 对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。 这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。 4、四次挥手释放连接时，等待2MSL的意义? MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。 两个理由： 保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 5、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？ 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:4","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"TCP状态转换 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:5:5","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"流量控制 TCP 利用滑动窗口实现流量控制 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。 TCP的两端都有发送/接收缓存和发送/接收窗口。TCP的缓存是一个循环队列。在进程调用send()发送的数据的时候，会将数据拷贝进入内核的socket发送缓冲区之中，然后send便会在上层返回。换句话说，send返回之时，数据不一定会发送到对端去。接收缓冲区把数据缓存入内核，应用进程如果一直没有调用recv()进行读取的话，此数据会一直缓存在相应socket的接收缓冲区内。不管进程是否调用recv()读取socket，对端发来的数据都会经由内核接收并且缓存到socket的内核接收缓冲区之中。 发送缓存中的发送窗口可以用3个指针表示。已发送但未被确认数据大小\u003c=发送窗口的大小。已被确认的数据会从发送缓存中删除。然后发送窗口整体向左移。此外要说明一下，接受方的接受窗口是指接受方中的接受缓存中剩余可用空间大小，该值会通知给发送端调整发送窗口，从而控制流量。 发送方应用程序必须控制写入缓存的速率，不能太快，否则发送缓存会没有存放数据的空间。但是，linux下可以动态调整缓冲区的大小。发送缓冲区的动态调整比较简单，当发送缓冲区的剩余空间充足的时候，可以减小发送缓冲区的大小，反之则增加缓冲区的大小。 输出\r\rcat /proc/sys/net/ipv4/tcp_wmem 4096 87380 4194304 // 4096表示缓冲区的最小大小，4194304表示缓冲区的最大大小，87380 表示默认值 \r\r 发送窗口的大小受TCP数据报中窗口大小的影响，TCP数据报中的窗口大小是接收端通知发送端其还可以接收多少数据，因此发送窗口根据接收的的窗口大小的值动态变化。需要明确的是，发送窗口只是发送缓存的一部分。 接受缓存区也可以自动调整，在高并发的场景中可以降低默认的缓冲区大小，提高并发性。 输出\r\rcat /proc/sys/net/ipv4/tcp_rmem 4096 87380 4194304 \r\r 查看是否开启接受缓冲区自动调整的功能 输出\r\rcat /proc/sys/net/ipv4/tcp_moderate_rcvbuf 4096 87380 4194304 \r\r 发送缓冲区自动调节的依据是待发送的数据，接收缓冲区由于只能被动地等待接收数据，它该如何自动调整呢？可以依据空闲系统内存的数量来调节接收窗口。如果系统的空闲内存很多，就可以把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而对方的发送速度就会通过增加飞行报文（发送还未确认的报文）来提升。反之，当内存紧张时就会缩小缓冲区，这虽然会减慢速度，但可以保证更多的并发连接正常工作。需要注意，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样做就可以避免了丢包情况。 当接受缓存满并且系统不再有内存分配调整大小，此时接受方会发送零窗口大小的报文，具体做法是将返回的确认（ACK）报文的窗口值大小设置为0（窗口关闭），让发送方停止发送数据。之后接收方有足够的缓存，再发送非零窗口大小的报文。 此外，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。这样做是为了避免发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，使得变成相互等待，会造成了死锁的现象 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:6:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"拥塞控制 在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的包丢失，此时网络拥塞将会进入恶性循环并且不断地放大。 拥塞控制协议维护着一个拥塞窗口，会根据网络的拥塞状态而动态调整，其调整规则为1.只要网络中没有出现拥塞，cwnd 就会增大；2. 网络中如果出现了拥塞，cwnd 就减少。加入拥塞窗口后，此时发送窗口swnd = min(cwnd(拥塞窗口), rwnd(接受窗口)) 那么如何判断是否出现网络拥塞呢？一种简单的方法就是只要发生了丢包，触发超时重传就会判定网络出现拥塞。 TCP 在刚建立连接完成后，首先是有个慢启动的过程，以指数性的提高发送数据包的数量。当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。当慢启动一段时间后，达到慢启动门限 ssthresh，就会改用拥塞避免模式，进行线性增大。当网络出现超时重传（拥塞）时，门限值调整为一半，cwnd=1，然后改为执行慢启动模式。当网络出现快速重传（拥塞）时，cwnd = cwnd/2，ssthresh = cwnd，然后改为执行拥塞避免模式。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"慢开始+拥塞避免 （1）拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16； （2）执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长； （3）假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=cwnd/2=12，cwnd重新设置为1，并执行慢开始算法。 （4）当cwnd=12=ssthresh时，改为执行拥塞避免算法。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"快重传+快恢复 快重传(Fast retransmit) 快速重传(Fast retransmit)要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。 快恢复(Fast Recovery) （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。此时直接进入拥塞避免。请注意：接下来不执行慢开始算法。 （2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"拥塞控制与流量控制区别 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:7:3","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"参考 【计算机网络】学习笔记汇总（目录）（谢希仁） - 知乎 (zhihu.com) ","date":"2022-01-07","objectID":"/reliable_data_transfer/:8:0","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["C/C++"],"content":"GCC 编译工具 GCC是一款强大的编译工具，下文在介绍c以及c++程序的编译运行流程中将采用gcc做示例。 GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由 [2] 。 GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言编 译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数 -std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 \u003e 4.8.5） 查看版本 gcc/g++ -v/--version ","date":"2021-05-19","objectID":"/compile_link/:1:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"1.gcc 和 g++ 的关系 gcc 和 g++都是GNU(组织)的一个编译器。 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的 宏__cplusplus只是标志着编译器将会把代码按 C 还是 C++ 语法来解释，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义 编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++ gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价 ","date":"2021-05-19","objectID":"/compile_link/:1:1","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"2.gcc 常用编译参数 -E 预处理指定的源文件，不进行编译 -S 编译指定的源文件，但是不进行汇编 -c 编译、汇编指定的源文件，但是不进行链接 -o [file1] [file2] /[file2] -o [file1] 将文件 file2 编译成可执行文件 file1 -I directory 指定 include 包含文件的搜索目录 -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -On n的取值范围：0~3。编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高 -l 在程序编译的时候，指定使用的库 -L 指定编译的时候，搜索的库的路径。 -fPIC/fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 指定C方言，如:-std=c99，gcc默认的方言是GNU C ","date":"2021-05-19","objectID":"/compile_link/:1:2","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"3.GCC 工作流程 GCC工作流程也就是一个c/c++语言程序从编译到生成可执行程序的过程，如下图所示。 下面分别介绍各个阶段,我们的示例代码如下： . ├── include │ ├── mymath.c │ └── mymath.h └── test.c test.c #include \u003cstdio.h\u003e#include \"mymath.h\" int main(int argc, char **argv) { int a = 2, b = 3; int sum = add(a, b); printf(\"a=%d, b=%d, a+b=%d\", a, b, sum); return 0; } mymath.h #ifndef MYMATH_H #define MYMATH_H int add(int a, int b); int sub(int a, int b); int mul(int a, int b); double div(int a, int b); #endif mymath.c int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } int mul(int a, int b) { return a * b; } double div(int a, int b) { return a * 1.0 / b; } ","date":"2021-05-19","objectID":"/compile_link/:1:3","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"1.预处理（Preprocessing） 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。 预处理器的主要作用就是: 把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有: 文件包含，条件编译、布局控制和宏替换4种。 文件包含: #include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。 条件编译: #if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。 布局控制: #progma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。 宏替换: #define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。 gcc的预处理是预处理器cpp来完成的，你可以通过如下命令对test.c进行预处理 : # -I 指定头文件目录 # -E 指定编译器在预处理后就退出，不再进行后续编译过程 # -o 指定输出的文件名 gcc -E test.c -I ./include -o test.i # 或者直接用cpp命令 cpp test.c -I ./include -o test.i 执行结果为： -rw-r--r-- 1 lwy lwy 106 Apr 6 20:56 test.c -rw-r--r-- 1 lwy lwy 16349 Apr 6 21:14 test.i 看得出来经过预处理后的文件比源文件要大很多，预处理之后的程序还是文本，可以用文本编辑器打开。其内容大致如下： # 1 \"test.c\" # 1 \"\u003cbuilt-in\u003e\" # 1 \"\u003ccommand-line\u003e\" # 31 \"\u003ccommand-line\u003e\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4# 32 \"\u003ccommand-line\u003e\" 2 # 1 \"test.c\" # 1 \"/usr/include/stdio.h\" 1 3 4# 27 \"/usr/include/stdio.h\" 3 4 ... typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; ... # 4 \"test.c\" int main(int argc, char **argv) { printf(\"hello world\"); return 0; } ","date":"2021-05-19","objectID":"/compile_link/:2:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"2.编译（Compilation） 这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。编译的指令如下： gcc -S -I ./include test.c -o test.s 上述命令中-S让编译器在编译之后停止，不进行后续过程。编译过程完成后，将生成程序的汇编代码test.s，内容如下： .file \"test.c\" .text .section .rodata .LC0: .string \"hello world\" .text .globl main .type main, @function main: .LFB0: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl %edi, -4(%rbp) movq %rsi, -16(%rbp) leaq .LC0(%rip), %rdi movl $0, %eax call printf@PLT movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident \"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04) 9.4.0\" .section .note.GNU-stack,\"\",@progbits .section .note.gnu.property,\"a\" .align 8 .long 1f - 0f .long 4f - 1f .long 5 0: .string \"GNU\" 1: .align 8 .long 0xc0000002 .long 3f - 2f 2: .long 0x3 3: .align 8 4: ","date":"2021-05-19","objectID":"/compile_link/:3:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"3.汇编（Assemble） 汇编过程将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。gcc汇编过程通过gcc -c命令完成： gcc -c test.s -o test.o gcc -c ./include/mymath.c -o ./include/mymath.o 这一步会为每一个源文件产生一个目标文件。因此mymath.c也需要产生一个mymath.o文件 . ├── include │ ├── mymath.c │ ├── mymath.h │ └── mymath.o ├── test.c ├── test.i ├── test.o └── test.s ","date":"2021-05-19","objectID":"/compile_link/:4:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"4.链接（Linking） 链接过程将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file),其命令如下 gcc -o test.out test.o include/mymath.o # 这里用g++也可，当是c++程序时倾向使用g++ 结果\r\r . ├── include │ ├── mymath.c │ ├── mymath.h │ └── mymath.o ├── test.c ├── test.i ├── test.o ├── test.out └── test.s \r\r 执行\r\r./test.out\r\r 结果为： 输出\r\rlwy@lwysLaptop:~/workspace/test$ ./test.out hello world \r\r 经过以上分析，我们发现编译过程并不像想象的那么简单，而是要经过预处理、编译、汇编、链接。尽管我们平时使用gcc命令的时候没有关心中间结果，但每次程序的编译都少不了这几个步骤。也不用为上述繁琐过程而烦恼，因为你仍然可以： 输出\r\rgcc/g++ -c test.c -o test.out\r\r ","date":"2021-05-19","objectID":"/compile_link/:5:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["Computer Network"],"content":"IO多路复用简介 I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll 100%弄明白5种IO模型 - 知乎 (zhihu.com) 聊聊Linux 五种IO模型 - 简书 (jianshu.com) 本文仅介绍Multiplexing IO。 ","date":"2021-05-12","objectID":"/io_multiplexing/:1:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"select 主旨思想： 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O 操作时，该函数才返回。 这个函数是阻塞 函数对文件描述符的检测的操作是由内核完成的 在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作 // sizeof(fd_set) = 128 1024 #include \u003csys/time.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003csys/select.h\u003eint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); - 参数： - nfds : 委托内核检测的最大文件描述符的值 + 1 - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性 - 一般检测读操作 - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲 区 - 是一个传入传出参数 - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性 - 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写） - exceptfds : 检测发生异常的文件描述符的集合 - timeout : 设置的超时时间 struct timeval { long tv_sec; /* seconds */ long tv_usec; /* microseconds */ }; - NULL : 永久阻塞，直到检测到了文件描述符有变化 - tv_sec = 0 tv_usec = 0， 不阻塞 - tv_sec \u003e 0 tv_usec \u003e 0， 阻塞对应的时间 - 返回值 : - -1 : 失败 - \u003e0(n) : 检测的集合中有n个文件描述符发生了变化 // 将参数文件描述符fd对应的标志位设置为0 void FD_CLR(int fd, fd_set *set); // 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1 int FD_ISSET(int fd, fd_set *set); // 将参数文件描述符fd 对应的标志位，设置为1 void FD_SET(int fd, fd_set *set); // fd_set一共有1024 bit, 全部初始化为0 void FD_ZERO(fd_set *set) ","date":"2021-05-12","objectID":"/io_multiplexing/:2:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"poll #include \u003cpoll.h\u003estruct pollfd { int fd; /* 委托内核检测的文件描述符 */ short events; /* 委托内核检测文件描述符的什么事件 */ short revents; /* 文件描述符实际发生的事件 */ }; struct pollfd myfd; myfd.fd = 5; myfd.events = POLLIN | POLLOUT; int poll(struct pollfd *fds, nfds_t nfds, int timeout); - 参数： - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合 - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1 - timeout : 阻塞时长 0 : 不阻塞 -1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞 \u003e0 : 阻塞的时长 - 返回值： \u003e0（n） : 成功,n表示检测到集合中有n个文件描述符发生变化 ","date":"2021-05-12","objectID":"/io_multiplexing/:3:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"epoll #include \u003csys/epoll.h\u003e// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向 链表）。 int epoll_create(int size); - 参数： size : 目前没有意义了。随便写一个数，必须大于0 - 返回值： -1 : 失败 \u003e 0 : 文件描述符，操作epoll实例的 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; 常见的Epoll检测事件： - EPOLLIN - EPOLLOUT - EPOLLERR // 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); - 参数： - epfd : epoll实例对应的文件描述符 - op : 要进行什么操作 EPOLL_CTL_ADD: 添加 EPOLL_CTL_MOD: 修改 EPOLL_CTL_DEL: 删除 - fd : 要检测的文件描述符 - event : 检测文件描述符什么事情 // 检测函数 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); - 参数： - epfd : epoll实例对应的文件描述符 - events : 传出参数，保存了发送了变化的文件描述符的信息 - maxevents : 第二个参数结构体数组的大小 - timeout : 阻塞时间 - 0 : 不阻塞 - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞 - \u003e 0 : 阻塞的时长（毫秒） - 返回值： - 成功，返回发送变化的文件描述符的个数 \u003e 0 - 失败 -1 struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; 常见的Epoll检测事件： - EPOLLIN - EPOLLOUT - EPOLLERR - EPOLLET ","date":"2021-05-12","objectID":"/io_multiplexing/:4:0","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"LT模式（Level Triggerd） 假设委托内核检测读事件 -\u003e 检测fd的读缓冲区 读缓冲区有数据 - \u003e epoll检测到了会给用户通知  a. 用户不读数据，数据一直在缓冲区，epoll 会一直通知  b. 用户只读了一部分数据，epoll会通知  c. 缓冲区的数据读完了，不通知 提示\r\rLT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的\r\r ","date":"2021-05-12","objectID":"/io_multiplexing/:4:1","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"ET模式（Edge Triggerd） 假设委托内核检测读事件 -\u003e 检测fd的读缓冲区 读缓冲区有数据 -\u003e epoll检测到了会给用户通知  a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了  b.用户只读了一部分数据，epoll不通知  c.缓冲区的数据读完了，不通知 提示\r\rET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死 \r\r","date":"2021-05-12","objectID":"/io_multiplexing/:4:2","tags":["multiplexingIO"],"title":"IO多路复用","uri":"/io_multiplexing/"},{"categories":["Computer Network"],"content":"Socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 ","date":"2021-04-17","objectID":"/unix_socket/:1:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序 现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码/译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。 字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 ","date":"2021-04-17","objectID":"/unix_socket/:2:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序举例 ","date":"2021-04-17","objectID":"/unix_socket/:2:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序转换 当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换） 网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。 // h - host 主机，主机字节序 // to - 转换成什么 // n - network 网络字节序 // s - short unsigned short // l - long unsigned in #include \u003carpa/inet.h\u003e// 转换端口 uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序 uint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序 // 转IP uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序 uint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序 ","date":"2021-04-17","objectID":"/unix_socket/:2:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"Socket地址 ","date":"2021-04-17","objectID":"/unix_socket/:3:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"通用Socket地址 socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下： #include \u003cbits/socket.h\u003estruct sockaddr { sa_family_t sa_family; char sa_data[14]; }; typedef unsigned short int sa_family_t; sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示: 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP/IPv4协议族 PF_INET6 AF_INET6 TCP/IPv6协议族 宏 PF_* 和 AF_* 都定义在 bits/socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用 sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示 协议族 地址值的含义和长度 PF_UNIX 文件的路径名，长度可以达到108字节 PF_INET 16bit 端口号和32bit IPv4 地址，共6字节 PF_INET6 16bit 端口号，32bit 流标识，128bit IPv6 地址，32bit范围ID,共26字节 由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的： #include \u003cbits/socket.h\u003estruct sockaddr_storage { sa_family_t sa_family; unsigned long int __ss_align; char __ss_padding[ 128 - sizeof(__ss_align) ]; }; typedef unsigned short int sa_family_t; ","date":"2021-04-17","objectID":"/unix_socket/:3:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"专用Socket地址 很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型 UNIX 本地域协议族使用如下专用的 socket 地址结构体： #include \u003csys/un.h\u003estruct sockaddr_un { sa_family_t sin_family; char sun_path[108]; }; TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6: #include \u003cnetinet/in.h\u003estruct sockaddr_in { sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */ in_port_t sin_port; /* Port number. */ struct in_addr sin_addr; /* Internet address. */ /* Pad to size of `struct sockaddr'. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; }; struct in_addr { in_addr_t s_addr; }; struct sockaddr_in6 { sa_family_t sin6_family; in_port_t sin6_port; /* Transport layer port # */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* IPv6 scope-id */ }; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef uint16_t in_port_t; typedef uint32_t in_addr_t; #define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)) 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。 ","date":"2021-04-17","objectID":"/unix_socket/:3:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"IP地址转换 通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换： #include \u003carpa/inet.h\u003ein_addr_t inet_addr(const char *cp); int inet_aton(const char *cp, struct in_addr *inp); char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址： #include \u003carpa/inet.h\u003e// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 int inet_pton(int af, const char *src, void *dst); af:地址族： AF_INET AF_INET6 src:需要转换的点分十进制的IP字符串 dst:转换后的结果保存在这个里面 // 将网络字节序的整数，转换成点分十进制的IP地址字符串 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); af:地址族： AF_INET AF_INET6 src: 要转换的ip的整数的地址 dst: 转换成IP地址字符串保存的地方 size：第三个参数的大小（数组的大小） 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 ","date":"2021-04-17","objectID":"/unix_socket/:4:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"套接字函数 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e#include \u003carpa/inet.h\u003e // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol); - 功能：创建一个套接字 - 参数： - domain: 协议族 AF_INET : ipv4 AF_INET6 : ipv6 AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信） - type: 通信过程中使用的协议类型 SOCK_STREAM : 流式协议 SOCK_DGRAM : 报式协议 - protocol : 具体的一个协议。一般写0 - SOCK_STREAM : 流式协议默认使用 TCP - SOCK_DGRAM : 报式协议默认使用 UDP - 返回值： - 成功：返回文件描述符，操作的就是内核缓冲区。 - 失败：-1 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命 名 - 功能：绑定，将fd 和本地的IP + 端口进行绑定 - 参数： - sockfd : 通过socket函数得到的文件描述符 - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息 - addrlen : 第二个参数结构体占的内存大小 int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn - 功能：监听这个socket上的连接 - 参数： - sockfd : 通过socket()函数得到的文件描述符 - backlog : 未连接的和已经连接的和的最大值， 5 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接 - 参数： - sockfd : 用于监听的文件描述符 - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port） - addrlen : 指定第二个参数的对应的内存大小 - 返回值： - 成功 ：用于通信的文件描述符 - -1 ： 失败 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); - 功能： 客户端连接服务器 - 参数： - sockfd : 用于通信的文件描述符 - addr : 客户端要连接的服务器的地址信息 - addrlen : 第二个参数的内存大小 - 返回值：成功 0， 失败 -1 ssize_t write(int fd, const void *buf, size_t count); // 写数据 ssize_t read(int fd, void *buf, size_t count); // 读数 示例如下： 服务器端 #include \u003carpa/inet.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e int main() { // 1 创建socket， 用于监听 int lfd = socket(AF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 绑定端口 struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_pton(AF_INET, \"172.25.93.158\", \u0026sockaddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr *)\u0026saddr, sizeof(saddr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 监听 ret = listen(lfd, 8); if (ret == -1) { perror(\"listen\"); exit(-1); } // 4 接受连接 struct sockaddr_in clientaddr; socklen_t len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr *)\u0026clientaddr, \u0026len); if (cfd == -1) { perror(\"accept\"); exit(-1); } // 输出客户端信息 char clientIP[16]; inet_ntop(AF_INET, \u0026clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(\"client Ip is %s, client port is %d\\n\", clientIP, clientPort); // 5 通信 // 获取客户端数据 char recvBuf[1024] = {0}; while (1) { ret = read(cfd, recvBuf, sizeof(recvBuf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"receive client data : %s\\n\", recvBuf); } else if (ret == 0) { printf(\"client closed...\\n\"); break; } // 给客户端发送数据 char sendBuf[] = \"hello I am server\"; ret = write(cfd, sendBuf, sizeof(sendBuf) - 1); if (ret == -1) { perror(\"write\"); exit(-1); } } // 6 关闭连接 close(cfd); close(lfd); return 0; } 客户端 #include \u003carpa/inet.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e int main() { // 1 创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { perror(\"socket\"); exit(-1); } // 2 连接服务器 struct sockaddr_in serverAddr; serverAddr.sin_family = PF_INET; inet_pton(AF_INET, \"172.25.93.158\", \u0026serverAddr.sin_addr.s_addr); serverAddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr *)\u0026serverAddr, sizeof(serverAddr)); if (ret == -1) { perror(\"connect\"); exit(-1); } // 3 通信 char recvBuf[1024] = {0}; while (1) { char sendBuf[] = \"hello I am client\"; ret = write(fd, sendBuf, sizeof(sendBuf) - 1); if (ret == -1) { perror(\"write\"); exit(-1); } sleep(1); ret = read(fd, recvBuf, sizeof(recvBuf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"receive server data : %s\\n\", recvBuf); } else if (ret == 0) { printf(\"server closed...\\n\"); break; } } // 4 关闭连接 close(fd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:5:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"TCP通信流程 ","date":"2021-04-17","objectID":"/unix_socket/:6:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"服务器端 （被动接受连接的角色） 创建一个用于监听的套接字 （监听：监听有客户端的连接；套接字：这个套接字其实就是一个文件描述符 ） 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）客户端连接服务器的时候使用的就是这个IP和端口 设置监听，监听的fd开始工作 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd） 通信 接收数据、发送数据 通信结束，断开 ","date":"2021-04-17","objectID":"/unix_socket/:6:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"客户端 创建一个用于通信的套接字（fd） 连接服务器，需要指定连接的服务器的 IP 和 端口 连接成功了，客户端可以直接和服务器通信 接收数据 发送数据 通信结束，断开 ","date":"2021-04-17","objectID":"/unix_socket/:6:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"多进程TCP通信 服务端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e #include \u003csignal.h\u003e#include \u003cwait.h\u003e#include \u003cerrno.h\u003e void recyleChild(int arg) { // SIGCHILD信号处理函数 // 用于回收资源 while (1) { int ret = waitpid(-1, NULL, WNOHANG); if (ret == -1) { // 所有子进程都被回收 break; } else if (ret == 0) { // 还有子进程 break; } else if (ret \u003e 0) { printf(\"子进程 %d 被回收了\\n\", ret); } } return; } int main() { // 注册信号，当子进程退出时，回收资源 struct sigaction act; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; act.sa_handler = recyleChild; sigaction(SIGCHLD, \u0026act, NULL); // 1 创建监听socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 为监听socket绑定端口 bind struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr.s_addr); int ret = bind(lfd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 开始监听 listen ret = listen(lfd, 128); if (ret == -1) { perror(\"listen\"); exit(-1); } // 4 循环等待接受请求 accept while (1) { struct sockaddr_in client_add r; socklen_t client_socket_len = sizeof(client_addr); // 这里的第三个参数要传长度的指针 int cfd = accept(lfd, (struct sockaddr *)\u0026client_addr, \u0026client_socket_len); if (cfd == -1) { // 这里为了避免因为accept被回收资源函数中断而退出程序 if(errno == EINTR) { continue; } perror(\"accept\"); exit(-1); } printf(\"client connected, clientSockedFd: %d\\n\", cfd); // 5 创建新进程 pid_t pid = fork(); if (pid == 0) { // 6 新进程与客户socket通信 char buf[1024] = {0}; while (1) { // 循环从客户端读取 ret = read(cfd, buf, sizeof(buf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"server read data: %s \\n\", buf); } else if (ret == 0) { // 读完了 printf(\"client closed...\\n\"); break; } // 向客户端写入 ret = write(cfd, buf, sizeof(buf)); if (ret == -1) { perror(\"write\"); exit(-1); } } close(cfd); exit(0); // 子进程退出 } } // 7 回收子进程资源 // 8 关闭连接 close(lfd); return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e int main() { // 1 创建socket int cfd = socket(PF_INET, SOCK_STREAM, 0); if (cfd == -1) { perror(\"socket\"); exit(-1); } // 2 建立连接 connect struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr.s_addr); // 注意要类型转换 int ret = connect(cfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); if (ret == -1) { perror(\"connect\"); exit(-1); } // 3 通信 char buf[1024] = {0}; while (1) { scanf(\"%s\", buf); write(cfd, buf, sizeof(buf)); int len = read(cfd, buf, sizeof(buf)); if (len == -1) { perror(\"read\"); exit(-1); } else if (len \u003e 0) { if (strcmp(buf, \"quit\") == 0) { printf(\"client quit... \\n\"); break; } else { printf(\"receive server data: %s\\n\", buf); } } else if (len == 0){ // 读取完了服务器断开连接 printf(\"server closed\"); break; } } // 4 关闭连接 close(cfd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:6:3","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"多线程TCP通信 服务端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003cunistd.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e struct sockInfo { // 线程号 pthread_t tid; // 通信的文件描述符 int fd; struct sockaddr_in addr; }; struct sockInfo sockinfos[128]; void* work(void * arg) { // 6 在新线程中通信 struct sockInfo* pinfo = (struct sockInfo*) arg; int cfd = pinfo-\u003efd; // 打印客户端的IP和端口 char clientIp[16]; inet_ntop(AF_INET, \u0026pinfo-\u003eaddr.sin_addr.s_addr, clientIp, sizeof(clientIp)); unsigned short clientPort = ntohs(pinfo-\u003eaddr.sin_port); printf(\"client ip is : %s, port is : %d\\n\", clientIp, clientPort); char buf[1024]; while (1) { // 循环从客户端读取 int len = read(cfd, buf, sizeof(buf)); if (len == -1) { perror(\"read\"); exit(-1); } else if (len \u003e 0) { // 接收到了数据 printf(\"server reveiced data: %s\\n\", buf); } else if (len == 0) { // 读完了，关闭连接 printf(\"client closed\\n\"); break; } // 往客户端写数据 write(pinfo-\u003efd, buf, sizeof(buf)); } close(pinfo-\u003efd); return NULL; } int main() { // 1 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 为socket绑定IP端口 bind struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026server_addr.sin_addr.s_addr); int ret = bind(lfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 开启监听 listen ret = listen(lfd, 128); if (ret == -1) { perror(\"listen\"); exit(-1); } // 初始化线程池 int max = sizeof(sockinfos) / sizeof(sockinfos[0]); for (int i = 0; i \u003c max; ++i) { bzero(\u0026sockinfos[i], sizeof(sockinfos[i])); sockinfos[i].fd = -1; sockinfos[i].tid = -1; } while (1) { // 4 循环监听 接受连接 accept struct sockaddr_in client_addr; int len = sizeof(client_addr); int cfd = accept(lfd, (struct sockaddr*)\u0026client_addr, \u0026len); if (cfd == -1) { perror(\"accept\"); exit(-1); } // 5 开启新线程 // 寻找可用线程 struct sockInfo *pinfo; for (int i = 0; i \u003c max; ++i) { if (sockinfos[i].fd == -1) { pinfo = \u0026sockinfos[i]; break; } else { // 线程池满 if (i == max - 1) { sleep(1); --i; } } } // 记录客户端文件描述符 pinfo-\u003efd = cfd; // 记录客户端地址信息 memcpy(\u0026pinfo-\u003eaddr, \u0026client_addr, sizeof(client_addr)); // 创建线程 pthread_create(\u0026pinfo-\u003etid, NULL, work, pinfo); // 分离线程 pthread_detach(pinfo-\u003etid); } // 7 关闭 close(lfd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:6:4","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"UDP通信流程 #include \u003csys/types.h\u003e#include \u003csys/socket.h\u003essize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); - 参数： - sockfd : 通信的fd - buf : 要发送的数据 - len : 发送数据的长度 - flags : 0 - dest_addr : 通信的另外一端的地址信息 - addrlen : 地址的内存大小 ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); - 参数： - sockfd : 通信的fd - buf : 接收数据的数组 - len : 数组的大小 - flags : 0 - src_addr : 用来保存另外一端的地址信息，不需要可以指定为NULL - addrlen : 地址的内存大 ","date":"2021-04-17","objectID":"/unix_socket/:7:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"服务端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003carpa/inet.h\u003e int main() { // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\"socket\"); exit(-1); } struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; // 2.绑定 int ret = bind(fd, (struct sockaddr *)\u0026addr, sizeof(addr)); if(ret == -1) { perror(\"bind\"); exit(-1); } // 3.通信 while(1) { char recvbuf[128]; char ipbuf[16]; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接收数据 int num = recvfrom(fd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr *)\u0026cliaddr, \u0026len); printf(\"client IP : %s, Port : %d\\n\", inet_ntop(AF_INET, \u0026cliaddr.sin_addr.s_addr, ipbuf, sizeof(ipbuf)), ntohs(cliaddr.sin_port)); printf(\"client say : %s\\n\", recvbuf); // 发送数据 sendto(fd, recvbuf, strlen(recvbuf) + 1, 0, (struct sockaddr *)\u0026cliaddr, sizeof(cliaddr)); } close(fd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:7:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"客户端 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003carpa/inet.h\u003e int main() { // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if(fd == -1) { perror(\"socket\"); exit(-1); } // 服务器的地址信息 struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); inet_pton(AF_INET, \"127.0.0.1\", \u0026saddr.sin_addr.s_addr); int num = 0; // 3.通信 while(1) { // 发送数据 char sendBuf[128]; sprintf(sendBuf, \"hello , i am client %d \\n\", num++); sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr *)\u0026saddr, sizeof(saddr)); // 接收数据 int num = recvfrom(fd, sendBuf, sizeof(sendBuf), 0, NULL, NULL); printf(\"server say : %s\\n\", sendBuf); sleep(1); } close(fd); return 0; } ","date":"2021-04-17","objectID":"/unix_socket/:7:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"参考 Socket原理详解 - 编程宝库 (codebaoku.com) ","date":"2021-04-17","objectID":"/unix_socket/:8:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Tools"],"content":"CMake 介绍 cmake的定义是什么 ？—–高级编译配置工具 当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！ 所有操作都是通过编译CMakeLists.txt来完成的—简单 官 方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息 学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备 ","date":"2021-04-17","objectID":"/cmake_tutorial/:1:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMake安装 1、绝大多数的linux系统已经安装了CMake 2、Windows或某些没有安装过的linux系统，去http://www.cmake.org/HTML/Download.html 可以下载安装 ","date":"2021-04-17","objectID":"/cmake_tutorial/:2:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMake一个HelloWord 1、步骤一，写一个HelloWord #main.cpp #include \u003ciostream\u003e int main(){ std::cout \u003c\u003c \"hello word\" \u003c\u003c std::endl; } 2、步骤二，写CMakeLists.txt #CMakeLists.txt PROJECT (HELLO) SET(SRC_LIST main.cpp) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \"${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) 3、步骤三、使用cmake，生成makefile文件 cmake . 输出： [root@localhost cmake]# cmake . CMake Warning (dev) in CMakeLists.txt: Syntax Warning in cmake code at /root/cmake/CMakeLists.txt:7:37 Argument not separated from preceding token by whitespace. This warning is for project developers. Use -Wno-dev to suppress it. -- The C compiler identification is GNU 10.2.1 -- The CXX compiler identification is GNU 10.2.1 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- This is BINARY dir /root/cmake -- This is SOURCE dir /root/cmake -- Configuring done -- Generating done -- Build files have been written to: /root/cmake 目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile. 4、使用make命令编译 root@localhost cmake]# make Scanning dependencies of target hello [100%] Building CXX object CMakeFiles/hello.dir/main.cpp.o Linking CXX executable hello [100%] Built target hello 5、最终生成了Hello的可执行程序 ","date":"2021-04-17","objectID":"/cmake_tutorial/:3:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMakeLists基础指令 ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"PROJECT关键字 可以用来指定工程的名字和支持的语言，默认支持所有语言 PROJECT (HELLO) 指定了工程的名字，并且支持所有语言—建议 PROJECT (HELLO CXX) 指定了工程的名字，并且支持语言是C++ PROJECT (HELLO C CXX) 指定了工程的名字，并且支持语言是C和C++ 该指定隐式定义了两个CMAKE的变量 \u003cprojectname\u003e_BINARY_DIR，本例中是 HELLO_BINARY_DIR \u003cprojectname\u003e_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译 问题：如果改了工程名，这两个变量名也会改变 解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系 ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"SET关键字 用来显示的指定变量的 SET(SRC_LIST main.cpp) SRC_LIST变量就包含了main.cpp 也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp) ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"MESSAGE关键字 向终端输出用户自定义的信息 主要包含三种信息： SEND_ERROR，产生错误，生成过程被跳过。 SATUS，输出前缀为—的信息。 FATAL_ERROR，立即终止所有 cmake 过程. ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"ADD_EXECUTABLE关键字 生成可执行文件 ADD_EXECUTABLE(hello ${SRC_LIST}) 生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容 也可以直接写 ADD_EXECUTABLE(hello main.cpp) 上述例子可以简化的写成 PROJECT(HELLO)ADD_EXECUTABLE(hello main.cpp) 注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的 ","date":"2021-04-17","objectID":"/cmake_tutorial/:4:4","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"CMakeLists语法的基本原则 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件 就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp) 指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令 ","date":"2021-04-17","objectID":"/cmake_tutorial/:5:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"语法注意事项 SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号 ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main ","date":"2021-04-17","objectID":"/cmake_tutorial/:5:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"内部构建和外部构建 上述例子就是内部构建，他生产的临时文件特别多，不方便清理 外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式 ","date":"2021-04-17","objectID":"/cmake_tutorial/:6:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"外部构建方式举例 //例子目录，CMakeLists.txt和上面例子一致 [root@localhost cmake]# pwd /root/cmake [root@localhost cmake]# ll total 8 -rw-r--r--. 1 root root 198 Dec 28 20:59 CMakeLists.txt -rw-r--r--. 1 root root 76 Dec 28 00:18 main.cpp 1、建立一个build目录，可以在任何地方，建议在当前目录下 2、进入build，运行cmake .. 当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了 3、在build目录下，运行make来构建工程 注意外部构建的两个变量 1、HELLO_SOURCE_DIR 还是工程路径 2、HELLO_BINARY_DIR 编译路径 也就是 /root/cmake/bulid ","date":"2021-04-17","objectID":"/cmake_tutorial/:6:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"一般Cmake工程结构 为工程添加一个子目录 src，用来放置工程源代码 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 在工程目录添加文本文件 COPYRIGHT, README 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 将构建后的目标文件放入构建目录的 bin 子目录 将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/ ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"将目标文件放入构建目录的 bin 子目录 每个目录下都要有一个CMakeLists.txt说明 [root@localhost cmake]# tree . ├── build ├── CMakeLists.txt └── src ├── CMakeLists.txt └── main.cpp 外层CMakeLists.txt PROJECT(HELLO)ADD_SUBDIRECTORY(src bin) src下的CMakeLists.txt ADD_EXECUTABLE(hello main.cpp) ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"ADD_SUBDIRECTORY 指令 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置 EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example ADD_SUBDIRECTORY(src bin) 将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录 如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录 ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"更改二进制的保存路径 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 思考：加载哪个CMakeLists.txt当中 技巧\r\r哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写\r\r ","date":"2021-04-17","objectID":"/cmake_tutorial/:7:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"源码编译安装 一种是从代码编译后直接 make install 安装 一种是打包时的指定 目录安装。 简单的可以这样指定目录：make install DESTDIR=/tmp/test 稍微复杂一点可以这样指定目录：./configure –prefix=/usr ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"如何安装HelloWord 使用CMAKE一个新的指令：INSTALL INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等 使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX // 目录树结构 [root@localhost cmake]# tree . ├── build ├── CMakeLists.txt ├── COPYRIGHT ├── doc │ └── hello.txt ├── README ├── runhello.sh └── src ├── CMakeLists.txt └── main.cpp 3 directories, 7 files ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装文件COPYRIGHT和README INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/) FILES：文件 DESTINATION： 1、写绝对路径 2、可以写相对路径，相对路径实际路径是： ${CMAKE_INSTALL_PREFIX}/\u003cDESTINATION 定义的路径\u003e CMAKE_INSTALL_PREFIX 默认是在 /usr/local/ cmake -DCMAKE_INSTALL_PREFIX=/usr 在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径 ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装脚本runhello.sh PROGRAMS：非目标文件的可执行程序安装(比如脚本之类) INSTALL(PROGRAMS runhello.sh DESTINATION bin) 说明：实际安装到的是 /usr/bin ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装 doc 中的 hello.txt 一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file 二、是直接在工程目录通过 INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake) DIRECTORY 后面连接的是所在 Source 目录的相对路径 注意：abc 和 abc/有很大的区别 目录名不以/结尾：这个目录将被安装为目标路径下的 目录名以/结尾：将这个目录中的内容安装到目标路径 ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:4","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装过程 cmake .. make make install ","date":"2021-04-17","objectID":"/cmake_tutorial/:8:5","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"静态库和动态库的构建 任务： １，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 ２，安装头文件与共享库。 静态库和动态库的区别 静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。 静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行 动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。 ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"构建实例 [root@localhost cmake2]# tree . ├── build ├── CMakeLists.txt └── lib ├── CMakeLists.txt ├── hello.cpp └── hello.h hello.h中的内容 #ifndef HELLO_H #define Hello_H void HelloFunc(); #endif hello.cpp中的内容 #include \"hello.h\"#include \u003ciostream\u003evoid HelloFunc(){ std::cout \u003c\u003c \"Hello World\" \u003c\u003c std::endl; } 项目中的cmake内容 PROJECT(HELLO)ADD_SUBDIRECTORY(lib bin) lib中CMakeLists.txt中的内容 SET(LIBHELLO_SRC hello.cpp)ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"ADD_LIBRARY ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so SHARED，动态库 STATIC，静态库 ${LIBHELLO_SRC} ：源文件 ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"同时构建静态和动态库 // 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已 ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"SET_TARGET_PROPERTIES 这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本 同时构建静态和动态库 SET(LIBHELLO_SRC hello.cpp)ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})//对hello_static的重名为hello SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\")//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库， // 因为，在构建 libhello.so 时， 就会清理掉 libhello.a SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})SET_TARGET_PROPERTIES(hello PROPERTIES OUTPUT_NAME \"hello\")SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:4","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"动态库的版本号 一般动态库都有一个版本号的关联 libhello.so.1.2 libhello.so -\u003elibhello.so.1 libhello.so.1-\u003elibhello.so.1.2 CMakeLists.txt 插入如下 SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION 指代动态库版本，SOVERSION 指代 API 版本。 ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:5","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"安装共享库和头文件 本例中我们将 hello 的共享库安装到\u003cprefix\u003e/lib目录， 将 hello.h 安装到\u003cprefix\u003e/include/hello 目录 //文件放到该目录下 INSTALL(FILES hello.h DESTINATION include/hello)//二进制，静态库，动态库安装都用TARGETS //ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。 INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 注意： 安装的时候，指定一下路径，放到系统下 cmake -DCMAKE_INSTALL_PREFIX=/usr .. ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:6","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"使用外部共享库和头文件 准备工作，新建一个目录来使用外部共享库和头文件 [root@MiWiFi-R4CM-srv cmake3]# tree . ├── build ├── CMakeLists.txt └── src ├── CMakeLists.txt └── main.cpp main.cpp #include \u003chello.h\u003e int main(){ HelloFunc(); } ","date":"2021-04-17","objectID":"/cmake_tutorial/:9:7","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"若干问题 ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:0","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"解决：make后头文件找不到的问题 PS：include \u003chello/hello.h\u003e 这样include是可以，这么做的话，就没啥好讲的了 关键字：INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割 在CMakeLists.txt中加入头文件搜索路径 INCLUDE_DIRECTORIES(/usr/include/hello) ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:1","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"解决：找不到引用的函数问题 报错信息：undefined reference to HelloFunc()'` 关键字：LINK_DIRECTORIES 添加非标准的共享库搜索路径 指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs) 关键字：TARGET_LINK_LIBRARIES 添加需要链接的共享库 TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。 在CMakeLists.txt中插入链接共享库，主要要插在executable的后面 查看main的链接情况 [root@MiWiFi-R4CM-srv bin]# ldd main linux-vdso.so.1 =\u003e (0x00007ffedfda4000) libhello.so =\u003e /lib64/libhello.so (0x00007f41c0d8f000) libstdc++.so.6 =\u003e /lib64/libstdc++.so.6 (0x00007f41c0874000) libm.so.6 =\u003e /lib64/libm.so.6 (0x00007f41c0572000) libgcc_s.so.1 =\u003e /lib64/libgcc_s.so.1 (0x00007f41c035c000) libc.so.6 =\u003e /lib64/libc.so.6 (0x00007f41bff8e000) /lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000) 链接静态库 TARGET_LINK_LIBRARIES(main libhello.a) ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:2","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Tools"],"content":"特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置 我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置 我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello 补充：生产debug版本的方法： cmake .. -DCMAKE_BUILD_TYPE=debug ","date":"2021-04-17","objectID":"/cmake_tutorial/:10:3","tags":["CMake"],"title":"CMake使用方法","uri":"/cmake_tutorial/"},{"categories":["Operating System"],"content":"线程概述 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP 号：ps –Lf pi ◼ 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的 一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 ◼ 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始 来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 ◼ NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。 ◼ 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION ","date":"2021-04-12","objectID":"/linux_multi_threads/:1:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"进程与线程之间的区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用 一些进程间通信方式，在进程间进行信息交换。 调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表 ","date":"2021-04-12","objectID":"/linux_multi_threads/:1:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程基本操作 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_t pthread_self(void); int pthread_equal(pthread_t t1, pthread_t t2); void pthread_exit(void *retval); int pthread_join(pthread_t thread, void **retval); int pthread_detach(pthread_t thread); int pthread_cancel(pthread_t thread); ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程创建（create） /* 一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程 称之为子线程。 程序中默认只有一个进程，fork()函数调用，2进行 程序中默认只有一个线程，pthread_create()函数调用，2个线程。 #include \u003cpthread.h\u003e int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); - 功能：创建一个子线程 - 参数： - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。 - attr : 设置线程的属性，一般使用默认值，NULL - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码 - arg : 给第三个参数使用，传参 - 返回值： 成功：0 失败：返回错误号。这个错误号和之前errno不太一样。 获取错误号的信息： char * strerror(int errnum); */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"child thread...\\n\"); printf(\"arg value: %d\\n\", *(int *)arg); return NULL; } int main() { pthread_t tid; int num = 10; // 创建一个子线程 int ret = pthread_create(\u0026tid, NULL, callback, (void *)\u0026num); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } sleep(1); return 0; // exit(0); } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程终止（exit） /* #include \u003cpthread.h\u003e void pthread_exit(void *retval); 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程 参数： retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。 pthread_t pthread_self(void); 功能：获取当前的线程的线程ID int pthread_equal(pthread_t t1, pthread_t t2); 功能：比较两个线程ID是否相等 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的 是使用结构体去实现的。 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e void * callback(void * arg) { printf(\"child thread id : %ld\\n\", pthread_self()); return NULL; // pthread_exit(NULL); } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } // 主线程 for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self()); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); printf(\"main thread exit\\n\"); return 0; // exit(0); } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:2","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程汇合（join） /* #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **retval); - 功能：和一个已经终止的线程进行连接 回收子线程的资源 这个函数是阻塞函数，调用一次只能回收一个子线程 一般在主线程中使用 - 参数： - thread：需要回收的子线程的ID - retval: 接收子线程退出时的返回值 - 返回值： 0 : 成功 非0 : 失败，返回的错误号 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e int value = 10; void * callback(void * arg) { printf(\"child thread id : %ld\\n\", pthread_self()); // sleep(3); // return NULL; // int value = 10; // 局部变量 pthread_exit((void *)\u0026value); // return (void *)\u0026value; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } // 主线程 for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self()); // 主线程调用pthread_join()回收子线程的资源 int * thread_retval; ret = pthread_join(tid, (void **)\u0026thread_retval); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } printf(\"exit data : %d\\n\", *thread_retval); printf(\"回收子线程资源成功！\\n\"); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:3","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程分离（detach） /* #include \u003cpthread.h\u003e int pthread_detach(pthread_t thread); - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 1.不能多次分离，会产生不可预料的行为。 2.不能去连接一个已经分离的线程，会报错。 - 参数：需要分离的线程的ID - 返回值： 成功：0 失败：返回错误号 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); return NULL; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); // 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if(ret != 0) { char * errstr = strerror(ret); printf(\"error2 : %s\\n\", errstr); } // 设置分离后，对分离的子线程进行连接 pthread_join() // ret = pthread_join(tid, NULL); // if(ret != 0) { // char * errstr = strerror(ret); // printf(\"error3 : %s\\n\", errstr); // } pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:4","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程取消（cancel） /* #include \u003cpthread.h\u003e int pthread_cancel(pthread_t thread); - 功能：取消线程（让线程终止） 取消某个线程，可以终止某个线程的运行， 但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); for(int i = 0; i \u003c 5; i++) { printf(\"child : %d\\n\", i); } return NULL; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 取消线程 pthread_cancel(tid); for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:5","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程属性（attr） /* int pthread_attr_init(pthread_attr_t *attr); - 初始化线程属性变量 int pthread_attr_destroy(pthread_attr_t *attr); - 释放线程属性的资源 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); - 获取线程分离的状态属性 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); - 设置线程分离的状态属性 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); return NULL; } int main() { // 创建一个线程属性变量 pthread_attr_t attr; // 初始化属性变量 pthread_attr_init(\u0026attr); // 设置属性 pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, \u0026attr, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 获取线程的栈的大小 size_t size; pthread_attr_getstacksize(\u0026attr, \u0026size); printf(\"thread stack size : %ld\\n\", size); // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); // 释放线程属性资源 pthread_attr_destroy(\u0026attr); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:6","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程同步（synchronization） ◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 ◼ 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。 ◼ 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"互斥量（锁） 互斥量基本原理 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 ◼ 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 ◼ 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 ◼ 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示： 互斥量示例 /* 互斥量的类型 pthread_mutex_t int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); - 初始化互斥量 - 参数 ： - mutex ： 需要初始化的互斥量变量 - attr ： 互斥量相关的属性，NULL - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。 pthread_mutex_t *restrict mutex = xxx; pthread_mutex_t * mutex1 = mutex; int pthread_mutex_destroy(pthread_mutex_t *mutex); - 释放互斥量的资源 int pthread_mutex_lock(pthread_mutex_t *mutex); - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待 int pthread_mutex_trylock(pthread_mutex_t *mutex); - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。 int pthread_mutex_unlock(pthread_mutex_t *mutex); - 解锁 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 全局变量，所有的线程都共享这一份资源。 int tickets = 1000; // 创建一个互斥量 pthread_mutex_t mutex; void * sellticket(void * arg) { // 卖票 while(1) { // 加锁 pthread_mutex_lock(\u0026mutex); if(tickets \u003e 0) { usleep(6000); printf(\"%ld 正在卖第 %d 张门票\\n\", pthread_self(), tickets); tickets--; }else { // 解锁 pthread_mutex_unlock(\u0026mutex); break; } // 解锁 pthread_mutex_unlock(\u0026mutex); } return NULL; } int main() { // 初始化互斥量 pthread_mutex_init(\u0026mutex, NULL); // 创建3个子线程 pthread_t tid1, tid2, tid3; pthread_create(\u0026tid1, NULL, sellticket, NULL); pthread_create(\u0026tid2, NULL, sellticket, NULL); pthread_create(\u0026tid3, NULL, sellticket, NULL); // 回收子线程的资源,阻塞 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); pthread_exit(NULL); // 退出主线程 // 释放互斥量资源 pthread_mutex_destroy(\u0026mutex); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"死锁 ◼ 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 ◼ 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁 死锁的几种场景 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 更多关于死锁的内容将在操作系统的相关理论文章中介绍，本文不再继续讨论。 死锁产生的四个必要条件 虽然进程在运行过程中，可能发生死锁，但死锁的发生必须具备一定的条件，死锁的发生必须具有以下四个必要条件。 （1）互斥条件：指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。 （2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 （3）不剥夺条件：指进程已获得的资源，在未使用之前，不能被剥夺，只能在使用完时由自己释放。 （4）循环等待条件：指在发生死锁时，必然在一个进程 – 资源的环形链，即进程集合{P0， P1， P2 …， Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，….，Pn正在等待已被 P0 占用的资源。 死锁处理方法 在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁 （1）预防死锁 ：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 （2）避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。 （3）检测和解除死锁：先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。 这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。 死锁示例 #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 创建2个互斥量 pthread_mutex_t mutex1, mutex2; void * workA(void * arg) { pthread_mutex_lock(\u0026mutex1); sleep(1); pthread_mutex_lock(\u0026mutex2); printf(\"workA....\\n\"); pthread_mutex_unlock(\u0026mutex2); pthread_mutex_unlock(\u0026mutex1); return NULL; } void * workB(void * arg) { pthread_mutex_lock(\u0026mutex2); sleep(1); pthread_mutex_lock(\u0026mutex1); printf(\"workB....\\n\"); pthread_mutex_unlock(\u0026mutex1); pthread_mutex_unlock(\u0026mutex2); return NULL; } int main() { // 初始化互斥量 pthread_mutex_init(\u0026mutex1, NULL); pthread_mutex_init(\u0026mutex2, NULL); // 创建2个子线程 pthread_t tid1, tid2; pthread_create(\u0026tid1, NULL, workA, NULL); pthread_create(\u0026tid2, NULL, workB, NULL); // 回收子线程资源 pthread_join(tid1, NULL); pthread_join(tid2, NULL); // 释放互斥量资源 pthread_mutex_destroy(\u0026mutex1); pthread_mutex_destroy(\u0026mutex2); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:2","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 ◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 ◼ 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高。 示例 /* 读写锁的类型 pthread_rwlock_t int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 案例：8个线程操作同一个全局变量。 3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 创建一个共享数据 int num = 1; // pthread_mutex_t mutex; pthread_rwlock_t rwlock; void * writeNum(void * arg) { while(1) { pthread_rwlock_wrlock(\u0026rwlock); num++; printf(\"++write, tid : %ld, num : %d\\n\", pthread_self(), num); pthread_rwlock_unlock(\u0026rwlock); usleep(100); } return NULL; } void * readNum(void * arg) { while(1) { pthread_rwlock_rdlock(\u0026rwlock); printf(\"===read, tid : %ld, num : %d\\n\", pthread_self(), num); pthread_rwlock_unlock(\u0026rwlock); usleep(100); } return NULL; } int main() { pthread_rwlock_init(\u0026rwlock, NULL); // 创建3个写线程，5个读线程 pthread_t wtids[3], rtids[5]; for(int i = 0; i \u003c 3; i++) { pthread_create(\u0026wtids[i], NULL, writeNum, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026rtids[i], NULL, readNum, NULL); } // 设置线程分离 for(int i = 0; i \u003c 3; i++) { pthread_detach(wtids[i]); } for(int i = 0; i \u003c 5; i++) { pthread_detach(rtids[i]); } pthread_exit(NULL); pthread_rwlock_destroy(\u0026rwlock); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:3","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"条件变量 互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。 条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。 两个线程操作同一临界区时，通过互斥锁保护，若A线程已经加锁，B线程再加锁时候会被阻塞，直到A释放锁，B再获得锁运行，进程B必须不停的主动获得锁、检查条件、释放锁、再获得锁、再检查、再释放，一直到满足运行的条件的时候才可以（而此过程中其他线程一直在等待该线程的结束），这种方式是比较消耗系统的资源的。而条件变量同样是阻塞，还需要通知才能唤醒，线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，该线程就休眠了，应该仍阻塞在这里，等待条件满足后被唤醒，节省了线程不断运行浪费的资源。这个过程一般用while语句实现。当线程B发现被锁定的变量不满足条件时会自动的释放锁并把自身置于等待状态，让出CPU的控制权给其它线程。其它线程 此时就有机会去进行操作，当修改完成后再通知那些由于条件不满足而陷入等待状态的线程。这是一种通知模型的同步方式，大大的节省了CPU的计算资源，减少了线程之间的竞争，而且提高了线程之间的系统工作的效率。这种同步方式就是条件变量。 示例（生产者-消费者模型） /* 条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); - 等待，调用了该函数，线程会阻塞。 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。 int pthread_cond_signal(pthread_cond_t *cond); - 唤醒一个或者多个等待的线程 int pthread_cond_broadcast(pthread_cond_t *cond); - 唤醒所有的等待的线程 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建条件变量 pthread_cond_t cond; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); // 只要生产了一个，就通知消费者消费 pthread_cond_signal(\u0026cond); pthread_mutex_unlock(\u0026mutex); usleep(100); } return NULL; } void * customer(void * arg) { while(1) { pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; // 判断是否有数据 if(head != NULL) { // 有数据 head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); usleep(100); } else { // 没有数据，需要等待 // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。 pthread_cond_wait(\u0026cond, \u0026mutex); pthread_mutex_unlock(\u0026mutex); } } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); pthread_cond_init(\u0026cond, NULL); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_cond_destroy(\u0026cond); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:4","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"信号量 信号量又称为信号灯（semaphore），其与自旋锁不同的地方是它可以引起调用者休眠，也就是信号量本质上是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放后），处于等待队列中的那个任务将被唤醒，并将获得该信号量。 信号量一个有用的特性是它可以同时允许任意数量的锁持有者，而自旋锁和互斥锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为使用者数量（usage count）或简单的叫做数量（count）。通常情况下，信号量和自旋锁一样，在一个时刻仅允许有一个锁持有者。这时计数等于1，这样的信号量被称为二值信号量或者称为互斥信号量。另一方面，初始化时也可以把数量设置为大于1的非0值。这种情况，信号量被称为计数信号量（counting semaphore），它允许在同一时刻至多有count个锁持有者。 示例（生产者-消费者模型） /* 信号量的类型 sem_t int sem_init(sem_t *sem, int pshared, unsigned int value); - 初始化信号量 - 参数： - sem : 信号量变量的地址 - pshared : 0 用在线程间 ，非0 用在进程间 - value : 信号量中的值 int sem_destroy(sem_t *sem); - 释放资源 int sem_wait(sem_t *sem); - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞 int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); - 对信号量解锁，调用一次对信号量的值+1 int sem_getvalue(sem_t *sem, int *sval); sem_t psem; sem_t csem; init(psem, 0, 8); init(csem, 0, 0); producer() { sem_wait(\u0026psem); sem_post(\u0026csem) } customer() { sem_wait(\u0026csem); sem_post(\u0026psem) } */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003csemaphore.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建两个信号量 sem_t psem; sem_t csem; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { sem_wait(\u0026psem); pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026csem); } return NULL; } void * customer(void * arg) { while(1) { sem_wait(\u0026csem); pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026psem); } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); sem_init(\u0026psem, 0, 8); sem_init(\u0026csem, 0, 0); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:5","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"多进程通信（IPC） 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变 ","date":"2021-04-10","objectID":"/ipc/:1:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"管道（PIPE） 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式， 所有的 UNIX 系统都支持这种通信机制。 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行ls和 wc。 ","date":"2021-04-10","objectID":"/ipc/:2:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用 ","date":"2021-04-10","objectID":"/ipc/:2:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"管道的读写特点 使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作） 所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。 ","date":"2021-04-10","objectID":"/ipc/:2:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* #include \u003cunistd.h\u003e int pipe(int pipefd[2]); 功能：创建一个匿名管道，用来进程间通信。 参数：int pipefd[2] 这个数组是一个传出参数。 pipefd[0] 对应的是管道的读端 pipefd[1] 对应的是管道的写端 返回值： 成功 0 失败 -1 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞 注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程） */ // 子进程发送数据给父进程，父进程读取到数据输出 #include \u003cunistd.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e int main() { // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) { perror(\"pipe\"); exit(0); } // 创建子进程 pid_t pid = fork(); if(pid \u003e 0) { // 父进程 printf(\"i am parent process, pid : %d\\n\", getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = {0}; while(1) { int len = read(pipefd[0], buf, sizeof(buf)); printf(\"parent recv : %s, pid : %d\\n\", buf, getpid()); // 向管道中写入数据 //char * str = \"hello,i am parent\"; //write(pipefd[1], str, strlen(str)); //sleep(1); } } else if(pid == 0){ // 子进程 printf(\"i am child process, pid : %d\\n\", getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = {0}; while(1) { // 向管道中写入数据 char * str = \"hello,i am child\"; write(pipefd[1], str, strlen(str)); //sleep(1); // int len = read(pipefd[0], buf, sizeof(buf)); // printf(\"child recv : %s, pid : %d\\n\", buf, getpid()); // bzero(buf, 1024); } } return 0; } ","date":"2021-04-10","objectID":"/ipc/:2:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"命名管道（Named Pipe） 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件 ","date":"2021-04-10","objectID":"/ipc/:3:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 文件定位操作。 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 ","date":"2021-04-10","objectID":"/ipc/:3:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* 创建fifo文件 1.通过命令： mkfifo 名字 2.通过函数：int mkfifo(const char *pathname, mode_t mode); #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e int mkfifo(const char *pathname, mode_t mode); 参数： - pathname: 管道名称的路径 - mode: 文件的权限 和 open 的 mode 是一样的 是一个八进制的数 返回值：成功返回0，失败返回-1，并设置错误号 */ #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e int main() { // 判断文件是否存在 int ret = access(\"fifo1\", F_OK); if(ret == -1) { printf(\"管道不存在，创建管道\\n\"); ret = mkfifo(\"fifo1\", 0664); if(ret == -1) { perror(\"mkfifo\"); exit(0); } } return 0; } ","date":"2021-04-10","objectID":"/ipc/:3:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"内存映射（Memory Map） ","date":"2021-04-10","objectID":"/ipc/:4:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功? void * ptr = mmap(...); ptr++; 可以对其进行++操作 munmap(ptr, len); // 错误,要保存地址 如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? 错误，返回MAP_FAILED open()函数中的权限建议和prot参数的权限保持一致。 如果文件偏移量为1000会怎样? 偏移量必须是4K的整数倍，返回MAP_FAILED mmap什么情况下会调用失败? 第2个参数：length = 0 第3个参数：prot 只指定了写权限 prot PROT_READ | PROT_WRITE 第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗? 可以的，但是创建的文件的大小如果为0的话，肯定不行 可以对新的文件进行扩展（lseek()，truncate()） mmap后关闭文件描述符，对mmap映射有没有影响？ int fd = open(\"XXX\"); mmap(,,,,fd,0); close(fd); 映射区还存在，创建映射区的fd被关闭，没有任何影响。 对ptr越界操作会怎样？ void * ptr = mmap(NULL, 100,,,,,); 4K 越界操作操作的是非法的内存 -\u003e 段错误 ","date":"2021-04-10","objectID":"/ipc/:4:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* #include \u003csys/mman.h\u003e void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); - 功能：将一个文件或者设备的数据映射到内存中 - 参数： - void *addr: NULL, 由内核指定 - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。 获取文件的长度：stat lseek - prot : 对申请的内存映射区的操作权限 -PROT_EXEC ：可执行的权限 -PROT_READ ：读权限 -PROT_WRITE ：写权限 -PROT_NONE ：没有权限 要操作映射内存，必须要有读的权限。 PROT_READ、PROT_READ|PROT_WRITE - flags : - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项 - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write） - fd: 需要映射的那个文件的文件描述符 - 通过open得到，open的是一个磁盘文件 - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。 prot: PROT_READ open:只读/读写 prot: PROT_READ | PROT_WRITE open:读写 - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。 - 返回值：返回创建的内存的首地址 失败返回MAP_FAILED，(void *) -1 int munmap(void *addr, size_t length); - 功能：释放内存映射 - 参数： - addr : 要释放的内存的首地址 - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。 */ /* 使用内存映射实现进程间通信： 1.有关系的进程（父子进程） - 还没有子进程的时候 - 通过唯一的父进程，先创建内存映射区 - 有了内存映射区以后，创建子进程 - 父子进程共享创建的内存映射区 2.没有关系的进程间通信 - 准备一个大小不是0的磁盘文件 - 进程1 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 进程2 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 使用内存映射区通信 注意：内存映射区通信，是非阻塞。 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cwait.h\u003e // 作业:使用内存映射实现没有关系的进程间的通信。 int main() { // 1.打开一个文件 int fd = open(\"test.txt\", O_RDWR); int size = lseek(fd, 0, SEEK_END); // 获取文件的大小 // 2.创建内存映射区 void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 3.创建子进程 pid_t pid = fork(); if(pid \u003e 0) { wait(NULL); // 父进程 char buf[64]; strcpy(buf, (char *)ptr); printf(\"read data : %s\\n\", buf); }else if(pid == 0){ // 子进程 strcpy((char *)ptr, \"nihao a, son!!!\"); } // 关闭内存映射区 munmap(ptr, size); return 0; } /* 匿名映射：不需要文件实体进程一个内存映射 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/wait.h\u003e int main() { // 1.创建匿名内存映射区 int len = 4096; void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 父子进程间通信 pid_t pid = fork(); if(pid \u003e 0) { // 父进程 strcpy((char *) ptr, \"hello, world\"); wait(NULL); }else if(pid == 0) { // 子进程 sleep(1); printf(\"%s\\n\", (char *)ptr); } // 释放内存映射区 int ret = munmap(ptr, len); if(ret == -1) { perror(\"munmap\"); exit(0); } return 0; } // 使用内存映射实现文件拷贝的功能 /* 思路： 1.对原始的文件进行内存映射 2.创建一个新文件（拓展该文件） 3.把新文件的数据映射到内存中 4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中 5.释放资源 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e int main() { // 1.对原始的文件进行内存映射 int fd = open(\"english.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); exit(0); } // 获取原始文件的大小 int len = lseek(fd, 0, SEEK_END); // 2.创建一个新文件（拓展该文件） int fd1 = open(\"cpy.txt\", O_RDWR | O_CREAT, 0664); if(fd1 == -1) { perror(\"open\"); exit(0); } // 对新创建的文件进行拓展 truncate(\"cpy.txt\", len); write(fd1, \" \", 1); // 3.分别做内存映射 void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); void * ptr1 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } if(ptr1 == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 内存拷贝 memcpy(ptr1, ptr, len); // 释放资源 munmap(ptr1, len); munmap(ptr, len); close(fd1); close(fd); return 0; } ","date":"2021-04-10","objectID":"/ipc/:4:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号（Signal） 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也 称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下： 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数 ","date":"2021-04-10","objectID":"/ipc/:5:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"使用信号的目的： 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 ","date":"2021-04-10","objectID":"/ipc/:5:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号的特点 简单 不能携带大量信息 满足某个特定条件才发送 优先级比较高 查看系统定义的信号列表：kill –l ，前 31 个信号为常规信号，其余为实时信号。 查看信号的详细信息：man 7 signal 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。 ","date":"2021-04-10","objectID":"/ipc/:5:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号示例 /* #include \u003csys/types.h\u003e #include \u003csignal.h\u003e int kill(pid_t pid, int sig); - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig - 参数： - pid ： \u003e 0 : 将信号发送给指定的进程 = 0 : 将信号发送给当前的进程组 = -1 : 将信号发送给每一个有权限接收这个信号的进程 \u003c -1 : 这个pid=某个进程组的ID取反 （-12345） - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号 kill(getppid(), 9); kill(getpid(), 9); int raise(int sig); - 功能：给当前进程发送信号 - 参数： - sig : 要发送的信号 - 返回值： - 成功 0 - 失败 非0 kill(getpid(), sig); void abort(void); - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程 kill(getpid(), SIGABRT); */ #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csignal.h\u003e#include \u003cunistd.h\u003e int main() { pid_t pid = fork(); if(pid == 0) { // 子进程 int i = 0; for(i = 0; i \u003c 5; i++) { printf(\"child process\\n\"); sleep(1); } } else if(pid \u003e 0) { // 父进程 printf(\"parent process\\n\"); sleep(2); printf(\"kill child process now\\n\"); kill(pid, SIGINT); } return 0; } /* #include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候， 函数会给当前的进程发送一个信号：SIGALARM - 参数： seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。 取消一个定时器，通过alarm(0)。 - 返回值： - 之前没有定时器，返回0 - 之前有定时器，返回之前的定时器剩余的时间 - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。 alarm(10); -\u003e 返回0 过了1秒 alarm(5); -\u003e 返回9 alarm(100) -\u003e 该函数是不阻塞的 */ #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { int seconds = alarm(5); printf(\"seconds = %d\\n\", seconds); // 0 sleep(2); seconds = alarm(2); // 不阻塞 printf(\"seconds = %d\\n\", seconds); // 3 while(1) { } return 0; } /* #include \u003csys/time.h\u003e int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时 - 参数： - which : 定时器以什么时间计时 ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用 ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF - new_value: 设置定时器的属性 struct itimerval { // 定时器的结构体 struct timeval it_interval; // 每个阶段的时间，间隔时间 struct timeval it_value; // 延迟多长时间执行定时器 }; struct timeval { // 时间的结构体 time_t tv_sec; // 秒数 suseconds_t tv_usec; // 微秒 }; 过10秒后，每个2秒定时一次 - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL - 返回值： 成功 0 失败 -1 并设置错误号 */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e // 过3秒以后，每隔2秒钟定时一次 int main() { struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026new_value, NULL); // 非阻塞的 printf(\"定时器开始了...\\n\"); if(ret == -1) { perror(\"setitimer\"); exit(0); } getchar(); return 0; } /* #include \u003csignal.h\u003e typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); - 功能：设置某个信号的捕捉行为 - 参数： - signum: 要捕捉的信号 - handler: 捕捉到信号要如何处理 - SIG_IGN ： 忽略信号 - SIG_DFL ： 使用信号默认的行为 - 回调函数 : 这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。 回调函数： - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义 - 不是程序员调用，而是当信号产生，由内核调用 - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。 - 返回值： 成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL 失败，返回SIG_ERR，设置错误号 SIGKILL SIGSTOP不能被捕捉，不能被忽略。 */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e void myalarm(int num) { printf(\"捕捉到了信号的编号是：%d\\n\", num); printf(\"xxxxxxx\\n\"); } // 过3秒以后，每隔2秒钟定时一次 int main() { // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。 signal(SIGALRM, myalarm); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026new_value, NULL); // 非阻塞的 printf(\"定时器开始了...\\n\"); if(ret == -1) { perror(\"setitimer\"); exit(0); } getchar(); return 0; } ","date":"2021-04-10","objectID":"/ipc/:5:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号集 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 ","date":"2021-04-10","objectID":"/ipc/:5:4","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号集示例 场景： 用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）\r- SIGINT信号状态被存储在第二个标志位上\r- 这个标志位的值为0， 说明信号不是未决状态\r- 这个标志位的值为1， 说明信号处于未决状态\r 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号\r- 如果想要阻塞某些信号需要用户调用系统的API\r 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 - 如果没有阻塞，这个信号就被处理\r- 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理\r /* 以下信号集相关的函数都是对自定义的信号集进行操作。 int sigemptyset(sigset_t *set); - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigfillset(sigset_t *set); - 功能：将信号集中的所有的标志位置为1 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigaddset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigdelset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置不阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigismember(const sigset_t *set, int signum); - 功能：判断某个信号是否阻塞 - 参数： - set：需要操作的信号集 - signum：需要判断的那个信号 - 返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 */ #include \u003csignal.h\u003e#include \u003cstdio.h\u003e int main() { // 创建一个信号集 sigset_t set; // 清空信号集的内容 sigemptyset(\u0026set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(\u0026set, SIGINT); if(ret == 0) { printf(\"SIGINT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGINT 阻塞\\n\"); } // 添加几个信号到信号集中 sigaddset(\u0026set, SIGINT); sigaddset(\u0026set, SIGQUIT); // 判断SIGINT是否在信号集中 ret = sigismember(\u0026set, SIGINT); if(ret == 0) { printf(\"SIGINT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGINT 阻塞\\n\"); } // 判断SIGQUIT是否在信号集中 ret = sigismember(\u0026set, SIGQUIT); if(ret == 0) { printf(\"SIGQUIT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGQUIT 阻塞\\n\"); } // 从信号集中删除一个信号 sigdelset(\u0026set, SIGQUIT); // 判断SIGQUIT是否在信号集中 ret = sigismember(\u0026set, SIGQUIT); if(ret == 0) { printf(\"SIGQUIT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGQUIT 阻塞\\n\"); } return 0; } /* int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换） - 参数： - how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， mask | set SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞 mask \u0026= ~set SIG_SETMASK:覆盖内核中原来的值 - set ：已经初始化好的用户自定义的信号集 - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL - 返回值： 成功：0 失败：-1 设置错误号：EFAULT、EINVAL int sigpending(sigset_t *set); - 功能：获取内核中的未决信号集 - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。 */ // 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕 // 设置某些信号是阻塞的，通过键盘产生这些信号 #include \u003cstdio.h\u003e#include \u003csignal.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e int main() { // 设置2、3号信号阻塞 sigset_t set; sigemptyset(\u0026set); // 将2号和3号信号添加到信号集中 sigaddset(\u0026set, SIGINT); sigaddset(\u0026set, SIGQUIT); // 修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, \u0026set, NULL); int num = 0; while(1) { num++; // 获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(\u0026pendingset); sigpending(\u0026pendingset); // 遍历前32位 for(int i = 1; i \u003c= 31; i++) { if(sigismember(\u0026pendingset, i) == 1) { printf(\"1\"); }else if(sigismember(\u0026pendingset, i) == 0) { printf(\"0\"); }else { perror(\"sigismember\"); exit(0); } } printf(\"\\n\"); sleep(1); if(num == 10) { // 解除阻塞 sigprocmask(SIG_UNBLOCK, \u0026set, NULL); } } return 0; } /* #include \u003csignal.h\u003e int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); - 功能：检查或者改变信号的处理。信号捕捉 - 参数： - signum : 需要捕捉的信号的编号或者宏值（信号的名称） - act ：捕捉到信号之后的处理动作 - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL - 返回值： 成功 0 失败 -1 struct sigaction { // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void); }; */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e void myalarm(int num) { printf(\"捕捉到了信号的编号是：%d\\n\", num); printf(\"xxxxxxx\\n\"); } // 过3秒以后，每隔2秒钟定时一次 int main() { struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; sigemptyset(\u0026act.sa_mask); // 清空临时阻塞信号集 // 注册信号捕捉 sigaction(SIGALRM, \u0026act, NULL); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_i","date":"2021-04-10","objectID":"/ipc/:5:5","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"共享内存（Shared Memory） 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 ◼ 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 ◼ 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 ◼ 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 ◼ 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步 ipcs 用法 ipcs -a // 打印当前系统中所有的进程间通信方式的信息 ipcs -m // 打印出使用共享内存进行进程间通信的信息 ipcs -q // 打印出使用消息队列进行进程间通信的信息 ipcs -s // 打印出使用信号进行进程间通信的信息 ipcrm 用法 ipcrm -M shmkey // 移除用shmkey创建的共享内存段 ipcrm -m shmid // 移除用shmid标识的共享内存段 ipcrm -Q msgkey // 移除用msqkey创建的消息队列 ipcrm -q msqid // 移除用msqid标识的消息队列 ipcrm -S semkey // 移除用semkey创建的信号 ipcrm -s semid // 移除用semid标识的信号 ","date":"2021-04-10","objectID":"/ipc/:6:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"问题 操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch，shm_nattach 记录了关联的进程个数 可不可以对共享内存进行多次删除 shmctl 可以的，因为shmctl 标记删除共享内存，不是直接删除，当和共享内存关联的进程数为0的时候，就真正被删除，当共享内存的key为0的时候，表示共享内存被标记删除了，如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 ","date":"2021-04-10","objectID":"/ipc/:6:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效率更高 共享内存方式所有的进程操作的是同一块共享内存。而内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全：当进程突然退出，共享内存还存在，而内存映射区消失；当运行进程的电脑死机，宕机了，数据存在在共享内存中，没有了，而内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期：内存映射区：进程退出，内存映射区销毁；共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机，如果一个进程退出，会自动和共享内存进行取消关联。 ","date":"2021-04-10","objectID":"/ipc/:6:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 共享内存相关的函数 #include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e int shmget(key_t key, size_t size, int shmflg); - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 新创建的内存段中的数据都会被初始化为0 - 参数： - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 一般使用16进制表示，非0值 - size: 共享内存的大小 - shmflg: 属性 - 访问权限 - 附加属性：创建/判断共享内存是不是存在 - 创建：IPC_CREAT - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值： 失败：-1 并设置错误号 成功：\u003e0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。 void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能：和当前的进程进行关联 - 参数： - shmid : 共享内存的标识（ID）,由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 - shmflg : 对共享内存的操作 - 读 ： SHM_RDONLY, 必须要有读权限 - 读写： 0 - 返回值： 成功：返回共享内存的首（起始）地址。 失败(void *) -1 int shmdt(const void *shmaddr); - 功能：解除当前进程和共享内存的关联 - 参数： shmaddr：共享内存的首地址 - 返回值：成功 0， 失败 -1 int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。 - 参数： - shmid: 共享内存的ID - cmd : 要做的操作 - IPC_STAT : 获取共享内存的当前的状态 - IPC_SET : 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf：需要设置或者获取的共享内存的属性信息 - IPC_STAT : buf存储数据 - IPC_SET : buf中需要初始化数据，设置到内核中 - IPC_RMID : 没有用，NULL key_t ftok(const char *pathname, int proj_id); - 功能：根据指定的路径名，和int值，生成一个共享内存的key - 参数： - pathname:指定一个存在的路径 /home/nowcoder/Linux/a.txt / - proj_id: int类型的值，但是这系统调区销毁 - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 #include \u003cstdio.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e#include \u003cstring.h\u003e int main() { // 1.获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(\"shmid : %d\\n\", shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); // 3.读数据 printf(\"%s\\n\", (char *)ptr); printf(\"按任意键继续\\n\"); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0; } #include \u003cstdio.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e#include \u003cstring.h\u003e int main() { // 1.创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT|0664); printf(\"shmid : %d\\n\", shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); char * str = \"helloworld\"; // 3.写数据 memcpy(ptr, str, strlen(str) + 1); printf(\"按任意键继续\\n\"); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0; } ","date":"2021-04-10","objectID":"/ipc/:6:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号量（Semaphore Array） ","date":"2021-04-10","objectID":"/ipc/:7:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"套接字（Socke） ","date":"2021-04-10","objectID":"/ipc/:8:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"本地套接字 本地套接字的作用：本地的进程间通信, 适用于有关系的进程间的通信和没有关系的进程间的通信 本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流 // 本地套接字通信的流程 - tcp // 服务器端 1. 创建监听的套接字 int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); 2. 监听的套接字绑定本地的套接字文件 -\u003e server端 struct sockaddr_un addr; // 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 bind(lfd, addr, len); 3. 监听 listen(lfd, 100); 4. 等待并接受连接请求 struct sockaddr_un cliaddr; int cfd = accept(lfd, \u0026cliaddr, len); 5. 通信 接收数据：read/recv 发送数据：write/send 6. 关闭连接 close(); // 客户端的流程 1. 创建通信的套接字 int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); 2. 监听的套接字绑定本地的IP 端口 struct sockaddr_un addr; // 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 bind(lfd, addr, len); 3. 连接服务器 struct sockaddr_un serveraddr; connect(fd, \u0026serveraddr, sizeof(serveraddr)); 4. 通信 接收数据：read/recv 发送数据：write/send 5. 关闭连接 close(); // 头文件: sys/un.h #define UNIX_PATH_MAX 108 struct sockaddr_un { sa_family_t sun_family; // 地址族协议 af_local char sun_path[UNIX_PATH_MAX]; // 套接字文件的路径, 这是一个伪文件, 大小永远=0 }; 服务端 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/un.h\u003e int main() { unlink(\"server.sock\"); // 1.创建监听的套接字 int lfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(lfd == -1) { perror(\"socket\"); exit(-1); } // 2.绑定本地套接字文件 struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, \"server.sock\"); int ret = bind(lfd, (struct sockaddr *)\u0026addr, sizeof(addr)); if(ret == -1) { perror(\"bind\"); exit(-1); } // 3.监听 ret = listen(lfd, 100); if(ret == -1) { perror(\"listen\"); exit(-1); } // 4.等待客户端连接 struct sockaddr_un cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)\u0026cliaddr, \u0026len); if(cfd == -1) { perror(\"accept\"); exit(-1); } printf(\"client socket filename: %s\\n\", cliaddr.sun_path); // 5.通信 while(1) { char buf[128]; int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) { perror(\"recv\"); exit(-1); } else if(len == 0) { printf(\"client closed....\\n\"); break; } else if(len \u003e 0) { printf(\"client say : %s\\n\", buf); send(cfd, buf, len, 0); } } close(cfd); close(lfd); return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/un.h\u003e int main() { unlink(\"client.sock\"); // 1.创建套接字 int cfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(cfd == -1) { perror(\"socket\"); exit(-1); } // 2.绑定本地套接字文件 struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, \"client.sock\"); int ret = bind(cfd, (struct sockaddr *)\u0026addr, sizeof(addr)); if(ret == -1) { perror(\"bind\"); exit(-1); } // 3.连接服务器 struct sockaddr_un seraddr; seraddr.sun_family = AF_LOCAL; strcpy(seraddr.sun_path, \"server.sock\"); ret = connect(cfd, (struct sockaddr *)\u0026seraddr, sizeof(seraddr)); if(ret == -1) { perror(\"connect\"); exit(-1); } // 4.通信 int num = 0; while(1) { // 发送数据 char buf[128]; sprintf(buf, \"hello, i am client %d\\n\", num++); send(cfd, buf, strlen(buf) + 1, 0); printf(\"client say : %s\\n\", buf); // 接收数据 int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) { perror(\"recv\"); exit(-1); } else if(len == 0) { printf(\"server closed....\\n\"); break; } else if(len \u003e 0) { printf(\"server say : %s\\n\", buf); } sleep(1); } close(cfd); return 0; } ","date":"2021-04-10","objectID":"/ipc/:8:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"远程过程调用（RPC, Remote Procedure Call） ","date":"2021-04-10","objectID":"/ipc/:9:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["C/C++"],"content":" 本文介绍文件IO与标准IO的相关概念，以及一些常用的文件IO函数 ","date":"2021-04-08","objectID":"/fileio/:0:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"基本概念 文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。 标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。 （1）全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 （2）行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 （3）不带缓存：stderr就是了。 ","date":"2021-04-08","objectID":"/fileio/:1:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"原理 文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。（Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。  ","date":"2021-04-08","objectID":"/fileio/:2:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"栈与堆的扩展方向 早期的微弱优势 早期的系统需要考虑有限内存下的内存布局问题。具体来说，内存的一端放置了静态代码和静态数据之后，剩余的区域，既需要动态数据，又需要可增长的栈，那么合理的方案就是各放一端向中间生长。现在的问题就是两个选项：静态内存放在哪端；栈是在静态内存的同端还是对端。 考虑下面的一些条件： 早期的部分机器，从0地址启动[1]。想象一下磁带机的编址。 动态数据从概念上来说，和静态数据比较像 所以从内存布局来说，一个自然的方案是，从0地址依次放置代码、静态数据、动态数据，高地址放置栈。 但是，从安全性来说，向低地址扩展也有微弱劣势： 数组、字符串越界时会覆盖过去栈帧的数据，黑客更容易找到缓冲区溢出攻击的漏洞 历史的实际情况 大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。 主流1：向低地址扩展：x86，MIPS 主流2：自由选择：Arm（但个别指令仅支持向低） 罕见：向高地址扩展：PA-RISC，操作系统Multics 非主流：System z，栈是个链表[2] 如果CPU同时支持向上和向下，例如arm，那么编译器需要指定程序的调用方向，一般还是选择向下。比较罕见的极端的案例是Multics操作系统，这是Unix的巨无霸前身，设计者刻意选用向高地址扩展，因为该架构有助于防御缓冲区溢出攻击[3]。 现代的情况 现代程序的下列特征，导致内存布局问题中的单个栈增长方向无所谓。 使用线性虚拟地址，进程空间为4G或者更高 现代程序写法，栈的大小1M左右已经足够使用。编译器一般都直接限制栈的大小 多线程导致有多个栈，所以堆-栈的两端分割模式是不合适的，每个栈应当有界 引用 作者：刘源 链接：https://www.zhihu.com/question/29520755/answer/373320074 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-04-08","objectID":"/fileio/:2:1","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"open /* #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e // 打开一个已经存在的文件 int open(const char *pathname, int flags); 参数： - pathname：要打开的文件路径 - flags：对文件的操作权限设置还有其他的设置 O_RDONLY, O_WRONLY, O_RDWR 这三个设置是互斥的 返回值：返回一个新的文件描述符，如果调用失败，返回-1 errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。 #include \u003cstdio.h\u003e void perror(const char *s);作用：打印errno对应的错误描述 s参数：用户描述，比如hello,最终输出的内容是 hello:xxx(实际的错误描述) // 创建一个新的文件 int open(const char *pathname, int flags, mode_t mode); 参数： - pathname：要创建的文件的路径 - flags：对文件的操作权限和其他的设置 - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个之间是互斥的 - 可选项：O_CREAT 文件不存在，创建新文件 - mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775 最终的权限是：mode \u0026 ~umask 0777 -\u003e 111111111 \u0026 0775 -\u003e 111111101 ---------------------------- 111111101 按位与：0和任何数都为0 umask的作用就是抹去某些权限。 flags参数是一个int类型的数据，占4个字节，32位。 flags 32个位，每一位就是一个标志位。 */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { // 打开一个文件 int fd = open(\"a.txt\", O_RDONLY); if(fd == -1) { perror(\"open\"); } // 读写操作 // 关闭 close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:3:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"read \u0026 write /* #include \u003cunistd.h\u003e ssize_t read(int fd, void *buf, size_t count); 参数： - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件 - buf：需要读取数据存放的地方，数组的地址（传出参数） - count：指定的数组的大小 返回值： - 成功： \u003e0: 返回实际的读取到的字节数 =0：文件已经读取完了 - 失败：-1 ，并且设置errno #include \u003cunistd.h\u003e ssize_t write(int fd, const void *buf, size_t count); 参数： - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件 - buf：要往磁盘写入的数据，数据 - count：要写的数据的实际的大小 返回值： 成功：实际写入的字节数 失败：返回-1，并设置errno */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e int main() { // 1.通过open打开english.txt文件 int srcfd = open(\"english.txt\", O_RDONLY); if(srcfd == -1) { perror(\"open\"); return -1; } // 2.创建一个新的文件（拷贝文件） int destfd = open(\"cpy.txt\", O_WRONLY | O_CREAT, 0664); if(destfd == -1) { perror(\"open\"); return -1; } // 3.频繁的读写操作 char buf[1024] = {0}; int len = 0; while((len = read(srcfd, buf, sizeof(buf))) \u003e 0) { write(destfd, buf, len); } // 4.关闭文件 close(destfd); close(srcfd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:4:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"lseek /* 标准C库的函数 #include \u003cstdio.h\u003e int fseek(FILE *stream, long offset, int whence); Linux系统函数 #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e off_t lseek(int fd, off_t offset, int whence); 参数： - fd：文件描述符，通过open得到的，通过这个fd操作某个文件 - offset：偏移量 - whence: SEEK_SET 设置文件指针的偏移量 SEEK_CUR 设置偏移量：当前位置 + 第二个参数offset的值 SEEK_END 设置偏移量：文件大小 + 第二个参数offset的值 返回值：返回文件指针的位置 作用： 1.移动文件指针到文件头 lseek(fd, 0, SEEK_SET); 2.获取当前文件指针的位置 lseek(fd, 0, SEEK_CUR); 3.获取文件长度 lseek(fd, 0, SEEK_END); 4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节 lseek(fd, 100, SEEK_END) 注意：需要写一次数据 */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int fd = open(\"hello.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); return -1; } // 扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if(ret == -1) { perror(\"lseek\"); return -1; } // 写入一个空数据 write(fd, \" \", 1); // 关闭文件 close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:5:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"stat /* #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cunistd.h\u003e int stat(const char *pathname, struct stat *statbuf); 作用：获取一个文件相关的一些信息 参数: - pathname：操作的文件的路径 - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息 返回值： 成功：返回0 失败：返回-1 设置errno int lstat(const char *pathname, struct stat *statbuf); 参数: - pathname：操作的文件的路径 - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息 返回值： 成功：返回0 失败：返回-1 设置errno */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { struct stat statbuf; int ret = stat(\"a.txt\", \u0026statbuf); if(ret == -1) { perror(\"stat\"); return -1; } printf(\"size: %ld\\n\", statbuf.st_size); return 0; }access ","date":"2021-04-08","objectID":"/fileio/:6:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"access /* #include \u003cunistd.h\u003e int access(const char *pathname, int mode); 作用：判断某个文件是否有某个权限，或者判断文件是否存在 参数： - pathname: 判断的文件路径 - mode: R_OK: 判断是否有读权限 W_OK: 判断是否有写权限 X_OK: 判断是否有执行权限 F_OK: 判断文件是否存在 返回值：成功返回0， 失败返回-1 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int ret = access(\"a.txt\", F_OK); if(ret == -1) { perror(\"access\"); } printf(\"文件存在！！!\\n\"); return 0; } ","date":"2021-04-08","objectID":"/fileio/:7:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"chmod /* #include \u003csys/stat.h\u003e int chmod(const char *pathname, mode_t mode); 修改文件的权限 参数： - pathname: 需要修改的文件的路径 - mode:需要修改的权限值，八进制的数 返回值：成功返回0，失败返回-1 */ #include \u003csys/stat.h\u003e#include \u003cstdio.h\u003eint main() { int ret = chmod(\"a.txt\", 0777); if(ret == -1) { perror(\"chmod\"); return -1; } return 0; } ","date":"2021-04-08","objectID":"/fileio/:8:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"truncate /* #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int truncate(const char *path, off_t length); 作用：缩减或者扩展文件的尺寸至指定的大小 参数： - path: 需要修改的文件的路径 - length: 需要最终文件变成的大小 返回值： 成功返回0， 失败返回-1 */ #include \u003cunistd.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e int main() { int ret = truncate(\"b.txt\", 5); if(ret == -1) { perror(\"truncate\"); return -1; } return 0; }  ","date":"2021-04-08","objectID":"/fileio/:9:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"chdir \u0026 getcwd /* #include \u003cunistd.h\u003e int chdir(const char *path); 作用：修改进程的工作目录 比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder 参数： path : 需要修改的工作目录 #include \u003cunistd.h\u003e char *getcwd(char *buf, size_t size); 作用：获取当前工作目录 参数： - buf : 存储的路径，指向的是一个数组（传出参数） - size: 数组的大小 返回值： 返回的指向的一块内存，这个数据就是第一个参数 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cfcntl.h\u003e int main() { // 获取当前的工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(\"当前的工作目录是：%s\\n\", buf); // 修改工作目录 int ret = chdir(\"/home/nowcoder/Linux/lesson13\"); if(ret == -1) { perror(\"chdir\"); return -1; } // 创建一个新的文件 int fd = open(\"chdir.txt\", O_CREAT | O_RDWR, 0664); if(fd == -1) { perror(\"open\"); return -1; } close(fd); // 获取当前的工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(\"当前的工作目录是：%s\\n\", buf1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:10:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"mkdir /* #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e int mkdir(const char *pathname, mode_t mode); 作用：创建一个目录 参数： pathname: 创建的目录的路径 mode: 权限，八进制的数 返回值： 成功返回0， 失败返回-1 */ #include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e int main() { int ret = mkdir(\"aaa\", 0777); if(ret == -1) { perror(\"mkdir\"); return -1; } return 0; } ","date":"2021-04-08","objectID":"/fileio/:11:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"opendir \u0026 readdir \u0026 closedir /* // 打开一个目录 #include \u003csys/types.h\u003e #include \u003cdirent.h\u003e DIR *opendir(const char *name); 参数： - name: 需要打开的目录的名称 返回值： DIR * 类型，理解为目录流 错误返回NULL // 读取目录中的数据 #include \u003cdirent.h\u003e struct dirent *readdir(DIR *dirp); - 参数：dirp是opendir返回的结果 - 返回值： struct dirent，代表读取到的文件的信息 读取到了末尾或者失败了，返回NULL // 关闭目录 #include \u003csys/types.h\u003e #include \u003cdirent.h\u003e int closedir(DIR *dirp); */ #include \u003csys/types.h\u003e#include \u003cdirent.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e int getFileNum(const char * path); // 读取某个目录下所有的普通文件的个数 int main(int argc, char * argv[]) { if(argc \u003c 2) { printf(\"%s path\\n\", argv[0]); return -1; } int num = getFileNum(argv[1]); printf(\"普通文件的个数为：%d\\n\", num); return 0; } // 用于获取目录下所有普通文件的个数 int getFileNum(const char * path) { // 1.打开目录 DIR * dir = opendir(path); if(dir == NULL) { perror(\"opendir\"); exit(0); } struct dirent *ptr; // 记录普通文件的个数 int total = 0; while((ptr = readdir(dir)) != NULL) { // 获取名称 char * dname = ptr-\u003ed_name; // 忽略掉. 和.. if(strcmp(dname, \".\") == 0 || strcmp(dname, \"..\") == 0) { continue; } // 判断是否是普通文件还是目录 if(ptr-\u003ed_type == DT_DIR) { // 目录,需要继续读取这个目录 char newpath[256]; sprintf(newpath, \"%s/%s\", path, dname); total += getFileNum(newpath); } if(ptr-\u003ed_type == DT_REG) { // 普通文件 total++; } } // 关闭目录 closedir(dir); return total; } ","date":"2021-04-08","objectID":"/fileio/:12:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"dup /* #include \u003cunistd.h\u003e int dup(int oldfd); 作用：复制一个新的文件描述符 fd=3, int fd1 = dup(fd), fd指向的是a.txt, fd1也是指向a.txt 从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstring.h\u003e int main() { int fd = open(\"a.txt\", O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if(fd1 == -1) { perror(\"dup\"); return -1; } printf(\"fd : %d , fd1 : %d\\n\", fd, fd1); close(fd); char * str = \"hello,world\"; int ret = write(fd1, str, strlen(str)); if(ret == -1) { perror(\"write\"); return -1; } close(fd1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:13:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"dup2 /* #include \u003cunistd.h\u003e int dup2(int oldfd, int newfd); 作用：重定向文件描述符 oldfd 指向 a.txt, newfd 指向 b.txt 调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt oldfd 必须是一个有效的文件描述符 oldfd和newfd值相同，相当于什么都没有做 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cfcntl.h\u003e int main() { int fd = open(\"1.txt\", O_RDWR | O_CREAT, 0664); if(fd == -1) { perror(\"open\"); return -1; } int fd1 = open(\"2.txt\", O_RDWR | O_CREAT, 0664); if(fd1 == -1) { perror(\"open\"); return -1; } printf(\"fd : %d, fd1 : %d\\n\", fd, fd1); int fd2 = dup2(fd, fd1); if(fd2 == -1) { perror(\"dup2\"); return -1; } // 通过fd1去写数据，实际操作的是1.txt，而不是2.txt char * str = \"hello, dup2\"; int len = write(fd1, str, strlen(str)); if(len == -1) { perror(\"write\"); return -1; } printf(\"fd : %d, fd1 : %d, fd2 : %d\\n\", fd, fd1, fd2); close(fd); close(fd1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:14:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"fcntl /* #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, ...); 参数： fd : 表示需要操作的文件描述符 cmd: 表示对文件描述符进行如何操作 - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值） int ret = fcntl(fd, F_DUPFD); - F_GETFL : 获取指定的文件描述符文件状态flag 获取的flag和我们通过open函数传递的flag是一个东西。 - F_SETFL : 设置文件描述符文件状态flag 必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改 可选性：O_APPEND, O)NONBLOCK O_APPEND 表示追加数据 NONBLOK 设置成非阻塞 阻塞和非阻塞：描述的是函数调用的行为。 */ #include \u003cunistd.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e int main() { // 1.复制文件描述符 // int fd = open(\"1.txt\", O_RDONLY); // int ret = fcntl(fd, F_DUPFD); // 2.修改或者获取文件状态flag int fd = open(\"1.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); return -1; } // 获取文件描述符状态flag int flag = fcntl(fd, F_GETFL); if(flag == -1) { perror(\"fcntl\"); return -1; } flag |= O_APPEND; // flag = flag | O_APPEND // 修改文件描述符状态的flag，给flag加入O_APPEND这个标记 int ret = fcntl(fd, F_SETFL, flag); if(ret == -1) { perror(\"fcntl\"); return -1; } char * str = \"nihao\"; write(fd, str, strlen(str)); close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:15:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["Tools"],"content":" GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境 GDB调试的三种方式： 目标板直接使用GDB进行调试。 目标板使用gdbserver，主机使用xxx-linux-gdb作为客户端。 目标板使用ulimit -c unlimited，生成core文件；然后主机使用xxx-linux-gdb ./test ./core。 ","date":"2021-04-07","objectID":"/gdb/:0:0","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"GDB 调试 构造测试程序如下main.c和sum.c如下: // main.c: #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e extern int sum(int value); struct inout { int value; int result; }; int main(int argc, char * argv[]) { struct inout * io = (struct inout * ) malloc(sizeof(struct inout)); if (NULL == io) { printf(\"Malloc failed.\\n\"); return -1; } if (argc != 2) { printf(\"Wrong para!\\n\"); return -1; } io -\u003e value = *argv[1] - '0'; io -\u003e result = sum(io -\u003e value); printf(\"Your enter: %d, result:%d\\n\", io -\u003e value, io -\u003e result); return 0; } // sum.c: int sum(int value) { int result = 0; int i = 0; for (i = 0; i \u003c value; i++) result += (i + 1); return result; } 然后gcc main.c sum.c -o main -g, 得到main可执行文件， 输入gdb main可进入调试. 下面介绍了gdb大部分功能，1.1 设置断点以及 1.3显示栈帧是常用功能；调试过程中可以需要1.6 单步执行，并且1.4 显示变量、1.5显示寄存器、1.8 监视点、1.9 改变变量的值。 如果进程已经运行中，需要1.11 attach到进程，或者1.10 生成转储文件进行分析。当然为了提高效率可以自定义1.13 初始化文件。 ","date":"2021-04-07","objectID":"/gdb/:1:0","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"设置断点* 设置断点可以通过b或者break设置断点，断点的设置可以通过函数名、行号、文件名+函数名、文件名+行号以及偏移量、地址等进行设置。 格式为： break 函数名 break 行号 break 文件名:函数名 break 文件名:行号 break +偏移量 break -偏移量 break *地址 查看断点，通过info break查看断点列表。 (gdb) b 13 Breakpoint 1 at 0x11aa: file main.c, line 13. (gdb) b sum.c:2 Breakpoint 2 at 0x123d: file sum.c, line 2. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000000011aa in main at main.c:13 2 breakpoint keep y 0x000000000000123d in sum at sum.c:2 删除断点通过命令包括： delete \u003c断点id\u003e：删除指定断点 delete：删除所有断点 clear clear 函数名 clear 行号 clear 文件名：行号 clear 文件名：函数名 断点还可以条件断住 break 断点 if 条件；比如break sum if value==9，当输入的value为9的时候才会断住。 condition 断点编号：给指定断点删除触发条件 condition 断点编号 条件：给指定断点添加触发条件 断点还可以通过disable/enable临时停用启用。 disable disable 断点编号 disable display 显示编号 disable mem 内存区域 enable enable 断点编号 enable once 断点编号：该断点只启用一次，程序运行到该断点并暂停后，该断点即被禁用。 enable delete 断点编号 enable display 显示编号 enable mem 内存区域 断点commands高级功能 大多数时候需要在断点处执行一系列动作，gdb提供了在断点处执行命令的高级功能commands。 #include \u003cstdio.h\u003e int total = 0; int square(int i) { int result=0; result = i*i; return result; } int main(int argc, char **argv) { int i; for(i=0; i\u003c10; i++) { total += square(i); } return 0; } 比如需要对如上程序square参数i为5的时候断点，并在此时打印栈、局部变量以及total的值 编写gdb.init如下： set logging on gdb.log b square if i == 5 commands bt full i locals p total print \"Hit break when i == 5\" end 在gdb shell中source gdb.init，然后r执行命令，结果如下： (gdb) source gdb.init Breakpoint 1 at 0x1129: file commands.c, line 6. (gdb) r Starting program: /home/lwy/workspace/gdbtest/commands Breakpoint 1, square (i=5) at commands.c:6 6 { #0 square (i=5) at commands.c:6 result = 25 #1 0x000055555555516f in main (argc=1, argv=0x7fffffffe048) at commands.c:20 i = 6 result = 25 $1 = 55 $2 = \"Hit break when i == 5\" 可以看出断点在i==5的时候断住了，并且此时打印了正确的值。 ","date":"2021-04-07","objectID":"/gdb/:1:1","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"运行 “gdb 命令”之后，run可以在gdb下运行命令；如果命令需要参数则跟在run之后。 (gdb) run 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Your enter: 9, result:45 [Inferior 1 (process 12362) exited normally] 如果需要断点在main()处，直接执行start就可以。 (gdb) start Temporary breakpoint 1 at 0x555555555189: file main.c, line 11. Starting program: /home/lwy/workspace/gdbtest/main 9 Temporary breakpoint 1, main (argc=21845, argv=0x0) at main.c:11 ","date":"2021-04-07","objectID":"/gdb/:1:2","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示栈帧* 如果遇到断点而暂停执行，或者coredump可以显示栈帧。 通过bt可以显示栈帧，bt full可以显示局部变量。 (gdb) r 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Breakpoint 2, sum (value=9) at sum.c:3 3 int i = 0; (gdb) bt #0 sum (value=9) at sum.c:3 #1 0x0000555555555204 in main (argc=2, argv=0x7fffffffe048) at main.c:24 (gdb) bt full #0 sum (value=9) at sum.c:3 result = 0 i = 32767 #1 0x0000555555555204 in main (argc=2, argv=0x7fffffffe048) at main.c:24 io = 0x5555555592a0 命令格式如下： bt bt full：不仅显示backtrace，还显示局部变量 bt N：显示开头N个栈帧 bt full N ","date":"2021-04-07","objectID":"/gdb/:1:3","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示变量* print 变量名可以显示变量内容。 ptype 变量名 可以打印变量类型 如果需要一行监控多个变量，可以通过p {var1, var2, var3}。 如果要跟踪自动显示，可以使用display {var1, var2, var3} 取消跟踪用 undisplay 编号 查看文件代码：list/l [文件名:][行号/函数名] 设置显示的行数：show list/listsize , set list/listsize 行数 ","date":"2021-04-07","objectID":"/gdb/:1:4","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示寄存器* info reg可以显示寄存器内容。 (gdb) i r rax 0x9 9 rbx 0x555555555270 93824992236144 rcx 0x5555555592b0 93824992252592 rdx 0x9 9 rsi 0x0 0 rdi 0x9 9 rbp 0x7fffffffdf20 0x7fffffffdf20 rsp 0x7fffffffdf20 0x7fffffffdf20 r8 0x5555555592a0 93824992252576 r9 0x7ffff7dd1070 140737351848048 r10 0x7ffff7fb9be0 140737353849824 r11 0x7ffff7fb9be0 140737353849824 r12 0x5555555550a0 93824992235680 r13 0x7fffffffe040 140737488347200 r14 0x0 0 r15 0x0 0 rip 0x55555555524b 0x55555555524b \u003csum+25\u003e eflags 0x216 [ PF AF IF ] cs 0x33 51 ss 0x2b 43 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 在寄存器名之前加$可以显示寄存器内容， p $寄存器：显示寄存器内容 p/x $寄存器：十六进制显示寄存器内容。 (gdb) p $ss $2 = 43 (gdb) p/x $pc $3 = 0x55555555524b 用x命令可以显示内容内容，x/格式 地址。 x $pc：显示程序指针内容 x/i $pc：显示程序指针汇编。 x/10i $pc：显示程序指针之后10条指令。 x/128wx 0xfc207000：从0xfc20700开始以16进制打印128个word。 (gdb) x $pc 0x55555555524b \u003csum+25\u003e: 0x00fc45c7 (gdb) x/i $pc =\u003e 0x55555555524b \u003csum+25\u003e: movl $0x0,-0x4(%rbp) (gdb) x/10i $pc =\u003e 0x55555555524b \u003csum+25\u003e: movl $0x0,-0x4(%rbp) 0x555555555252 \u003csum+32\u003e: jmp 0x555555555261 \u003csum+47\u003e 0x555555555254 \u003csum+34\u003e: mov -0x4(%rbp),%eax 0x555555555257 \u003csum+37\u003e: add $0x1,%eax 0x55555555525a \u003csum+40\u003e: add %eax,-0x8(%rbp) 0x55555555525d \u003csum+43\u003e: addl $0x1,-0x4(%rbp) 0x555555555261 \u003csum+47\u003e: mov -0x4(%rbp),%eax 0x555555555264 \u003csum+50\u003e: cmp -0x14(%rbp),%eax 0x555555555267 \u003csum+53\u003e: jl 0x555555555254 \u003csum+34\u003e 0x555555555269 \u003csum+55\u003e: mov -0x8(%rbp),%eax 还可以通过disassemble指令来反汇编。 disassemble disassemble 程序计数器 ：反汇编pc所在函数的整个函数。 disassemble addr-0x40,addr+0x40：反汇编addr前后0x40大小。 ","date":"2021-04-07","objectID":"/gdb/:1:5","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"单步执行* 单步执行有两个命令next和step，缩写为n和s，两者的区别是next遇到函数不会进入函数内部，step会执行到函数内部。 finish （跳出函数体） 如果需要逐条汇编指令执行，可以分别使用nexti和stepi。 ","date":"2021-04-07","objectID":"/gdb/:1:6","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"继续执行*  调试时，使用continue命令(缩写：c)继续执行程序。程序遇到断电后再次暂停执行；如果没有断点，就会一直执行到结束。 continue：继续执行 continue 次数：继续执行一定次数。 ","date":"2021-04-07","objectID":"/gdb/:1:7","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"监视点* 要想找到变量在何处被改变，可以使用watch命令设置监视点watchpoint。 watch \u003c表达式\u003e：表达式发生变化时暂停运行 awatch \u003c表达式\u003e：表达式被访问、改变是暂停执行 rwatch \u003c表达式\u003e：表达式被访问时暂停执行 (gdb) watch i Hardware watchpoint 3: i (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000555555555244 in sum at sum.c:3 stop only if value==9 breakpoint already hit 1 time 3 hw watchpoint keep y ","date":"2021-04-07","objectID":"/gdb/:1:8","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"改变变量的值* 通过set variable \u003c变量\u003e=\u003c表达式\u003e来修改变量的值。 简写set var 变量名=变量值 （循环中用的多） until (跳出循环) (gdb) b main Breakpoint 4 at 0x555555555189: file main.c, line 11. (gdb) r 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Breakpoint 4, main (argc=21845, argv=0x0) at main.c:11 11 { (gdb) n 12 struct inout * io = (struct inout * ) malloc(sizeof(struct inout)); (gdb) n 13 if (NULL == io) { (gdb) n 18 if (argc != 2) { (gdb) n 23 io -\u003e value = *argv[1] - '0'; (gdb) n 24 io -\u003e result = sum(io -\u003e value); (gdb) print io-\u003evalue $4 = 9 (gdb) set variable io-\u003evalue=10 (gdb) n 25 printf(\"Your enter: %d, result:%d\\n\", io -\u003e value, io -\u003e result); (gdb) n Your enter: 10, result:55 26 return 0; set $r0=xxx：设置r0寄存器的值为xxx。 ","date":"2021-04-07","objectID":"/gdb/:1:9","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"生成内核转储文件* 通过generate-core-file生成core.xxxx转储文件。 然后gdb ./main ./core.xxxx查看恢复的现场。 (gdb) generate-core-file warning: target file /proc/14188/cmdline contained unexpected null characters Saved corefile core.14188 lwy@lwysLaptop:~/workspace/gdbtest$ gdb ./main ./core.14188 Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from ./main... [New LWP 14188] Core was generated by `/home/lwy/workspace/gdbtest/main 9'. Program terminated with signal SIGTRAP, Trace/breakpoint trap. #0 main (argc=2, argv=0x7fffffffe048) at main.c:26 26 return 0; 另一命令gcore可以从命令行直接生成内核转储文件。 gcore pidof 命令：无需停止正在执行的程序以获得转储文件。 ","date":"2021-04-07","objectID":"/gdb/:1:10","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"attach到进程* 如果程序已经运行，或者是调试陷入死循环而无法返回控制台进程，可以使用attach命令。 attach pid 通过ps aux可以查看进程的pid，然后使用bt查看栈帧。 以top为例操作步骤为： ps -aux查看进程pid，为16974. sudo gdb attach 16974，使用gdb 附着到top命令。 使用bt full查看，当前栈帧。此时使用print等查看信息。 还可以通过info proc查看进程信息。 ","date":"2021-04-07","objectID":"/gdb/:1:11","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"反复执行 continue、step、stepi、next、nexti都可以指定重复执行的次数。 ignore 断点编号 次数：可以忽略指定次数断点。 ","date":"2021-04-07","objectID":"/gdb/:1:12","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"dump内存到指定文件 在gdb调试中可能需要将一段内存导出到文件中，可以借助dump命令。 命令格式： dump binary memory FILE START STOP 比如dump binary memory ./dump.bin 0x0 0x008000000，将内存区间从0x0到0x00800000导出到dump.bin中。 ","date":"2021-04-07","objectID":"/gdb/:1:13","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"多进程调试 使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child] 设置调试模式：set detach-on-fork [on | off] 默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。 查看调试的进程：info inferiors 切换当前调试的进程：inferior id 使进程脱离 GDB 调试：detach inferiors id ","date":"2021-04-07","objectID":"/gdb/:1:14","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Operating System"],"content":"进程的概念 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。  一个进程在CPU上运行可以有两种运行模式（进程状态）：用户模式和内核模式。如果当前运行的是用户程序（用户代码），那么对应进程就处于用户模式（用户态），如果出现系统调用或者发生中断，那么对应进程就处于内核模式（核心态） ","date":"2021-04-06","objectID":"/process/:1:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程的状态模型 下图为进程的7状态模型，常用的5状态模型在该图的基础上去掉了挂起状态。其中包括如下状态： New State：New state is the state when the process is under creation Ready State: When the process is created new state comes, which is called ready state. After creation process comes under ready state. In ready state more than one process can also come. For example: One process is created at the same time second process is created then both the process will come under ready state. Running State: From ready state we have to select a process, and then have to allot CPU to that process for run. When CPU is allotted to process in ready state that process comes in running state. In running state only one process can stay at a time. Because CPU can be allotted to single process at a time. Wait State: When a process request for input/output than that process will left the running state, and will join new state known as wait state. In wait state more than one process can stay. After completion of I/O request process will go to ready state. Termination State: When process comes in running state, there is no more input output request by the process, because it’s already get completed. So process will go to termination state. Suspend Ready State: When ready state is not able to occupy more states in it, than some states are suspended in suspended state. Suspend ready state will be in secondary memory not in primary memory. When ready state get space for new processes than, processes from suspended ready state gets switch back to ready state. Such transaction is known as resume. Suspend Wait State: Similarly suspend wait state is also reside in process state diagram. ","date":"2021-04-06","objectID":"/process/:2:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"Linux进程组织 Linux进程通过一个task_struct结构体描述，在linux/sched.h中定义，通过理解该结构，可更清楚的理解linux进程模型。包含进程所有信息的task_struct数据结构是比较庞大的，但是该数据结构本身并不复杂，我们将它的所有域按其功能可做如下划分：  进程状态（State）  进程调度信息（Scheduling Information）  各种标识符（Identifiers）  进程通信有关信息（IPC：Inter_Process Communication）  时间和定时器信息（Times and Timers）  进程链接信息（Links）  文件系统信息（File System）  虚拟内存信息（Virtual Memory）  页面管理信息（page）  对称多处理器（SMP）信息  和处理器相关的环境（上下文）信息（Processor Specific Context）  其他信息 ","date":"2021-04-06","objectID":"/process/:3:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程状态 为了对进程从产生到消亡的整个过程进行跟踪和描述，就需要定义各种进程的各种状态并制定相应的状态转换策略，以此来控制进程的运行。 Linux系统中，进程状态在 task_struct 中定义如下： volatile long state; /* -1 unrunnable, 0 runnable, \u003e0 stopped */ 其状态取值如下： #define TASK_RUNNING 0 #define TASK_INTERRUPTIBLE 1 #define TASK_UNINTERRUPTIBLE 2 #define __TASK_STOPPED 4 #define __TASK_TRACED 8 /* in tsk-\u003eexit_state */ #define EXIT_ZOMBIE 16 #define EXIT_DEAD 32 /* in tsk-\u003estate again */ #define TASK_DEAD 64 #define TASK_WAKEKILL 128 #define TASK_WAKING 256 #define TASK_STATE_MAX 512 对进程每个状态简析如下： TASK_RUNNING （可运行状态）：处于这种状态的进程，要么正在运行、要么正准备运行。正在运行的进程就是当前进程（由current所指向的进程），而准备运行的进程只要得到CPU就可以立即投入运行，CPU是这些进程唯一等待的系统资源。 TASK_INTERRUPTIBLE（可中断的等待状态）：表示进程被阻塞（睡眠），直到某个条件达成，进程的状态就被设置为TASK_RUNNING。处于该状态的进程正在等待某个事件（event）或某个资源，而被挂起。对应的task_struct结构被放入对应事件的等待队列中。处于可中断等待态的进程可以被信号（外部中断触发或者其他进程触发）唤醒，如果收到信号，该进程就从等待状态进入可运行状态，并且加入到运行队列中，等待被调度。 TASK_UNINTERRUPTIBLE（不可中断的等待状态）：该状态与 TASK_INTERRUPTIBLE 状态类似，也表示进程被阻塞，处于睡眠状态。当进程等待的某些条件被满足了之后，内核也会将该进程的状态设置为 TASK_RUNNING。但是，处于这个状态下的进程不能在接收到某个信号之后立即被唤醒。这时该状态与 TASK_INTERRUPTIBLE 状态唯一的区别。 __TASK_STOPPED（暂停状态）：此时的进程暂时停止运行来接受某种特殊处理。通常当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后就处于这种状态。例如，正接受调试的进程就处于这种状态。 __TASK_TRACED（跟踪状态）：当前进程正在被另一个进程所监视。 EXIT_ZOMBIE（僵死状态）：进程虽然已经终止，但由于某种原因，父进程还没有执行wait()系统调用，终止进程的信息也还没有回收。顾名思义，处于该状态的进程就是死进程，这种进程实际上是系统中的垃圾，必须进行相应处理以释放其占用的资源。 EXIT_DEAD：一个进程的最终状态。 以下是LINUX进程间状态转换和内核调用图解 ","date":"2021-04-06","objectID":"/process/:3:1","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程内存布局 每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”： 文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。 初始化数据段：包含显示初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。 未初始化数据段：包含了未进行显示初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。出于历史原因，此段常被称为BSS段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配空间。 栈（stack）：是一个动态增长和收缩的段，有栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。 堆（heap）：是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称为program break。 对于初始化和未初始化的数据段而言，不太常用、但表达更清晰的称为分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。 在大多数Unix（包括Linux）中的C语言编程环境提供了3个全局符号（symbol）：etext、edata、end，可以在程序中使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。 使用这些符号，必须显式声明如下： // For example, \u0026etext gives the address of the end of the program text / start of initialized data extern char etext, edata, end; 图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。 ","date":"2021-04-06","objectID":"/process/:3:2","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"孤儿进程（orphan） 我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main () { /*fpid表示fork函数返回的值,fork会返回两次， 一次是父进程，返回值是子进程的Pid，在子进程会返回0*/ pid_t fpid; fpid=fork();//fork后会出现两个分支执行下面的代码，一个父进程，一个新的子进程 if (fpid \u003c 0) printf(\"fork error!\"); else if (fpid == 0) { // printf(\"child id is %dn\",getpid()); sleep(100); } else { //父进程 printf(\"parent id is %dn\",getpid()); sleep(30);//睡眠30s，在子进程之前退出 printf(\"parend finally...\"); } } ","date":"2021-04-06","objectID":"/process/:3:3","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"僵尸进程（zombie） 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。 unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。 任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。 僵尸进程危害场景： 例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main () { /*fpid表示fork函数返回的值,fork会返回两次， 一次是父进程，返回值是子进程的Pid，在子进程会返回0*/ pid_t fpid; fpid=fork();//fork后会出现两个分支执行下面的代码，一个父进程，一个新的子进程 if (fpid \u003c 0) printf(\"fork error!\"); else if (fpid == 0) { // printf(\"child id is %dn\",getpid()); sleep(30);//睡眠30s，在父进程之前退出 printf(\"child finally...\"); } else { //父进程 printf(\"parent id is %dn\",getpid()); sleep(60); printf(\"parend finally...\"); } } 僵尸进程解决办法 通过信号机制 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示： #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e static void sig_child(int signo); int main() { pid_t pid; //创建捕捉子进程退出信号 signal(SIGCHLD,sig_child); pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } else if (pid == 0) { printf(\"I am child process,pid id %d.I am exiting.\\n\",getpid()); exit(0); } printf(\"I am father process.I will sleep two seconds\\n\"); //等待子进程先退出 sleep(2); //输出进程信息 system(\"ps -o pid,ppid,state,tty,command\"); printf(\"father process is exiting.\\n\"); return 0; } static void sig_child(int signo) { pid_t pid; int stat; //处理僵尸进程 while ((pid = waitpid(-1, \u0026stat, WNOHANG)) \u003e0) printf(\"child %d terminated.\\n\", pid); } fork两次 《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e int main() { pid_t pid; //创建第一个子进程 pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } //第一个子进程 else if (pid == 0) { //子进程再创建子进程 printf(\"I am the first child process.pid:%d\\tppid:%d\\n\",getpid(),getppid()); pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } //第一个子进程退出 else if (pid \u003e0) { printf(\"first procee is exited.\\n\"); exit(0); } //第二个子进程 //睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里 sleep(3); printf(\"I am the second child process.pid: %d\\tppid:%d\\n\",getpid(),getppid()); exit(0); } //父进程处理第一个子进程退出 if (waitpid(pid, NULL, 0) != pid) { perror(\"waitepid error:\"); exit(1); } exit(0); return 0; } ","date":"2021-04-06","objectID":"/process/:3:4","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"守护进程 控制终端 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl + C会产生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 进程组 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员 会话 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程 守护进程 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程特征 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事： 该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID 该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断 如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。我认为创建新会话的进程不能是组长进程的原因：在新创建的会话中，创建会话的进程成为了会话首进程，同时，该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID，如果其已经是一个组长进程，那么就会产生矛盾。 一般守护进程创建步骤 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。 执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（/）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。 核心业务逻辑 示例 /* 写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。 */ #include \u003cstdio.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/time.h\u003e#include \u003csignal.h\u003e#include \u003ctime.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e void work(int num) { // 捕捉到信号之后，获取系统时间，写入磁盘文件 time_t tm = time(NULL); struct tm * loc = localtime(\u0026tm); // char buf[1024]; // sprintf(buf, \"%d-%d-%d %d:%d:%d\\n\",loc-\u003etm_year,loc-\u003etm_mon // ,loc-\u003etm_mday, loc-\u003etm_hour, loc-\u003etm_min, loc-\u003etm_sec); // printf(\"%s\\n\", buf); char * str = asctime(loc); int fd = open(\"time.txt\", O_RDWR | O_CREAT | O_APPEND, 0664); write(fd ,str, strlen(str)); close(fd); } int main() { // 1.创建子进程，退出父进程 pid_t pid = fork(); if(pid \u003e 0) { exit(0); } // 2.将子进程重新创建一个会话 setsid(); // 3.设置掩码 umask(022); // 4.更改工作目录 chdir(\"/home/nowcoder/\"); // 5. 关闭、重定向文件描述符 int fd = open(\"/dev/null\", O_RDWR); dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); // 6.业务逻辑 // 捕捉定时信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(\u0026act.sa_mask); sigaction(SIGALRM, \u0026act, NULL); struct itimerval val; val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // 创建定时器 setitimer(ITIMER_REAL, \u0026val, NULL); // 不让进程结束 while(1) { sleep(10); } return 0; } ","date":"2021-04-06","objectID":"/process/:3:5","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程管理命令 ps ps命令（Processes Statistic）时Linux系统中最为常用的进程查看工具，主要用于显示包含当前运行的各进程完整信息的静态快照。通过不同的命令选项，可以有选择性地查看进程信息。 ■ a：显示当前终端下的所有进程信息，包括其他用户的进程。与“x”选项结合时将显示系统中所有的进程信息。 ■ u：使用以用户为主的格式输出进程信息。 ■ x：显示当前用户在所有终端下的进程信息。 ■ –e：显示系统内的所有进程信息。 ■ –l：使用长格式显示进程信息。 ■ –f：使用完整的格式显示进程信息。 以上是ps命令中几个常用的选项，需要注意的是，有一部分选项时不带“-”前缀的。习惯上将上述选项组合在一起使用，如执行“ps aux”或“ps -elf” 上述输出信息中，第一行为列表标题，其各字段的含义描述如下。 ■ USER：启动该进程的户账号的名称。 ■ PID：该进程在系统中的数字ID号，在当前系统中是唯一的。 ■ TTY：表明该进程在哪个终端上运行。“？”表示未知或不需要终端。 ■ STAT:显示了进程当前的状态，如S（休眠）、R（运行）、Z（僵死）、\u003c（高优先级）、N（低优先级）、s（父进程）、+（前台进程）。 ■ START：启动该进程的时间。 ■ TIME：该进程占用的CPU时间。 ■ COMMAND：启动该进程的命令的名称。 ■ %CPU：CPU占用的百分比。 ■ %MEM：内存占用的百分比。 ■ VSZ：占用虚拟内存（swap空间）的大小。 ■ RSS：占用常驻内存（物理内存）的大小。 top top命令将会在当前终端以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次。作用类似Windows系统中的“任务管理器”。 上述输出信息中，开头的部分显示了系统任务（Tasks）、CPU占用、内存占用（Mem）、交换空间（Swap）等汇总信息；汇总信息下方依次显示当前进程的排名情况。相关信息的含义表述如下。 系统任务（Tasks）信息：total，总进程数; running,正在运行的进程数；sleeping，休眠的进程数；stopped，终止的进程数；zombie，僵死无响应的进程数。 CPU占用信息：us，用户占用；sy，内核占用；ni，优先级调度占用；id，空闲CPU；wa，1/0等占用； hi，硬件中断占用，si，软件中断占用；st，虚拟化占用。 内存占用（Mem）信息：total，总内存空间；used，已用内存；free，空闲内存；buffers，缓冲区域。 交换空间（Swap）占用：total，总内存空间；used，已用内存；free，空闲内存； buffers，缓冲区域。 在top命令的全屏操作界面中：可以按P键根据CPU占用情况对进程列表进行排序。 按M键根据内存占用情况进行排序。 按N键根据启动时间进行排序。 按h键可以获得top程序的在线帮助。 按q键可以正常的退出top程序。 按k键在列表上方会出现“PID to kill：”的提示信息，根据提示输入指定进程的PID并按Enter键确认即可终止对应的进程。 pgrep 使用pgrep命令可以根据进程的名称、运行该进程的用户、进程所在的终端等多种属性查询特定进程的PID号。 通过pgrep命令，可以只指定进程的一部分名称进行查询，结合“-l”选项可同时输出对应的进程名（否则只输PID号，不便于理解）。例如，查询进程中包含“log”的进程及其PID号，可以执行以下操作。 [root@lwy~]# pgrep -l “log” 2538 rsyslog 2113 mcelog 还可以结合“-U”选项查询特定用户的进程、“-t”选项查询在特定终端运行的进程。例如，若要查询用户zhangsan在tty3终端上运行的进程及PID号，可以执行以下操作。 [root@lwy~]# pgrep -l -U zhangsan-t tty3 2105 bash 2122 vim pstree pstree命令可以输出Linux系统中各进程的树形结构，以更加直观地判断出各进程之间的相互关系（父、子进程）。 pstree命令默认情况下只显示个进程的名称，结合“-p”选项使用时可以同时列出对应的PID号，结合“-u”选项可以列出对应的用户名，结合“-a”选项可以列出完整的命令信息。例如，执行“pstree -aup”命令可以查看当前系统的进程树，包括个进程对应的PID号、用户名、完整命令等信息。从出输出结果中可以看出，init进程确实是Linux系统中所有进程的“始祖” 改变进程的运行方式 挂起当前的进程  当Linux系统中的命令正在前台执行时（运行尚未结束），按Ctrl+Z组合键可以将当前进程挂起（调入后台并停止执行），这种操作在需要暂停当前进程并进行其他操作时特别有用。 [root@lwy~]# cp /dev/cdrom/mnt/Redhat6.0.iso [1]+ Stopped cp -i/dev/cdrom /mnt/Redhat6.0.iso 查看后台的进程 查看当前终端中在后台运行的进程任务时，可以使用jobs命令，结合“-l”选项可以同时显示出该进程对应的PID号。 [root@lwy~]# jobs -l [1]+ 2193 Stopped cp -i /dev/cdrom /mnt/Redhat6.0.iso 将后台的进程恢复运行 ■ 使用bg（BackGround，后台）命令，可以将后台中暂定执行（如按Ctrl+Z组合键挂起）的任务恢复运行，继续在后台执行操作、 ■ 使用fg命令（ForeGround，前台）命令，可以将后台任务重新恢复到前台运行。 除非后台中的任务只有一个，否则bg和fg命令都需要指定后台进程的任务编号作为参数。 例如，执行“fg 1”命令可以将之前挂起至后台的cp进程重新调入前台执行。 [root@lwy/]# jobs [1]+ Stopped cp -i/dev/cdrom /mnt/Redhat6.0.iso [root@lwy/]# fg 1 cp -i /dev/cdrom /mnt/Redhat6.0.iso 用pkill命令终止进程 使用pkill命令可以根据进程的名称、运行该进程的用户、进程所在的终端等多种属性终止特定的进程，大部分选项与pgrep命令基本类似，如“-U”（指定用户）、“-t”（指定终端）等选项。 例如，若要终止由用户zhangsan启动的进程（包括登陆Shell），可以执行以下操作。 [root@lwy/]# pgrep -l -U\"zhangsan\" 2105 bash [root@lwy/]# pkill -9 -U\"zhangsan\" [root@lwy/]# pgrep -l -U\"zhangsan\" ","date":"2021-04-06","objectID":"/process/:3:6","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Tools"],"content":"静态库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。 库的好处：1.代码保密 2.方便部署和分发 ","date":"2021-04-04","objectID":"/make_lib/:1:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"静态库的使用 通过gcc的-L命令指定库的路径，通过-l命令指定库的名字，注意这里库的名字不加lib,例如库的文件名为libxxx.lib那么库名就是xxx。 ","date":"2021-04-04","objectID":"/make_lib/:1:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"动态库 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic dependencies）命令检查动态库依赖关系 如何定位共享库文件呢？ 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——\u003e 环境变量LD_LIBRARY_PATH ——\u003e /etc/ld.so.cache文件列表 ——\u003e /lib/，/usr/lib 目录找到库文件后将其载入内存。 ","date":"2021-04-04","objectID":"/make_lib/:2:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"动态库的使用 程序在执行的时候是如何定位共享库文件的呢？ 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—\u003e环境变量LD_LIBRARY_PATH—\u003e/etc/ld.so.cache文件列表—\u003e/lib/,/usr/lib 目录找到库文件后将其载入内存。 如何让系统能够找到它： 如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。 如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下： 编辑/etc/ld.so.conf文件，加入库文件所在目录的路径 运行ldconfig ，该命令会重建/etc/ld.so.cache文件 ","date":"2021-04-04","objectID":"/make_lib/:2:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"静态库与动态库对比 静态库特点总结： 静态库对函数库的链接是放在编译时期完成的。 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件 动态库特点总结： 动态库把对一些库函数的链接载入推迟到程序运行的时期。 可以实现进程之间的资源共享。（因此动态库也称为共享库） 将一些程序升级变得简单。 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。 静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。 ","date":"2021-04-04","objectID":"/make_lib/:3:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"Makefile 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编 译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就 像一个 Shell 脚本一样，也可以执行操作系统的命令。 Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整 个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个 解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如 Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。 ","date":"2021-04-04","objectID":"/make_lib/:4:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"Makefile规则 一个 Makefile 文件中可以有一个或者多个规则 目标 ...: 依赖 ... 命令（Shell 命令） ... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或是目标 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进） Makefile 中的其它规则一般都是为第一条规则服务的 ","date":"2021-04-04","objectID":"/make_lib/:4:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"依赖检查与更新检测 命令在执行之前，需要先检查规则中的依赖是否存在 ，如果存在，执行命令 ，如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的， 如果找到了，则执行该规则中的命令 在执行规则中的命令时，会比较目标和依赖文件的时间 。如果依赖的时间比目标的时间晚，需要重新生成目标 ，如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 ","date":"2021-04-04","objectID":"/make_lib/:4:2","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"变量 自定义变量 变量名=变量值 var=hello 预定义变量 AR : 归档维护程序的名称，默认值为 ar CC : C 编译器的名称，默认值为 cc CXX : C++ 编译器的名称，默认值为 g++ @ : 目标的完整名称 \u003c : 第一个依赖文件的名称 ^ : 所有的依赖文件 特殊命令 $(wildcard PATTERN...) 功能：获取指定目录下指定类型的文件列表 参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔 示例： $(wildcard *.c ./sub/*.c) 返回值格式: a.c b.c c.c d.c e.c f.c $(patsubst ,,) 功能：查找中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式，如果匹配的话，则以替换。 可以包括通配符%，表示任意长度的字串。如果 中也包含%，那么，中的这个%将是中的那个% 所代表的字串。(可以用\\来转义，以\\%来表示真实含义的%字符) 返回：函数返回被替换过后的字符串 示例：$(patsubst %.c, %.o, x.c bar.c) 返回值格式: x.o bar.o ","date":"2021-04-04","objectID":"/make_lib/:4:3","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"简单示例 #定义变量 src=sub.o add.o mult.o div.o main.o target=app $(target):$(src) $(CC) $(src) -o $(target) %.o:%.c $(CC) -c $\u003c -o $@ ","date":"2021-04-04","objectID":"/make_lib/:4:4","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Operating System"],"content":"POSIX简介 ","date":"2021-03-29","objectID":"/posix/:1:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1. 概念 POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ） ","date":"2021-03-29","objectID":"/posix/:1:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.发布者-IEEE 发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。 IEEE，总部位于美国纽约，是一个国际性的电子技术与信息科学工程师的协会，也是目前全球最大的非营利性专业技术学会。IEEE致力于电气、电子、计算机工程和与科学有关的领域的开发和研究，在太空、计算机、电信、生物医学、电力及消费性电子产品等领域已制定了1300多个行业标准，现已发展成为具有较大影响力的国际学术组织 POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。 POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。 ","date":"2021-03-29","objectID":"/posix/:1:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.POSIX标准相关文件 Single UNIX Specification V3，IEEE Std 1003.1,2004 Edition 标准线上地址： The UNIX System 注册后可以在线阅读或者下载。 IEEE和Open Group 的POSIX认证： POSIX Certified by IEEE and The Open Group 相关页面： IEEE Std 1003.1, 2004 Edition ","date":"2021-03-29","objectID":"/posix/:1:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"POSIX历史 ","date":"2021-03-29","objectID":"/posix/:2:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1.起源 POSIX是Unix的标准。 1974年，贝尔实验室正式对外发布Unix。因为涉及到反垄断等各种原因，加上早期的Unix不够完善，于是贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。 于是出现了好些独立开发的与Unix基本兼容但又不完全兼容的OS，通称Unix-like OS。 包括： 美国加州大学伯克利分校的Unix4.xBSD(Berkeley Software Distribution)。 贝尔实验室发布的自己的版本，称为System V Unix。 其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。 20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同。 局面非常混乱，麻烦也就随之而来了。 为了提高兼容性和应用程序的可移植性，阻止这种趋势， IEEE(电气和电子工程师协会)开始努力标准化Unix的开发，后来由 Richard Stallman命名为“Posix”。 这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。 ","date":"2021-03-29","objectID":"/posix/:2:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.标准覆盖 市面上绝大多数操作系统厂家都支持该标准，首先就是大名鼎鼎的Unix和Linux了，除此之外还有苹果的操作系统也是Unix-based的。有了这个规范，你就可以调用通用的API了，Linux提供的POSIX系统调用在Unix上也能执行，因此学习Linux的底层接口最好就是理解POSIX标准。Windows从WinNT开始就有兼容POSIX的考虑。这是因为当年在要求严格的领域，Unix地位比Windows高。为了把Unix用户拉到Windows阵营，被迫支持POSIX。 现在Win10对 Linux/POSIX 支持好，则是因为Linux已经统治了廉价服务器市场。为了提高Windows的竞争力搞的。所以一切都是以市场为主导。 ","date":"2021-03-29","objectID":"/posix/:2:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.支持POSIX-Linux成功的最重要一个因素 Linux之所以能够成功，有很多因素，但是支持POSIX标准无疑是它能够快速发展的最重要的一个因素。 POSIX 标准的制定最后投票敲定阶段大概是 1991~1993 年间，而此时正是Linux 刚刚起步的时候，这个 UNIX 标准为 Linux 提供了极为重要的信息，使得 Linux 能够在标准的指导下进行开发，并能够与绝大多数 UNIX 操作系统兼容。 在最初的 Linux 内核源码（0.01版、0.11版）中就已经为 Linux 系统与 POSIX 标准的兼容做好了准备工作。 在 Linux 0.01 版内核 /include/unistd.h 文件中就已经定义了几个有关 POSIX 标准要求的符号常数，而且 Linus 在注释中已写道：“OK，这也许是个玩笑，但我正在着手研究它呢”。 正是由于Linux支持POSIX标准，无数可以在unix上运行的程序都陆续的移植到Linux上，而此时unix因为版权问题，官司打的不可开交，使得Linux后来者居上。 而Linus也在《知识为了好玩》中讲述了POSIX的重要性： POSIX标准是一个可以适用于数以百计的UNIX系统调用中的任意一个的一套冗长规则， 计算机要执行任务（从读、 写、 开机和关机开始） 就需要这个标准。 POSIX则是指一个UNIX的标准体系， 或一个由来自不同公司的代表所组成的一个组织， 希望按照一个共同的标准进行运作。 对于程序员开发的在该操作系统下的新应用软件或开发应用软件的新版本而言， 标准是极其重要的。 从POSIX这样的系统调用（system call） ， 尤其是重要的调用（call） 中， 我可以获得一个操作系统应该具有哪些功能的一个单子； 然后我就可以通过自己的方式在自己的系统中实现每一个功能。 通过编写出这些标准， 我的系统软件的源代码将可以被别人使用， 以开发新的应用软件。 当时我并不知道我本可以直接从POSIX公司买到这些规则的软盘， 但这无所谓。 哪怕我能买得起， 什么东西运到芬兰， 往往会需要很长的时间。 我不愿等上那么久， 因此我四处搜求一个能从FTP地址上直接下载的版本。 没有人给我提供能找到POSI标准的来源。 于是我开始了计划B。 我从学校找到运行sun器(sun server)的sun微系统版的UNIX手册。 该手册中有一个完全可以凑合使用的系统呼叫的基本版本。 从用户手册中能看出系统呼叫的主要功能， 以及为完成这些功能所需要完成的步骤。 但是， 从中看不出具体的方法， 而只是标明了最终的结果。 于是我便着手从安德鲁·塔南鲍姆的书中和别的材料中收集一些系统呼叫。 最终有人给我寄来了那几卷厚厚的POSIX标准。 ","date":"2021-03-29","objectID":"/posix/:2:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"可移植性 聊到POSIX，那我们就不得不说说到底什么是可移植性，在讲可移植性之前，我们先来了解库函数和系统调用的区别。 Linux下对文件操作有两种方式：系统调用（system call）和库函数调用（Library functions）。 ","date":"2021-03-29","objectID":"/posix/:3:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1.系统调用 系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。 ","date":"2021-03-29","objectID":"/posix/:3:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.库函数 库函数（Library function）是把函数放到库里，供别人使用的一种方式。 方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。 库函数调用则是面向应用开发的，库函数可分为两类， 一类是C语言标准规定的库函数， 一类是编译器特定的库函数。 (由于版权原因，库函数的源代码一般是不可见的，但在头文件中你可以看到它对外的接口)。 glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的。 glibc 为程序员提供丰富的 API（Application Programming Interface），这些API都是遵循POSIX标准的，API的函数名，返回值，参数类型等都必须按照POSIX标准来定义。 POSIX兼容也就指定这些接口函数兼容，但是并不管API具体如何实现。 ","date":"2021-03-29","objectID":"/posix/:3:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.库函数API和系统调用的区别 如上图所示： (1) 库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分 (2) 库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大 (3) 系统调用依赖于平台，库函数并不依赖 系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。 库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性好。 ","date":"2021-03-29","objectID":"/posix/:3:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"4.程序的可移植性及其本质 程序在不同的机器上会生成不同的目标代码，那么目标代码和启动代码是怎么生成的呢？ 答案是编译器。 编程语言编写的程序首先要被编译器编译成目标代码（0、1代码），然后在目标代码的前面插入启动代码，最终生成了一个完整的程序。 要注意的是，程序中为访问特定设备（如显示器）或者操作系统（如windows xp 的API)的特殊功能而专门编写的部分通常是不能移植的。 综上所述，一个编程语言的可移植性取决于 不同平台编译器的数量 对特殊硬件或操作系统的依赖性 移植是基于操作系统的。但是这个时候，我们需要注意一点：基于各种操作系统平台不同，应用程序在二级制级别是不能直接移植的。 我们只能在代码层去思考可移植问题，在API层面上由于各个操作系统的命名规范、系统调用等自身原因，在API层面上实现可移植也是不大可能的。 在各个平台下，我们默认C标准库中的函数都是一样的，这样基本可以实现可移植。但是对于C库本身而言，在各种操作系统平台下其内部实现是完全不同的，也就是说C库封装了操作系统API在其内部的实现细节。 因此，C语言提供了我们在代码级的可移植性，即这种可移植是通过C语言这个中间层来完成的。 例如在我们的代码中下功夫。以下代码可以帮助我们实现各平台之间的可移植： #ifdef _WINDOWS_ CreateThread(); //windows下线程的创建 #else Pthread_create(); //Linux下线程的创建 #endif 对于头文件，也使用同样的预编译宏来实现。如： #ifndef _WINDOWS_ #include \u003cwindows.h\u003e#else #include \u003cthread.h\u003e#endif 这样就可以实现代码的可移植了。在编译的时候只要通过#define就可以选择在那个平台下完成程序的编译。 综上所述，我们都是将C，C++等各种语言当作中间层，以实现其一定程度上的可移植。如今，语言的跨平台的程序都是以这样的方式实现的。但是在不同的平台下，仍需要重新编译。 ","date":"2021-03-29","objectID":"/posix/:3:4","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"5.系统开销 使用系统调用会影响系统的性能，在执行调用时的从用户态切换到内核态，再返回用户态会有系统开销。 为了减少开销，因此需要减少系统调用的次数，并且让每次系统调用尽可能的完成多的任务。 硬件也会限制对底层系统调用一次所能写的数据块的大小。 为了给设备和文件提供更高层的接口，Linux系统提供了一系列的标准函数库。 使用标准库函数，可以高效的写任意长度的数据块，库函数在数据满足数据块长度要求时安排执行底层系统调用。 一般地，操作系统为了考虑实现的难度和管理的方便，它只提供一少部分的系统调用，这些系统调用一般都是由C和汇编混合编写实现的，其接口用C来定义，而具体的实现则是汇编，这样的好处就是执行效率高，而且，极大的方便了上层调用。 随着系统提供的这些库函数把系统调用进行封装或者组合，可以实现更多的功能，这样的库函数能够实现一些对内核来说比较复杂的操作。 比如，read()函数根据参数，直接就能读文件，而背后隐藏的比如文件在硬盘的哪个磁道，哪个扇区，加载到内存的哪个位置等等这些操作，程序员是不必关心的，这些操作里面自然也包含了系统调用。 而对于第三方的库，它其实和系统库一样，只是它直接利用系统调用的可能性要小一些，而是利用系统提供的API接口来实现功能(API的接口是开放的)。 ","date":"2021-03-29","objectID":"/posix/:3:5","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"例子 如下图是Linux系统调用的大概流程。 当应用程序调用printf()函数时，printf函数会调用C库中的printf，继而调用C库中的write，C库最后调用内核的write()。 而另一些则不会使用系统调用，比如strlen, strcat, memcpy等。 printf函数执行过程中，程序运行状态切换如下： 用户态–\u003e系统调用–\u003e内核态–\u003e返回用户态 printf函数、glibc库和系统调用在系统中关系图如下 实例代码如下： #include \u003cstdio.h\u003e int main(int argc, char **argv) { printf(\"hello world\"); return 0; } 编译执行 lwy@lwysLaptop:~/workspace$ gcc test.c -o test \u0026\u0026 strace ./test 运行程序前加上strace，可以追踪到函数库调用过程 如执行结果可知： 我们的程序虽然只有一个printf函数，但是在执行过程中，我们前后调用了execve、access、open、fstat、mmap、brk、write等系统调用。 其中write系统调用会把字符串：hello world通过设备文件1，发送到驱动，该设备节点对应终端stdout。 ","date":"2021-03-29","objectID":"/posix/:4:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["C/C++"],"content":"IFNDEF ifndef的含义是If not define, 其搭配使用如下 // xxx.h #ifndef __INCxxx.h #define __INCxxx.h #ifndef __cpluscplus extern \"C\" { #endif /*...*/ #ifndef } #endif #endif ","date":"2021-03-19","objectID":"/ifndef/:1:0","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"1.多次包含的情况 include xxx 就是将xxx的内容原地展开 假设有： a.h， 内容是 A b.h， 内容是： #include \"a.h\" B c.h， 内容是： #include \"a.h\" C 如果有一个文件x.c， 内容是： #include \"b.h\" #include \"c.h\" X b.h和c.h的内容就会被插入到X之前， 也就是这个样子： A B A C X A的内容就出现了2次。 在更复杂的环境中， A的内容还可能出现多次。 ","date":"2021-03-19","objectID":"/ifndef/:1:1","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"2.多次出现是有问题的 一般来说， 重复声明没什么问题。 所以， 如果A.h中止包含一些声明， 那重复了也没什么关系。 比如： int f(int); int f(int); int f(int); extern int i; extern int i; extern int i; struct x; struct x; struct x; 重复写N次也没关系。 但头文件中会出现一类\"定义\"， 在同一翻译单元中是不能重复的。 比如： struct x { ... }; struct x { ... }; // 重复定义 #define M ... #define M ... // 重复定义 ","date":"2021-03-19","objectID":"/ifndef/:1:2","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"3.头文件保护符 有时候必须将这些定义放在头文件中， 所以就要用头文件保护符。 另外还有一类\"定义\"， 会产生外部符号。 这类\"定义\"在一个链接过程中只能有唯一一份。 是不可以加入到头文件中的。 这种定义依然有例外…… 就是inline、模板和匿名名字空间， 就不扯远了…… 假设A的内容是： #ifndef A_H #define A_H AA #endif 如果A被展开多次，例如上面的X， 就会变成这个样子 // A_H是a.h的保护符， 必须是一个不冲突的名字。 那么，这里就不会有A_H的定义 // 然后紧接这下一行中的条件编译就会选中#ifndef 和#endif之间的部分， // 也就是#define A_H 和AA #ifndef A_H #define A_H AA #endif B // 在a.h被第一次包含后， A_H就获得定义 // 所以下一行的条件编译部分就被取消， AA就不会重复出现多次 #ifndef A_H #define A_H AA #endif C X 最终交给编译器看到的代码就是： AA B C X 只要A_H是唯一的， AA就不会重复出现。 就解决了这个问题， 一般情况就是这么用的， 是为惯例。 ","date":"2021-03-19","objectID":"/ifndef/:1:3","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"4.外部头文件保护符 上面的用法是\"内部头文件保护符\"。 a.h的保护符是使用在a.h里。 另外一种用法是\"外部头文件保护符\"， 如： ------ a.h ------ AA ------ b.h ------ #ifndef A_H #define A_H #include \"a.h\" #endif B ------ c.h ------ #ifndef A_H #define A_H #include \"a.h\" #endif C 当X同时包含b.h和c.h时， 最终效果和内部头文件保护符差不多。 两者对比， 外部的优势是可以减少打开a.h的次数。 而内部保护符可以降低a.h和b.h, c.h之间的耦合。 ","date":"2021-03-19","objectID":"/ifndef/:1:4","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"5.定义保护符 马上就要到主题了…… 将头文件保护符的用法扩展一下， 就变成了定义保护符（这个名字是我捏造的）。 保护的不是某个\"头文件\" 而是某个\"定义\"， 如： ------ a.h ------ #ifndef A_X #define A_X struct x { ... }; #endif #ifndef A_M #define A_M #define M ... #endif ... b.h和c.h直接包含a.h， 最终效果也是一样。 ","date":"2021-03-19","objectID":"/ifndef/:1:5","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"6.重复的定义保护符 到主题了…… 同样是一个捏造的词。 假设： b.h包含a.h是为了获得struct x的定义。 而c.h包含a.h是为了获得宏M的定义。 除了上面作法， 还有另一种做法： a.h和上面差不多 #ifndef X #define X struct x { ... }; #endif #ifndef M #define M ... #endif 而b.h和c.h并不包含a.h， 而是直接将需要的定义写在b.h和c.h中 ------ b.h ------ #ifndef X #define X struct x { ... }; #endif B ------ c.h ------ #ifndef M #define M ... #endif C 这样做其实耦合比外部头文件保护符还要高， 所以一般是不会采用的。 但C的标准头文件必须这样做。 因为C89有一个要求， 具体我不记得了。 要么是要求标准头文件不能包含其他标准头文件。 要么是要求标准头文件不能包含任何其他文件。 （C++和C99取消了这个要求） stdio.h是C89的标准头文件。 例如， 它需要定义一个size_t， 作为一些函数的参数类型。 而另外有一些标准头文件也会有size_t。 所以这些头文件中的size_t都是这样提供的： #ifndef _SIZE_T_DEFINED #define _SIZE_T_DEFINED typedef unsigned xxx size_t; #endif 或者也可能将若干定义分组， 共用一个保护符。 ","date":"2021-03-19","objectID":"/ifndef/:1:6","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"初学C语言会觉得字符串处理是一件比较繁琐的事情，后来学了C++发现字符串的处理可以这么方便。但是C++又为了兼容C，导致经常有混用的情况。本文就重点介绍C++中的字符串和C风格字符串的区别。 首先，明确一点，C语言中的字符串以及相关的标准库都能完全在C++中兼容使用。所以在介绍C++中的字符串特指C++中特有的。下面介绍几个概念 ","date":"2019-08-15","objectID":"/string/:0:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"字符串字面值(string literal) 字符串字面值是一串常量字符，字符串字面值常量用双引号括起来的零个或多个字符表示，为兼容C语言，C++中所有的字符串字面值都由编译器自动在末尾添加一个空字符。 字符串没有变量名字，自身表示自身 \"Hello World!\" //simple string literal \"\" //empty string literal \"\\nCC\\toptions\\tfile.[cC]\\n\" //string literal using newlines and tabs 字符字面值： 'A' //single quote:character literal 字符串字面值： \"A\" //double quote:character string literal.包含字母A和空字符的字符串 字符串字面值可以赋值给变量，但是与字符串字面值相关联的内存空间位于只读部分，因此它是常量字符数组。 char* ptr = \"hello\"; ptr[1] = 'a';//crash! attemps to write to read-only memory. //只读 因此，当引用字符串字面值的时候使用指向const的字符数组。 const char* ptr = \"hello\"; ptr[1] = 'a';//bug! attempts to write to read-only memory. 当将字符串字面值赋值给字符数组的初始值的时候。由于字符数组存放与栈中，不允许引用其他地方的内存，因此编译器会将字符串字面值复制到栈的数组内存中。因此，可以进行相应的修改。 char stackArray[] = \"hello\"; stackArray[1] = 'a'; ","date":"2019-08-15","objectID":"/string/:1:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"C风格字符串 字符串字面值的类型实质是const char类型的数组。C++从C语言继承下来的一种通用结构是C风格字符串，而字符串字面值就是该类型的实例。C风格字符串是以空字符null结束的字符数组。 char ca1[]={'C', '+', '+'}; // no null, not C-style string char ca2[]={'C', '+', '+', '\\0'}; // explicit null char ca3[]=\"C++\"; // null terminator added automatically const char *cp=\"C++\"; // null terminator added automatically char *cp1=ca1; // points to first element of a array, but not C-style string char *cp2=ca2; // points to first element of a null-terminated char array ca1和cp1都不是C风格字符串：ca1是一个不带结束符null的字符数组，而指针cp1指向ca1，因此，它指向的并不是以null结束的数组。 C++语言通过(const) char *类型的指针来操纵C风格字符串。 C风格字符串在C语言中有C标准库函数来处理：string.h C语言中也有对字符进行处理的标准库函数:ctype.h 这些库函数在C++中都有对应的版本，只需要去掉.h前面加上c就行了，这样也能在C++区分出这是C风格的函数 即cstring和cctype C风格字符串中带来困恼的原因是字符数组总要以空字符结尾，这给计算数组空间带来不便，也容易引发安全问题，处理字符串的相关复制，移动情形时，调用者必须保证目标字符串有足够的大小。 另一个苦恼是C风格的字符串的复制，截取等相关操作不能像对待基础数据类型一样方便，这些情况在C++风格的字符串中由重载运算符实现，方便了用户。 所以一般C++不推荐使用C风格字符串，即使要使用，也尽量在C标准库中使用诸如strn 前缀的函数处理，以降低风险。 ","date":"2019-08-15","objectID":"/string/:2:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"C++风格字符串 C++使用标准库类型string表示可变长的字符序列，标准库中的名称符号都包含在命名空间呢std中。 在初始化string对象时可以使用多种方式比如： string s1; // 默认初始化，s1是一个空字符串 string s2 = s1; // s2是s1的副本 string s3 = \"hiya\"; // s3是该字符串字面值的副本 string s4(10, 'c'); // s4的内容是cccccccccc string对象可以用标准库中的流直接读写 比如cin，但是读时从非空白开始，即忽略开头的空白，遇到下一处空白结束。 当要读取一整行的时候可以使用getline(cin,line) ，(line是读取后存放的string对象)该函数从给定的输入流中读取内容，直到遇到换行符为止，换行符也被读取进来，然后把读取的内容存放到line中，不包含换行符。 string对象可以使用== 、\u003c、\u003e、\u003e=等比较符号，这个很好理解，不多说。 另外值得注意的是，string对象之间可以相加，字符串字面值和string对象也可以相加，但是字符串字面值之间不能相加！ 最后谈一下C风格的字符串和C++风格字符串怎么转换 C风格字符串转换到C++的string对象很简单，可以将C风格字符串(包括字面值)作为string初始化的参数即可，或者可以用=号。 更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 即允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 string对象转换为C风格字符串则有一个方法c_str() ,直接调用即可。 string s = \"msl\"; string s1(\"dad\"); const char* p = \"dsjka\"; char p1[] = \"das\"; string w = s + \"da\"; string q = s + p; string t = s + p1; string u = p + p1; // wrong string k = p + \"daas\"; // wrong 如上面代码所示，最后两个有错，其余都是允许的。 ","date":"2019-08-15","objectID":"/string/:3:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"字符串与整型的互相转换 先说string对象与int型转换 int转换为string对象有全局函数std::to_string()(C++11)。 当然还可以用其他的stringstream的方式。 string转为int可以利用标准库中的atoi()函数（ ascii to integer），但要先转为C风格串，从C标准库继承过来，举例 std::string str = \"123\"; int n = atoi(str.c_str()); // 先转为C风格 cout\u003c\u003cn; //123 同时除了atoi()还要atof()等一系列函数。 另外用一些C语言中的格式化输入输出函数也可以实现,比如sprintf,sscanf等。 string s1 = \"1234\"; int a = atoi(s1.c_str()); string s2 = to_string(a); ","date":"2019-08-15","objectID":"/string/:4:0","tags":["C/C++"],"title":"字符串的一些问题","uri":"/string/"},{"categories":["C/C++"],"content":"常量const通俗理解 首先先讲一讲常量，为什么要使用常量，因为不变的值更易于理解、跟踪和分析，所以应该尽可能地使用常量代替变量。 C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点： const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 所以本文就针对const 修饰的常量以及其他的类型进行探讨。 在C++的学习过程中，不管是初学者，还是略有了解的人，对const关键字的理解总是或多或少遇到一些问题。本文不妨采用一种通俗的理解方式，另辟蹊径来和大家分享一下理解思路。 先说说技巧，怎么区分const修饰的是什么： 理解的时候，在定义或声明中跳过或者忽略掉数据类型（int，char，double等），const后面的内容即为修饰的内容。 比如： 普通类型： const int p;//忽略int，即 const后面是p，修饰的即为p int const p;//同样的分析方法，这句跟上面的分析一致 指针类型： const int *p1; //去掉int，const修饰的是 * int const *p2; //去掉int，const修饰的是 *，等同于上面一句 int* const p3; //去掉int，const修饰的是p3，区别于上面那种情况 const int* const p4; //去掉int，const即修饰*，又修饰p4，区别上面两种情况 当然还有其他的类型等，放到后面再说。 ","date":"2019-08-03","objectID":"/understand_const/:1:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"const修饰的普通变量 变量名的本质：一段连续内存空间的别名。 比如： 定义了 ：int p = 10； 则系统会分配4个字节的内存，这块内存我们命名为p,其地址是不确定的，这里我们假定是0x2222，于是在p生存的周期内，这块从0x2222开始的地址的内存空间就被命名为p，p = 10 即向这块内存内写入10。 对于普通变量，const修饰时，仅仅改变的是变量的属性，即将原来变量的可读写性变成了只读性。 可以这么理解：普通变量加const修饰是为了防止变量被修改。 但有个例外：如果该变量为全局变量，则不能通过指针修改，但如果是局部变量，则还是可以通过指针修改的。 原因是：全局变量在全局静态区，内容不能被修改，但局部变量本身仍在栈区，可以使用指针修改。 const int a = 10; //const修饰全局变量必须初始化 void fun(){ const int b; //const修饰局部变量可以不初始化 int *p = \u0026b; //可以利用指针指向b对应的内存块，对该内存块修改 *p = 20; printf(\"%d , %d\",*p,b); //结果为 20 ，20 p = \u0026a; //可以利用指针指向a对应的内存块 *p = 20; //（此句运行出错）但不可以通过指针修改全局变量的内容 a = 20; //（此句运行出错）因为a为全局常量，不能修改 } 默认情况下，cosnt对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同的文件中分别定义了独立的变量。所以如果想要在多个文件中共享const对象，则对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了。 ","date":"2019-08-03","objectID":"/understand_const/:2:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"const 与指针 利用最前面分析的方法，可以知道const修饰指针变量有三种情况： ①const修饰 * 号 ②const修饰变量 ③const既修饰 * 号又修饰变量 只要掌握了前两种情况，最后第三种自然明了。 先说说const修饰 * 号，该情况为（局部变量）： const int *p_a;//与int const *p_a;等价 int a = 10; int b = 20; p_a = \u0026a; *p_a = 20; //错误 a =20; //正确 p_a = \u0026b; //正确 当const修饰*号时，表示不能通过指针p_a修改p_a指向的内容。这句话有3层意思（对应上述代码三种情况）： ①当p_a指向a时,不能通过指针p_a取*号修改a中的内容 ②a中的内容仍可以由a自身修改 ③p_a指向可以改变，即p_a可以指向b 可以这么记忆：* 号是指针用来对指向的内存操作（读写）的，当对 * 加了const修饰，意味着 * 号的操作只剩下只读的功能，也就是只能使用 *号来读取指针指向的内容，而失去了写的特性，这点与普通变量的情况类似。 再说说const修饰变量的情况: void fun(){ int a = 10; int b = 20; int* const p_a = \u0026a; *p_a = 20; //正确 a = 30; //正确 p_a = \u0026b; //错误 } 当const修饰变量p_a时，表示不能改变p_a的内容，即改不了指针的指向。这句话有3层意思（对应上述代码三种情况）： ①当p_a指向a时,能通过指针p_a取*号修改a中的内容 ②a中的内容仍可以由a自身修改 ③p_a指向不可以改变，即p_a不可以修改，指向b或者其他变量 最好的理解便是：指针变量也是变量，变量名的本质：一段连续内存空间的别名。理解好了这句，也就明白了，const修饰了这个变量，也就是修饰了这块内存空间，使得这块内存空间的可读写性改为了可读性，也就是指针指向固定，无法更改。 看到这里，如果前面的都了解了，那么你就会明白了用const修饰，实际上就是将对应的可读写改成了只读性质。 那么，最后一种情况就是，const既修饰 * 号，又修饰变量的情况了： void fun(){ int a = 10; int b = 20; const int* const p = \u0026a; //必须初始化 *p = 20; //错误 p = \u0026b; //错误 a = 20; //正确 } 如果明白了前两种情况，那么最后这种情况就好理解了（对应上述代码三种情况） ①const修饰*号限定了指针对内存的操作只能为只读 ②const修饰变量p限定了指针的指向，p不能指向其他变量 ③a或b本身的变量可以自身修改。 至于为什么必须初始化，如果理解了上述内容，那也就明白了（因为只读）。并且在初始化的过程中，利用一个对象去初始化另一个对象，则它们是不是const都无关紧要，因为拷贝一个对象的值并不会改变它。说下不初始化的情况，编译器（我用的VS2017）仍能通过，但有警告，p没有明确初始化，并不知道其指向哪里，由于该变量既不能修改指向，又不能修改指向的内容，所以此时该指针也就没有作用了，这种做法是不好的。 ","date":"2019-08-03","objectID":"/understand_const/:3:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"const 与引用类型 可以把引用绑定到const对象上，就像绑定到其他对象身上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象： const int ci = 1024; const int \u0026r1 = ci; //正确, 引用及其对应的对象都是常量 r1 = 42; // 错误，r1 是对常量的引用 int \u0026r2 = ci; // 错误，试图让一个非常量引用指向一个常量对象 因为不允许直接为ci 赋值，当然也不可以通过引用去改变ci，因此对r2的初始化是错误的，假设该初始化合法， 就可以通过r2来改变其引用的值，这显然不正确。 “常量引用”是“对const的引用“，严格来说，并不存在常量引用，因为引用不是一个对象，我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上来看所有的引用又都算常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。 引用的类型必须与其所引用的对象保持一致，但是有两个例外：第一个是初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个表达式。 对于以下代码： double dval = 3.14; const int \u0026ri = dval; 此处ri引用了一个Int型的数，对ri的操作应该是整数运算，但dval是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器将代码变成了以下形式： const int temp = dval; // 由双精度浮点数生成一个临时的整型常量 const int \u0026ri = temp; // 让ri绑定这个临时量 这种情况下，ri绑定了一个临时量对象，所谓的临时量对象就是编译器需要一个空间来暂存表达式的求值结果临时创建的一个未命名的对象。 对const 的引用可能引用一个并非const 的对象 必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。 ","date":"2019-08-03","objectID":"/understand_const/:4:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"指针、常量和类型别名 针对上述的情况，特别举一例子作为讲解 先看下面的代码 typedef char* VP; const char *data[3] = {\"I\",\"Love\",\"u\"}; // (1) const VP data1[3] = {\"I\",\"Love\",\"u\"}； // (2) data[1] = \"hate\"; //能正常修改 data1[1] = \"hate\"; //编译器报错，提示data1[1]是无法修改的左值 根据编译器报错的提示信息，你可能猜到了在(2)式中的指针变为了常量指针，而(1)没有改变。那为什么会造成这种情况呢，这得从编译器的角度来说明变量的申明顺序问题。 首先，先针对声明语句进行剖析一下。 (a) c和c++中声明包含零个或者多个声明说明符，和一个声明符 例如： static unsigned long int *x[N]; static unsigned long int // 声明说明符 *x[N] // 声明符 一个声明符就是被声明的名称，可能还伴有操作符，如*,(),[],\u0026等，以本例为例，*表示x是一个指针，[]表示序列， *x[N]表明x是含有N个指针的序列。 可能基础比较弱的人一直分不清楚指针数组和数组指针，以及返回指针的函数和函数指针怎么写。其实与运算符一样，操作符也是有优先级的，在本例中[]的优先级要比*的优先级高，所以首先其是一个序列，然后才声明序列中的元素是指针。而(*x)[N]中()的优先级比[]的优先级高，所以首先确定了其是一个指针。 (b) 声明说明符包含类型说明符和与类型无关的说明符，分清楚这个对于理解例子中的两个例子为什么会出现不同的情况至关重要。注意在(1)式中char是类型说明符，而const是与类型无关的说明符，所以1)式中const并不会修饰变量data，应该理解为指向const char的指针序列，而不是指向char的const指针序列。。 (c) 声明说明符在一个声明中出现的顺序并不重要，如： const void *data[N]; void const *data[N]; 这两者实际上是等价的，但是要注意对于指针的声明是从右到左来看的，所以对于在对指针的声明说明符中，正确的写法应该将const放在类型说明符的右边。如： T const *p // const 在T后面， 指向常量的指针 T* const p // const 在T后面，常量指针 上面的式子中表示指向const T的指针，而下面的式子修饰了操作符*则表示指向T类型的const指针，说以对于最开始的问题中的(2)按照正确的写法应该是： VP const data1[3] = {\"I\",\"Love\",\"u\"}； 展开: char* const data1[3] = {\"I\",\"Love\",\"u\"}； 这样对照刚刚的讲解，现在是不是就能理解为什么data1序列中的指针为const类型了。 参考文献： https://blog.csdn.net/rlyhaha/article/details/80397227 https://blog.csdn.net/JayFan_Ma/article/details/82942903 https://blog.csdn.net/qq_40416052/article/details/82655736 https://blog.csdn.net/qq_40399012/article/details/84069983 https://blog.csdn.net/love_gaohz/article/details/7567856 ","date":"2019-08-03","objectID":"/understand_const/:5:0","tags":["C/C++"],"title":"理解常量const","uri":"/understand_const/"},{"categories":["C/C++"],"content":"声明与定义关系 为了允许把程序拆分为多个逻辑部分来写，C++文件允许分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。 如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是std::cout 和std::cin，它们定义于标准库，却能被我们写的程序使用。 为了支持分离式编译，C++将声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(definition)负责创建与名字关联的实体。 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还是申请存储空间，也可能会为变量赋一个初始值。 如果想要单纯声明一个变量，就在变量名前加关键字extern，而不要显式地初始化变量： 所以，下面的是声明: extern int a; 下面的是定义 int a; //声明并定义a int a = 0; // 声明并定义初始化a extern int a = 0;//// 声明并定义初始化a 在函数体内部，如果试图初始化一个extern关键字标记的变量，将引发错误。总结一下就是： 根据C++标准的规定，一个变量是声明，必须同时满足两个条件，否则就是定义： ① 声明必须使用extern关键字 ② 不能给变量赋初值 函数或变量在声明时，并没有给它实际的物理内存空间，它有时候可保证你的程序编译通过； 函数或变量在定义时，它就在内存中有了实际的物理空间。 如果你在编译单元中引用的外部变量没有在整个工程中任何一个地方定义的话，那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量。 函数或变量可以声明多次，但定义只能有一次。 ","date":"2019-08-01","objectID":"/variable/:1:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"编译单元 在VC或VS上编写完代码，点击编译按钮准备生成exe文件时，编译器做了两步工作： 第一步，将每个.cpp(.c)和相应的.h文件编译成obj文件； 第二步，将工程中所有的obj文件进行LINK，生成最终.exe文件。 那么，错误可能在两个地方产生： 一个，编译时的错误，这个主要是语法错误； 一个，链接时的错误，主要是重复定义变量等。 编译单元指在编译阶段生成的每个obj文件。 一个obj文件就是一个编译单元。 一个.cpp(.c)和它相应的.h文件共同组成了一个编译单元。 一个工程由很多编译单元组成，每个obj文件里包含了变量存储的相对地址等。 ","date":"2019-08-01","objectID":"/variable/:2:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"全局变量(extern) 在函数体外定义的变量，默认是全局变量。 针对上文提到的一个文件的代码可能需要使用另一个文件中定义的变量情况，推荐的做法是在头文件中声明，对应的源文件中定义的做法。因为声明可以多次，定义只能一次，这样头文件被其他许多文件包含时候，不会出现重复定义的错误。如果将全局变量的声明和定义放在一个头文件中，将不能使用头文件的方式在多个文件文件中共享变量，即使在头文件中加#pragma once，或#ifndef也会出现重复定义，因为每个编译单元是单独的，都会对它各自进行定义。这样的情况下，只能使用extern修饰的声明在其他文件中引用该变量。 举个例子： // 1.h 头文件 extern int a; //声明一个全局变量 // 1.cpp 源文件 int a; // 定义该变量，但没有初始化 // 2.cpp 源文件 #include\u003ciostream\u003e#include\"1.h\" // 以包含源文件形式引用变量using namespace std; //a = 1; //在全局中,语句的执行顺序是没有保证的,所以全局变量不能再函数体外赋值 extern void nm(); int main() { a = 2; nm(); cout \u003c\u003c ++a \u003c\u003c endl; return 0; } // 3.cpp 源文件 #include\u003ciostream\u003eusing namespace std; extern int a; // 以extern修饰形式引用变量 void nm() { cout \u003c\u003c a; } 上述程序结果输出为： 23 2.cpp采用包含头文件的形式引用全局变量，3.cpp采用extern 修饰的声明引用。两者都能正确共享变量。但是，如果在1.h中将声明改成定义，就不能使用头文件引用的形式了。 总之变量的使用前必须有声明，有定义。 另外，有一个问题是，在函数体之外，全局变量不能被赋值，因为函数体之外，代码块的执行顺序没有固定要求，视编译器而定，所以如果允许赋值的话，可能会造成先调用后赋值的情况，所以被禁止。 在上述例子中，2.cpp中引用1.h头文件，并且使用extern修饰的声明语句引用函数nm，在main函数体内，对变量a进行赋值，该变量在1.h中声明，1.cpp中定义，由于包含了1.h，所以2.cpp可以引用它。接着调用nm函数，nm函数来自3.cpp，功能是直接输出a,在3.cpp中是用extern关键字引用的该变量。在调用该函数之前，已经对a赋值过了，所以能够正确输出。实际上，在我的PC上用VS运行，假如在赋值之前调用nm，输出是：03，因为编译器给a默认初始化为0了吧。 ","date":"2019-08-01","objectID":"/variable/:3:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"静态全局变量(static) 注意使用static修饰变量，就不能使用extern来修饰，即static和extern不可同时出现。 static修饰的全局变量的声明与定义同时进行，即当你在头文件中使用static声明了全局变量，同时它也被定义了。 static修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其值复制给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并不影响本身在定义时的值。即在其他编译单元A使用它时，它所在的物理地址，和其他编译单元B使用它时，它所在的物理地址不一样，A和B对它所做的修改都不能传递给对方。 多个地方引用静态全局变量所在的头文件，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储。 ","date":"2019-08-01","objectID":"/variable/:4:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["C/C++"],"content":"全局常量(const) const单独使用时，其特性与static一样（每个编译单元中地址都不一样，不过因为是常量，也不能修改，所以就没有多大关系）。 const与extern一起使用时，其特性与extern一样。 extern const char g_szBuffer[]; //写入 .h中 const char g_szBuffer[] = \"123456\"; // 写入.cpp中 ","date":"2019-08-01","objectID":"/variable/:5:0","tags":["declartion","define"],"title":"C++变量声明与定义","uri":"/variable/"},{"categories":["Math"],"content":"假设检验（Hypothesis testing）是推论统计中用于检验统计假设的一种方法。而“统计假设”是可通过观察一组随机变量的模型进行检验的科学假说。一旦能估计未知参数，就会希望根据结果对未知的真正参数值做出适当的推论。 统计上对参数的假设，就是对一个或多个参数的论述。而其中欲检验其正确性的为零假设，零假设通常由研究者决定，反映研究者对未知参数的看法。相对于零假设的其他有关参数之论述是备择假设（Alternative hypothesis，记为或），它通常反应了执行检验的研究者对参数可能数值的另一种（对立的）看法（换句话说，备择假设通常才是研究者最想知道的）。 假设检验的种类包括：t检验，Z检验，卡方检验，F检验等等。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:0:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"假设检验步骤 最初研究假设为真相不明。 提出相关的零假设和备择假设。 考虑检验中对样本做出的统计假设；例如，关于总体资料的分布形式或关于独立性的假设。无效的假设将意味此检验的结果是无效的。 选择一个显著性水平 (α)，若低于这个概率阈值，就会拒绝零假设。最常用的是 5% 和 1%。 选择适合的检验统计量(Test statistic)T。 在设定零假设为真下推导检验统计量的分布。在标准情况下应该会得出一个熟知的结果。比如检验统计量可能会符合正态分布或学生t-分布。 根据在零假设成立时的检验统计量T分布，找到概率为显著性水平 (α)的区域，此区域称为“拒绝域”(记作RR或CR)，即在零假设成立的前提下，落在拒绝域的概率只有α。 针对检验统计量T，根据样本计算其估计值tobs。 若估计值tobs未落在拒绝域，则“不拒绝”零假设（do no reject ）。若估计值tobs落在拒绝域，则拒绝零假设，接受备择假设。 要注意的是一般不会将检验结果称作“接受”零假设，而是因没有显著证据证明零假设为非，所以“不拒绝”零假设。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:1:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"相关概念 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"原假设 也称为零假设（Null Hypothesis），即为你要对其进行检验的断言，除非有足够的证据进行反驳，否则你将接受这个断言。用符号$H_0$表示 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:1","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"备择假设 与原假设对立的断言称为备择假设（Alternative hypothesis），用$H_1$ 表示，如果有足够的证据拒绝$H_0$ ，我们就接受$H_1$ 二者不必涵盖所有可能结果 进行假设检验时，你假定原假设为真；如果有足够证据反驳原假设，则拒绝原假设，接受备择假设 我们根据原假设$H_0$ 选择检验统计量 我们需要检验是否有充足的证据反驳原假设。办法是：首先假设$H_0​$ 为真，然后寻找不利于$H_0​$ 的证据。先看看得出原假设观察结果的可能性多大。也就是说，取样本结果，然后计算发生这个结果的概率——通过求拒绝域实现这个目标 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:2","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"拒绝域 假设检验的拒绝域是一组数值，这组数值给出反驳原假设的最极端证据 问题是：当这些证据的强度达到多大时，我们能够坚决地拒绝原假设？我们需要通过某种方法指出何时能够合理地拒绝原假设——指定一个拒绝域即可实现这一目的 临界值（“c”）：我们把拒绝域的分界点称为临界值 为了求出假设检验的拒绝域，首先需要定下“显著性水平”。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:3","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"显著性水平($\\alpha$) 检验的显著性水平所量度的是一种愿望，即希望在样本结果的不可能程度达到多大时，就拒绝原假设$H_0$ ,像置信区间的置信水平一样，显著性水平用百分数表示 显著性水平常用希腊字母 $\\alpha$ 表示，$\\alpha$ 越小，为了拒绝 $H_0$ ，样本结果需要达到的不可能程度越高 单尾检验：即检验的拒绝域落在数据集的一侧，如果备择假设包括一个\u003c符号，则使用左尾，此时拒绝域位于数据的的极端，\u003e符号则相反 双尾检验：即拒绝域一分为二位于数据集的两侧，你选择检验水平 $\\alpha$ ,然后将拒绝域一分为二，并确保整个拒绝域以相应的概率反映这个检验水平。两侧各占 $\\alpha/2$ ,因此总和为$\\alpha$ ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:4","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"$p$ 值 即某个小于或者等于拒绝域方向上的一个样本数值的概率。具体求法是利用样本进行计算，然后判定样本结果是否落在假设检验的拒绝域以内，也就说我们通过 $p$ 值确定是否拒绝原假设，$p$ 值小于显著性水平 $\\alpha$，拒绝原假设。 已经求得P值的情况下，可以用它来检查我们的样本是否落在拒绝域内。以显著性水平5%的左尾检验为例，这意味着，如果 $p$ 值小于0.05，就能拒绝零假设。 检验统计量：检验统计量就是用于进行检验的变量 一旦确定了检验的显著性水平，就无法改变 第一类错误: 错误地拒绝原假设 第二类错误：错误地接收原假设 发生第一类错误的概率等于你的结果位于拒绝域以内的概率。由于拒绝域由检验水平决定，说明如果检验的显著性水平为$\\alpha$ ， 则发生第一类错误的概率必须也等于$\\alpha$ ，即： $$ P(第一类错误)=\\alpha $$ 其中 $\\alpha$ 为检验的显著性水平 发生第二类错误的概率要比求第一类错误的概率难得多，其通常用希腊字母$\\beta$ 表示， $$ P(第二类错误)=\\beta $$ 求解步骤如下： 检查是否拥有 $H_1$ 的特定数值 没有这个数值则无法计算第二类错误概率 求检验拒绝域以外的数值范围 假设检验统计量已经标准化，则该数值范围要进行逆标准化 假定 $H_1$ 为真，求得到这些数值的概率 也就是说，我们要求出得到拒绝域以外的数值的概率，但这一次用 $H_1$ 而不是 $H_0$ 对检验统计量进行描述 只有在备择假设具有唯一特定值时才能计算第二类错误的发生概率 假设检验的功效即你正确地拒绝一个假原假设的概率 $$ 功效=1-\\beta $$ 方差已知情况下求均值是Z检验。 方差未知求均值是 $t$ 检验（样本标准差 $s$ 代替总体标准差 $\\sigma$，由样本平均数推断总体平均数） 均值方差都未知求方差是 $\\chi^2$检验 两个正态分布样本的均值方差都未知情况下求两个总体的方差比值是 $F$ 检验。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:2:5","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"Z检验 ","date":"2019-05-14","objectID":"/hypothesis_testing/:3:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"Z检验量(Z-statistic) $$ Z=\\frac{\\overline{X}-\\mu_{\\overline{x}}}{\\sigma/\\sqrt{n}}=\\frac{\\overline{X}-\\mu_{\\overline{x}}}{s/\\sqrt{n}} $$ 当 $n$ 大于等于30时，其分布接近正态分布，否则其分布为 $t $ 分布，因为当样本容量较大时，我们可以通过样本标准差来估计总体标准差，这样相当于总体方差已知。而样本容量较小时，我们不能通过样本来估计总体方差，这时相当于总体方差未知，属于 $t $ 分布 ","date":"2019-05-14","objectID":"/hypothesis_testing/:3:1","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"实例 制药公司宣称他们的新药能够在两周内治愈90%的打鼾患者，外科诊所医生决定对药物进行试验，验证制药公司的说法是否可信，他随机抽取了100名患者，用该药进行了两周的治疗后，有80个人被治愈。现在要通过这个样本来对制药公司的断言进行 $Z$ -检验 确定假设 $H_0:p=0.9, H_1:p\u003c0.9 $ 即原假设为治愈率为90%,备择假设为治愈率小于90% 选择检验统计量 原分布为二项分布，当样本容量较大时，可以用正态分布近似代替二项分布，此时有$X\\sim{N(np,npq)}$ 例子中有 $X\\sim{N(90,9)}$ 经过标准化得到，$Z=\\frac{X-90}{\\sqrt9}=\\frac{X-90}{3}​$ 也就是说，我们的统计量可以是$Z=\\frac{X-90}{3} ,Z\\sim{N(0,1)}$ ,我们将$Z$作为统计量是因为通过它可以轻松查出概率，进而了解在以制药公司断言为前提下，我们的样本结果的不可能程度如何。我们将80代入$X$，这样就能求出治愈人数为80或以下的概率 求出拒绝域 有了检验统计量后我们还要求拒绝域。由于我们的备择假设为 $p\u003c0.9$ ，这表明拒绝域位于左尾，拒绝域还取决与显著性水平，这里取显著性水平为5% 由于$Z$ 统计量符合标准正态分布，于是可以用概率表查出临界值 $c$。 由于我们的显著性水平为5%,于是临界值 $c$ 等于令 $P(Z\u003cc)=0.05$ 的数值，通过概率表可以查到该值为-1.64 这说明只要检验统计量小于-1.64，我们就有足够的证据拒绝原假设 求出p值 拒绝域位于分布的左尾，治愈人数为80，那么80对应的Z 值为(80-90)/3=-3.33 $p$ 值算法为 $P(Z\u003cz)=P(Z\u003c-3.33)$ 查看检验统计量是否位于拒绝域内 如果 $p​$ 值小于0.05(显著性水平)，则检验统计量位于拒绝域中，此例中，检验统计量为0.0004，明显位于拒绝域中 做出决策 拒绝原假设 ","date":"2019-05-14","objectID":"/hypothesis_testing/:3:2","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"t检验 T检验是用于两个样本（或样本与群体）平均值差异程度的检验方法。它是用T分布理论来推断差异发生的概率，从而判定两个平均数的差异是否显著。 T检验的适用条件为样本分布符合正态分布。 T检验的应用条件： 当样本例数较小时，要求样本取自正态总体； 做两样本均数比较时，还要求两样本的总体方差相 等。 T检验的用途：（1）样本均数与群体均数的比较；（2）两样本均数的比较。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:4:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"t检验例子 样本与总体均值的比较 大量检测已知正常人血浆载脂蛋白 $E(apo E)$ 总体平均水平为 $4.15mmol/L$。某医师经抽样测得41例陈旧性心机梗死患者的血浆载脂蛋白E平均浓度为 $5.22mmol/L$，标准差为$1.61mmol/L$。据此能否认为陈旧性心肌梗死患者的血浆载脂蛋白$E$平均浓度与正常人的平均浓度不一致？ 建立检验假设和确定检验水准。 ​ $H_0: \\mu=\\mu_0,H1: \\mu≠\\mu_0,\\alpha=0.05$​，双侧检验； 选定检验方法和计算统计量。用单样本的t检验， $$ t=\\frac{\\overline{x}-\\mu_0}{s_{\\overline{x}}}=\\frac{\\overline{x}-\\mu_0}{s/\\sqrt{n}}=\\frac{5.22-4.15}{1.61/\\sqrt{41}}=4.26 $$ ​ 自由度 $v=41-1=40$ 确定P值和作出推断结论。 查 $t$ 分布表，$ t_{0.05/2,40}=2.021$, $ t=4.26\u003et_{0.05/2, 40}$,$P\u003c0.05$​。按 $\\alpha=0.05​ $水准，拒绝 $H_0$​，接受 $H_1$​，可认为陈旧性心肌梗死患者的血浆载脂蛋白$E$平均浓度与正常人的差别有统计学意义，结合专业可以认为前者平均浓度较高。 配对设计定量资料的 $t$ 检验 • 配对设计的 $t$ 检验研究的是差值均数（样本均数）与理论上的差值总体均数的比较。 • 首先计算出各对差值 $d$ 的均数。当两种处理结果无差别或某种处理不起作用时，理论上差值d的总体均数 $μ_d=0$ • 可将配对设计资料的假设检验视为样本均数与总体均数 $μ_d =0$ 的比较，据定理： $$ t=\\frac{\\overline{d}-\\mu_d}{s_{\\overline{d}}}=\\frac{\\overline{d}-0}{s_d/\\sqrt{n}}=\\frac{\\overline{d}}{s_d/\\sqrt{n}}\\sim{t(n-1)} $$ 将大白鼠配成8对，每对分别饲以正常饲料和缺乏维生素E饲料，测得两组大白鼠肝中维生素A的含量，试比较两组大白鼠中维生素A的含量有无差别。 大白鼠配对号 正常饲料组 维生素E缺乏组 差数d 1 3550 2450 1100 2 2000 2400 -400 3 3000 1800 1200 4 3950 3200 750 5 3800 3250 550 6 3750 2700 1050 7 3450 2500 950 8 3050 1750 1300 Mean 3318.75 2506.25 812.5 建立检验假设和确定检验水准 $H_0: \\mu_d =0,H1: \\mu_d ≠0,\\alpha=0.05$，双侧检验； 选定检验方法和计算统计量 $$ \\overline{d}=\\frac{\\sum d}{n}=\\frac{6500}{8}=812.5(U/g) $$ $$ S_{\\overline{d}}=\\frac{S_d}{\\sqrt{n}}=\\sqrt{\\frac{7370000-(6500)^2/8}{8\\times(8-1)}}=193.1298(U/g) $$ $$ t=\\frac{\\overline{d}-\\mu_d}{S_d-\\sqrt{n}}=\\frac{812.5-0}{193.1298}=4.2070, v=8-1-=7 $$ 确定p值和作出推断结论 查t分布表（双侧），$ t=4.2\u003et _{0.05/2, 7} =2.365,p\u003c0.05$。按$ \\alpha＝ 0.05$水准，拒绝$H_0$ ，接受 $H_1$ ,可以认为两种饲料喂养的两组大白鼠中维生素A的含量有差别。正常饲料组比缺乏维生素Ｅ饲料组的含量要高。 ","date":"2019-05-14","objectID":"/hypothesis_testing/:4:1","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["Math"],"content":"参考 https://www.jianshu.com/p/46d9b111dffc ","date":"2019-05-14","objectID":"/hypothesis_testing/:5:0","tags":["Statistical","Hypothesis Testing"],"title":"假设检验","uri":"/hypothesis_testing/"},{"categories":["English"],"content":"作者：若愚英塾 链接：https://www.zhihu.com/question/294752032/answer/2141847794 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2019-04-17","objectID":"/grammar/:0:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"主语谓语 我自己是主语，我做出的动作是谓语，我的动作碰到了某一个物体，它是宾语，我的动作让这个物体发生了什么样的运动状态变化叫宾补。 比如歌曲《Yesterday Once More》里有一句，It made me smile. 它使得我笑了起来。这句话就是这样的情况。（当然，这样的表述其实没能涵盖所有的宾补情况，这里为了让人便于理解就先采取了能涵盖大多数情况的表述形式，且看后面）。 宾补，就像补丁一样，裤子上的补丁是为了弥补裤子上的漏洞，衣服上的补丁是为了遮住衣服上的漏洞，软件的补丁就是为了补充软件在设计上的漏洞。同样地，宾补就肯定是宾语上的补丁，是为了弥补上宾语意思上的漏洞，也就是说宾补是为了为宾语补充一些信息，它补充的信息是为了更好地说明宾语。举个例子，如果你说I find English….那这句话就不完整，你发现了英语？英语是你发现的么？所以 我们一般说I find English easy. 这里的easy 就是一个补丁，它补充的是宾语English的意思上的不足，这也是宾补的一种形式。 ","date":"2019-04-17","objectID":"/grammar/:1:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"宾语 宾即客，我们经常说，客随主便，客总是接受和顺从主人的安排，总是处于一个被支配被限制的地位。 正因为如此，所以英语里把接受动作的东西叫宾语。客，永远是暗含着受牵制的意思，比如游客要遵守旅游地的规矩，乘客要听从交通工具运营方的安排，所以客不是一个会单独出现的概念，一谈到客，就必然会提到主。英语中宾语是OBJECT，它又有物体、对象、目标的意思，这是西方人的思维方式，OBJECT是被外力作用的物体，是一个动作作用的对象，是一个动作所要到达的目标物。但是中文就博大精神了，一个宾语就涵盖了所有。 ","date":"2019-04-17","objectID":"/grammar/:2:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"表语 我所表现出来的各种属性就是表语，比如我是什么样子，我是什么职业，我是在哪里，我看起来怎么样。这些是表现在其他人眼里的我的样子，所以只能称作是一种表象，所以我们把这样的成分叫做表语。而我和这个表象之间需要用一个东西联系起来，这个东西在英语里面叫做联系动词，有的时候也简称为系动词。 这里所说的属性有好几层意思： 第一，事物本身的属性，比如形状、大小、气味、年龄、动作状态等； 第二，事物的社会属性，比如身份、地位、职业等等； 第三，事物的时空维度属性，比如事物所处的位置，所对应的时间。 这里的所说的属性就没有我们通常所想的那么狭隘，相反非常宽泛。表语不是一个单独出现的概念，就如同舅舅和外甥，丈夫和妻子必然是同时存在的一对概念一样，不可能孤立地出现一个人就是舅舅，或者就是老公。 表语也不会单独出现，有表语那么必然就会有主语。因为表语表达的是主语的属性，主语和表语拿一根线连接起来，这根线就是联系动词。 汉语中你可以说我很好, 但是英语当中你就不可以直接说 I fine, 这两个单词中间需要用一个东西把它们联系起来，这就是我们所说的连系动词。联系动词就像一条纽带，把一个事物和它的属性联系起来。联系动词又像是一个渠道，把一个事物的属性散发出来。比如She sounds sweet. 她声音听起来很甜美，可能她看起来很粗犷。她很甜美这个属性是通过听觉的渠道传达出来的。 ","date":"2019-04-17","objectID":"/grammar/:3:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"状语 我一定是在特定的时间特定的地点特定的条件下因为特定的原因带着特定的目的以特定的方式做出的某个事情，这个事情造成了一定的结果，这些就都是状语。（有人说看不懂这句话，我在后面更新了点内容作为补充）也就是说，你做任何事情都有目的，做任何事情都是在某一时间做的，都是在某一地点做的，都是以某一种方式做的，都是在一定条件下做的，都是一定原因导致的，都会造成一定的结果，这些东西其实都是状语。 一言以蔽之，对于一个动作（事情）本身，你心中所泛起的所有疑问，都是状语。 比如，你说，走。那么，走到哪里，为啥走，怎么走，什么时候走，从哪走，和谁走，这些问题的答案都是状语。记住，是围绕动作本身所泛起的所有疑问。（等完全理解这一点以后，我可以再拓展状语的外延） 再比如，一个美女走到你面前，对你说“到我家来吧”。你脑海中一定会想，为啥到你家去？怎么去？什么时候去？她在什么条件下说出这样的话的？她让我到她家是什么目的？这些疑问的答案都是状语。 这个美女是如此热情地邀请你，以至于你一天上班心神不宁。 这个美女比电影明星网红还要好看十倍百倍。 最后你决定，无论今天有多少工作要做，你都要推掉一切去那个美女家中。 这里加黑体字的部分如果用英语表达出来依然是状语，具体是啥状语，你自己想想吧。 状语的门类很大，其中还有用句子来做状语，那么这个句子也就变成了所谓的状语从句。 那这里就来简单的说一说什么叫做状语从句。既然是简单说说，那么这就不是深入探讨，这里只是为了把本质的东西说明白。 什么叫做时间状语从句呢？时间状语从句，其实很简单，它就是用一个句子来表示一个特定的时间点。你可能觉得很奇怪，为什么他不直接说几点几分发生了什么样的事情，而非要用一个句子来表达一个时间点呢？那就是因为，并不是所有时候他都在看表的，并不是所有时刻都有条件来精确计量时间的。 比如如果我们要表达一个句子，我们想说，当你昨天给我打电话的时候，我正在看电视。When you rang me up yesterday, I was watching TV. 其实我并不知道你给我打电话的时候是几点几分，所以我只能用这样一个句子来表达那个时间点。那么这个表达时间点的句子，在英语当中就是时间状语从句。 同样的什么叫做地点状语从句呢？地点状语从句就是用一个句子来表达一个事件发生的地点。因为在日常生活中，不可能像专业的人士一样，随时随地记录这个地点的具体地址，或它的经纬度以及坐标。所以人们在说话的时候，经常会用一句话，来描述一个事情发生的地点，那么这样的一句话，实际上就是一个地点状语从句。 比如我们要表达这样一个意思，在我们昨天买衣服的地方，我又遇到了那个人。I came across that guy again where we bought our sportswear. 那么这里的“在我们昨天买衣服的地方”实际上就是一个地点状语从句，它只是为了描述一个地点。之所以把它叫做一个从句，是因为它只是一个从属的部分，而并不是说话的人想要表达的主要意思。 那么什么叫做原因状语从句呢？可以同样地来理解，任何事情发生都是有一个原因的。美国人总喜欢说一句话，God does make everything happen for a reason。当你用一句话，来表达一件事情发生的原因，那么这句话就只是一个原因状语从句而已。比如你想说这样的话，你们家的小宝贝不喜欢吃猪肉，因为他觉得那是佩奇的肉My little toddler doesn’t like pork, because he believes it’s Peppa’s meat. 那么这里的“因为他觉得那是佩奇的肉”实际上就是一个原因状语从句。这一部分并不是说话的人想要说的主要部分，而只是为了做一个铺垫，说明原因，所以它只是一个从属的部分，因为它表达了原因，所以是原因状语从句。 再举一个我经常会举的例子，你走进老板办公室，你对他说，因为我病了，所以我今天想请一天假。这里的这句“因为我病了”，并不是你想要表达的主要的意思，你想要表达的主要的意思，实际上是后半句，是你想请假，所以前面那半句，只能是原因状语从句。 我一定是在特定的时间特定的地点特定的条件下因为特定的原因带着特定的目的以特定的方式做出的某个事情，这个事情造成了一定的结果，这些就都是状语**。 你做任何事情肯定是在某一个时间去做的吧，你做任何事情也肯定是在某一个特定的地点做的吧，你不可能在一个不存在的时间和不存在的地点做了某一件事。所以时间和地点经常是用来描述某一个动作的，如果你单单说一个时间，单单提到一个地点，而这里没有任何事情发生，那么这个时间和地点就没有任何意义。 你做任何事情都是在一定的条件下去做的吧？比如你在考试之前，可能会跟你的父母提条件，你说如果我考到第一名，你就给我买个新的电话。这里你就是在和你的父母提条件，你的父母不可能平白无故就给你买个电话的，只有在你考到第一名的前提下才会给你买这个电话。 同样地，你做任何事情都有一定的目的。比如，你穿得十分帅气，从你的美女同学面前一遍一遍走过，你的目的就是为了引起她的注意。 你这一辈子做任何事情都是通过某一种方式去做的。比如，你上学你可以坐车去，可以骑车去。比如，你说话你可以高谈阔论，你可以细声细语，这些都是你说话的方式。 你做任何事情都会造成一定的结果，这里多多少少有了一点禅意。因为佛教认为，你的言语，行为，动念都会产生一定的结果，这些东西都叫做你的业，这些业终究会造成某一种结果，这叫做报。当然，我们不是在这里探讨宗教，我们就是探讨世界上任何的行为都会产生一定的结果。比如他们一心向佛，以至于终成正果。这样的例子好像不明显，那再来一个，他的声音很大，以至于墙角的蜘蛛网都在微微颤动。蜘蛛网微微颤动其实就是在修饰他的声音之大，也是其声音造成的一种结果，所以体现在英文句子当中，后句就只能是前句的结果状语。 所以，所谓的一件事情发生的时间地点原因条件目的结果等等皆可归入状语之中。我这里只是尽量通俗地去说明状语这个概念。但是英语里的状语概念实在太大，所以这里的说法也只涵盖了对于动词的修饰，而对于形容词和副词的修饰的状语，那就比较容易理解了。 ","date":"2019-04-17","objectID":"/grammar/:4:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"定语 把一个东西的某些属性确定下来的成份就叫定语，说白了就是把一个东西是什么样子限定出来的那些语言就叫做定语。 **我在生活中如果不用定语的话，这会给我带来很多麻烦，**我去买衣服，我如果仅仅告诉导购“我要买衣服”，然后就缄口不语，我估计导购可能会骂娘。因为衣服这个概念太宽泛了，其实帽子鞋子袜子文胸裤腰带也都是衣服的范畴，你直接来一句要买衣服，而不说买什么样的衣服，这就是找打的节奏啊。 你一定要说你是要买什么样子的衣服，比如红色的衣服，比如裘皮的衣服，上身穿的衣服，外面穿的衣服，里面穿的衣服，这些把某个东西限定下来的成分就叫定语。否则你光说你要衣服，那么对方就无法确定，也正是因此，所以顾名思义定语在中文中被翻译成定语。英语中定语叫做attribute modifier，attribute 是属性的意思，modifier是修饰语的意思。是不是这样就很容易理解定语为啥叫定语了？ ","date":"2019-04-17","objectID":"/grammar/:5:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"同位语 当孙悟空说出那句：俺老孙乃五百年前大闹天宫的齐天大圣。你要知道，这句话里面“老孙”就是指“俺”，“俺”就是指“老孙”。在英语里面，这样位置一样成分一样的两个东西，后面的叫做前面的同位语。虽然前后成分所指的东西都是一样的，但是在研究英语的过程中，我们只说后面的是前面的同位语，而不说前面的是后面的同位语。 单纯的同位语都好理解，比如我们中国人是一个不畏强暴的民族。这句话翻译成英文的话，“中国人”就是“我们”的同位语。 但是英语中有一种用一个句子来做同位语的，那就叫同位语从句了，同位语从句就是先说一个词，然后用一个句子来解释这个词，记住哦，我说的是用一个句子来解释这个词，这个句子的意义必须等于前面这个词。 化学中有个概念叫做同位素，英语中有个东西叫做同位语。同位素是指在元素周期表当中占据相同位置的物质，质子数相同中子数不一样，但是他们属于同一种元素。同样，同位语也指的是在句子中占据位置相同，担任成分相同的东西。唯一不同的是，同位素可以互称同位素，比如氕（¹H）、氘（²H）、氚（³H）可以互称同位素，而英语中的同位语一般是说后面成分担任前面成分的同位语。 ","date":"2019-04-17","objectID":"/grammar/:6:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"虚拟语气 虚拟语气就是某一种情感的抒发，要么后悔过去做了某事，要么庆幸过去没做某事；要么期望现在拥有某物，要么希望现在做成某事；要么期望将来永远不要发生某事，要么幻想将来能有某事发生。但无论如何，他们都知道这些事情发生的几率很小，或者根本不希望这些事发生。 早知如此绊人心，何如当初莫相识。这是后悔，与过去相反，早知道感情如此牵绊，又何苦坠入这温柔乡里？但是一切已经发生了。 如果不曾遇见你，我将会是在哪里？这是庆幸，也是与过去相反。如果今生不曾相遇，有需要经过几世轮回才能积攒到遇见的缘分？ 假如你不曾保护我，我的命运将会是什么？这是庆幸，与过去相反，说话的人一定是被保护得很好。 如果大海能够唤回曾经的爱，就让我用一生等待。这是与现在事实相反，大海是换唤不回你的爱的。 好吧下辈子，如果我还记得你，你的誓言可别忘记。这是与将来相反，希望即便是走过奈何桥，喝过孟婆汤，依然可以彼此记得前生的缘分，依然在茫茫人海当中可以再次遇见，而说话的人自己也知道，这样的几率太小。 他年我若为青帝，报与桃花一处开。这是对将来的美好憧憬，当时黄巢意气风发，畅想着有一天可以坐拥江山，但是无论如何他也成不了青帝之神。所以这也只能是对将来的美好憧憬而已。 山无陵，江水为竭，冬雷震震，夏雨雪，天地合，乃敢与君绝。对未来的虚拟，这是表达对未来的憧憬，无论如何也不愿分离，因为她列举的这些情况基本不可能发生，至少在他们的年代是认为不可能发生的，这里就不要谈什么地质运动了。 若非一番寒彻骨，哪得梅花扑鼻香？ 这是与过去事实相反，正是因为经历了彻骨之寒，才修炼成香气四溢的梅花。 当陈胜，辍耕之垄上说出：苟富贵“无相忘“的时候，他一定用的不是虚拟语气，因为他相信自己一定能做成大事，而一边听这句话的人，绝对是按照虚拟语气来理解的，因为他说”若为佣耕，何富贵也？“。所以一句话是不是虚拟语气也要看谁说出来，如果比尔盖茨说，如果我现在有一个亿的话，……和一个普通人说出来这句话，感觉就是不一样，比尔盖茨说这句话，那就不是虚拟语气，而你说这句话，很大程度上就是虚拟语气。 在日常生活中还有一种情况总是需要用虚拟语气的，比如在合同中约定，如果甲方未能履约，…… 这种情况是我们不希望未来会发生的，所以我们要用与未来相反的虚拟语气。If Party A should not fulfill the conditions，…。很多时候在合同文本当中会采取一种省略形式，Should Party A not fulfill the conditions,…，还是要适应这种虚拟语气的。 ","date":"2019-04-17","objectID":"/grammar/:7:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"主从关系 主句和从句之间的关系就像主人和随从一样。 主人往往可以做重要的决定，而随从只是辅助主人。同样的，主句往往是表达说话的人想要表达的主要意思，而从句所表达的含义就不是说话人所要表达的主要意思。不信的话，这里来举一个简单的例子，比如你和你的老板说， Because I feel sick， I want to ask for a leave.那么你觉得哪半句是说话的人想表达的主要意思呢？你是只想告诉你的老板你病了，还是真正想说你要请假？这里的答案是显而易见的，如果你只是告诉你的老板你病了，那么你的老板很大概率会跟你说，注意身体，回去工作吧。 再打一个不太合适的比喻，主句就像电脑，而从句则是像鼠标、优盘、音箱、耳机等外设，你使用电脑一定是主要为了使用电脑，绝对不是为了使用你的鼠标，而去再配一个电脑。电脑绝对是主体，其他的都是附属，所以都是外设。 ","date":"2019-04-17","objectID":"/grammar/:8:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"冠词 冠就是帽子，冠词就是像帽子一样的词，戴在名词的前面。 定冠词就是能确定那个戴帽子的名词的身份的冠词，比如一个厨师戴着帽子，一个警察戴着帽子，你都能认出他们的职业；而如果随便带一个棒球帽，你是认不出他的职业的，所以当你不确定是哪一个东西的时候就要用不定冠词，而你知道你想说的是哪一个东西的话，就用定冠词。所以最高级前面一般加the，因为最怎么样的是一眼就能看出来的，大家都能知道的 所以用定冠词了。 序数词为啥要加定冠词？举个例子，某一次考试之后，你们班第一名第二名一直到最后一名是不是都确定了？所以呀，每次考完只有一个第一名，也只有一个第二名，在不考虑并列的特殊情况下，所有的名次的归属都是确定的，所以序数词前面要加定冠词。 最高级为啥要加定冠词？举个例子，如果我问你们班最高的人叫啥名字，你一定会直接说出来名字，因为个子最高的那个人肯定是确定的，不可能一个班里的人的身高还随着气温的变化而热胀冷缩。 为啥比较级就不能加定冠词，如果我问你班上比较高的是谁，你可能一下说出一大堆，这些名字是完全不确定的，因为啥叫比较高就很难界定，所以比较级前面一般不用定冠词。 ","date":"2019-04-17","objectID":"/grammar/:9:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"情态动词 表示一个人主观意愿状态的动词，之所以叫做情态，是因为说的是感性和主观。 所以 任何情态动词其实都暗含着“我觉得”的意思。如果你对你妈说，I must have a new phone or I will die. 你妈是绝对不会搭理你的，因为没新手机绝对不会死的，只是你自己觉得不拿到新手机心里会很不爽。但是你如果说I have to breathe, otherwise I will die. 那么这就是说 你必须呼吸，否则就会死，这是就不是主观意愿了，这是客观要求。 ","date":"2019-04-17","objectID":"/grammar/:10:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"复合句 复合维生素就是一个药片里含有了好几种维生素，那么复合句就是一个句子里含有了好几个完整的句子。 ","date":"2019-04-17","objectID":"/grammar/:11:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"音节 音节就是声音分成一节一节的，节就是相对独立的发音的单位。很多东西都是一节一节的，比如竹子，一节一节的；再比如时间也是可以分为一节一节的，一年分为了24节，就是24个节气；上课也是一节一节的，火车也是一节一节的，包括我们人体也是一个个关节组成的。 汉语都是单音节词（除了个别硬造出“瓩”“兙”这样的字以外），英语的音节和汉语的音节不同在于它有辅音构成的音节尾（coda），比如dog这个词中有g这个音作为音节尾，而这在汉语普通话里是不存在的，音节开始的部分也会有辅音从（st，tr等），也就是两个辅音形成的音节头，这在汉语中是不存在的，汉语中的音节头都是单纯的辅音，所以在英语当中dog 这是一个音节，因为g只是一个音节尾，它是一个辅音，非常短促，并不构成完整的发音单位。而English这个词，也只有两个音节，Eng——lish，第一个音节中的g 和第二个音节中的sh都是音节尾，它们并不构成完整的发音单位。值得一提的是，很多中国的学习者，通常会把音节尾巴延长成另一个音节，比如dog 读成了 类似道哥的音，其实就相当于在音节尾后面又悄悄加了一个元音。 ","date":"2019-04-17","objectID":"/grammar/:12:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"元音 就是最简单最基本最省力就能发出来的声音，只需要用嗓子就能发出的声音，而不需要动用嘴唇舌头牙齿等等。 你看一些词语，元素、元帅、元凶、单元，只要带“元”字的单词都是为了表示最基本最简单最重要的意思。辅音顾名思义就是起辅助作用的音，只是为辅佐元音的，所以辅音都很短暂，你听到的语言的大部分响亮的声音其实都是元音。 ","date":"2019-04-17","objectID":"/grammar/:13:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"副词 正如有县长就有副县长，有村长就有副村长，所有副职的人都是为正职人当帮手的，副词也是为了一个比它更重要的词当帮手。 之所以把它叫做副词，因为它永远也改变不了千年老二的地位，它永远只能补充信息，而不能表达主要信息。就像任何组织当中的老二一样，永远只能干一些琐碎的活，做一些辅助的工作，重要的决定还是需要老大去做。就像领导和司机的关系，司机永远不能代替领导去开会，更别说在会上发言了。在句子当中也是一样的，副词作为副词永远也无法表达重要的意义，它永远也无法替代它为之服务的那个词，比如说He runs fast.这句话里fast就是副词，我们可以说它是run的副词。如果我们说He runs，那么还是可以表达一个比较清晰的意思，但是如果我们把run去掉，说He fast.那么我们就不知道他到底是什么快，fast 永远也不能代替run,它只能为这个词服务。所以副词在这句话里它的地位就是比不上run，所以它只能是副词，是一个相对不重要的地位。副词也有它的业务范围，它的业务范围就是为动词、形容词以及副词提供服务，是的你没看错，副词还可以修饰副词。比如我们可以说He runs very fast.这里的very就是一个副词，而它是修饰fast的，这就是所谓的副词为副词服务，或者说副词修饰副词。 一提到副词，好像就应该存在一个东西叫做“主词”的，其实英语当中还真的存在主词这样的说法，但是主词并不是对应于副词而言的，而是主语的另外一种叫法。但是我们这里为了更好地理解副词，我们可以假设另外一个与副词相对应的东西叫做主词。而这个主词永远要比副词更重要，之所以说它比副词更重要，是因为它在表达意义上，比副词传达更重要的信息。比如 She is very attractive. 这里面attractive 就是要比very更重要，你可以去掉very，句子变成She is attractive. 依然是表意完整的，但是如果去掉attractive，She is very. 这个句子就是个残缺不全的。所以very只能是个副词而已。 ","date":"2019-04-17","objectID":"/grammar/:14:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"介词 介就是指中介，就像结婚的介绍人一样，有介绍人才能将两人撮合到一起。所以介词就是把两个东西的关系确定下来的词。比如桌子上有本书，桌子和书需要用一个on来确定两者关系。 不定式的英文是infinitive ，维基百科说这个词源于拉丁词汇：The word is derived fromLate Latin[modus] infinitivus, a derivative ofinfinitusmeaning “unlimited”.也就是说“不限定，无限制”的意思，那么有infinitive 就会有finite，有不定式好像就应该有一个叫做“定式”的东西，虽然这叫法在英语里不存在。但是为了便于理解，作为对比我们暂且这样叫着。啥叫动词的“定式”呢？这样解释下吧，动词的“定式”就是主语直接发出那个动作，或者说是句子的谓语，那个动词把句子的时态人称单复数都确定下来了，我们就因此把它暂时叫做动词的定式吧。动词的“定式”定的是句子的时态人称单复数等主要信息，所以不定式于此相反，体现不出任何时态人称单复数，故称之为不定式。 ","date":"2019-04-17","objectID":"/grammar/:15:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"形容词 形，原来指人的体形和身材，容，原来指人的容貌，形容这个词原来是指人的身材和长相。屈原就写道：“颜色憔悴；形容枯槁”，这里的形容就是指人的身形和面容，当然，这里颜色指的也是脸的色泽，颜指的是脸，色才是颜色。 现在在语言学当中，形容词就是指一切用来说事物的属性的词了，好像世界上的任何一个事物都像人一样有了容貌和身形一样，这万事万物的容貌和身形其实就是它们各自的属性。 ","date":"2019-04-17","objectID":"/grammar/:16:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"时态 就是用看得见的动作或者状态，来体现看不见的时间。任何事情的发生都伴随着时间的流逝，只不过你看不见而已。 时间你是看不见的，这一点很容易理解。你衰老时你也感觉不到时间在你的额头刻下皱纹，你患病时你也看不见时间在吞噬你的健康。也许你会觉得你是一个被时间遗忘的人，一天闲的蛋疼，但是无论你做什么事情依然是在你的生命里扣除不再回回来的些许瞬间。 时态是由看不见的时间和看得见的动作状态组成的。或者说它是把一个动作拆成了时间和动作状态两部分。因为任何一个动作实际上都伴随着一定的时间，而任何一个时间点实际都伴随着一个动作状态，抛开动作谈时间就是空谈。 时间概念分为过去，现在，将来，而这三者加在一起就成了永远。至于永远有多远，没有谁知道。 动作状态分为正在进行，已经完成，规律性发生三种。 下面从生活体验的角度说下时态。 动作状态和时间相互组合就成了英语中的各种时态。比如正在进行的动作，放在过去就叫做过去进行时，放在现在就叫做现在进行时放在将来就叫做将来进行时。 从通俗的角度讲，时态就是每个人的生活状态，也是每个人的情感状态。人的一生会经历很多事情，有的事情过去了就过去了，没有任何留恋，你渐渐地会淡忘。只是在很久以后，和人谈起。你可能会告诉别人你在青春年华所做的那些事情，只是提起而已，这些事情和你现在几乎没有什么关联，而这些事情一般就可以使用一般过去式。 去年今日此门中，人面桃花相映红，这是过去；想当年，金戈铁马，气吞万里如虎，这是过去；遥想公瑾当年，小乔初嫁了，雄姿英发。 羽扇纶巾，谈笑间，樯橹灰飞烟灭，这是过去；晋太元中，武陵人捕鱼为业，这是过去；庆历四年春，滕子京谪守巴陵郡，这是过去；窗外疏梅筛月影，依稀掩映，吾与汝并肩携手，低低切切，何事不语，何情不诉！这还是过去。无论是哪一种心境，都已湮没于岁月的长流之中。如古人云：濯足长流，抽足再入，已非前水。 当过去的一切和现在毫无瓜葛的时候，那就是一般过去时。 过去事情就过去了，往者不可谏，来者犹可追。每一个人都应该是立足现在而期待将来的，过去的事情可作为镜鉴，但不能让过去的事情久久萦绕心间，不能为了一杯洒掉的牛奶，哭出一盆的眼泪。当你可以超然地回望着过去的时候，当过去和现在不再牵绊的时候，**你基本上用的就是一般过去时。**因为当你说起这些事情的时候，就好像在说起另一个毫不相干的人，发生在那个人身上的事情已经无法拨动你的今日的心弦。你令人心碎的初恋，当初花前月下成双入对，而最后天各一方，这都已经是过去，你现在过得开心，回头看的时候，你心中用的是一般过去时。 漫步在人生的数轴之上，蓦然回首，透过岁月的风尘，一般过去时是一个遥远的孤岛，你可以超然地看那时发生的一切，因为现在的你已经不是那时的你。那时的一切已经不能影响到现在的你。过去的痛苦是快乐，虽然当时有百般不堪万般无奈，现在你心中却有一种俱往矣的超然，这就叫做一般过去时。一般过去时之所以叫一般过去时是因为已经过去了，而现在完成时之所以叫现在完成时是因为还藕断丝连。现在完成时说是“完成”，其实并未“完成”。为什么这样说呢？现在完成时虽然说的是到此时此刻为止发生的事情，但是很多时候到此时此刻为止的事情并不会戛然而止。比如，在此时此刻，你和某个相恋数年的女孩已分手，你能否真正慧剑斩情丝，抛却过往走向新生呢？如果你依然心存留恋，那么这里现在完成时就出现了，I have broken up with her. 你嘴上说分手了，但心里还在回味一起度过的美好瞬间，这就是现在完成时所说的“此刻之前的动作对此刻以后的影响”。 完成时的宿命就是永远是有言外之意，也就是说永远话里有话。虽然叫做“完成时”，其实并没有“完成”。 当你说一句现在完成时的句子的时候，其实你肯定是后面还有话要说的。比如你说，I have worked so long.你下一句肯定是想说，我已经太累了。比如你说，He has waited for her for ten years.你下一句肯定想说“人生能有几个十年啊”之类的话。当你说I haven’t finished my homework. 你后面一定会说“现在我没时间和你唠嗑”之类的话。所以这就叫做完成时永远是有言外之意。 而人生又充满了情感的起起伏伏，有时候你会回想起过去的一些事情。无数个现在终究会变成曾经，而无数的过往构成了此时此刻的开始。佛教说：欲知前生事，今生受者是。你现在所遭遇的一切都是从前做的事情的结果，你此刻的遭遇，此刻的获得，此刻的失去，此刻的感受，都是之前某一些事情的结果。所以现在完成时就是这么产生的，这是一种有着言外之意的时态。 革命尚未成功，同志仍需努力，是现在完成时； 自李唐来，世人甚爱牡丹。是现在完成时； 后值倾覆，受任于败军之际，奉命于危难之间：尔来二十有一年矣。也是现在完成。 靖康耻，犹未雪。臣子恨，何时灭。是现在完成时。 商女不知亡国恨， 隔江犹唱《后庭花》。是现在完成时。 这几句话都暗暗包含着到现在为止的意思，革命到现在还没成功，自唐朝到现在人们都喜欢牡丹，自从孔明随刘备出山直到现在已经21年了。靖康之耻，尚未消除。歌女不知道什么是亡国之恨，还在唱着前朝亡国之曲。 现在完成时的时间截止点是到现在为止，而每一句现在完成时的句子都是有着自己的潜台词，比如当我说：“我已经喝了八瓶了”，我的意思可能是我不想再喝了；当我说“我还没准备好”，我的意思可能是我还需要一点时间；当我说：“我已经等了三小时了”，我的意思可能是我快没耐心了。所以现在完成时都是有着言外之意的，而这种言外之意又来自从过去某一时刻到现在为止发生的事情。听明白我的话，不要机械理解，现在完成时的时间区间是从过去某一时刻到现在为止，但是现在完成时所涉及的动作未必是到现在为止，它可能是到现在为止，也可能是现在之前就已经发生完了。 当现状不如人意的时候，人们就会怀念过往。你可能会对自己说，我曾经经历过那么多闪亮的日子。I have ever experienced so many shining days. 你说这个话的时候，你的意思不止于此。你想表达对过去的美好日子回忆，其实也想表达对未来的期许。也可能想说而现在却这么落寞。无论是哪一种含义，这样一个现在完成时的句子说出来的时候，它其实就已经暗示了一定程度的接下来要说的话。所以这里使用了现在完成时，表示到现在为止，你曾经经历过那些光辉的日子，那些美好的事情发生在过去的某一个时刻和此时此刻这个区间之内。一定要记住，现在完成时覆盖的时间是一个区间，而这个区间的截止点是现在，是此时此刻。但是，现在完成时所指的动作的影响已经远远超出了这个时间区间。比如我说：I have been away from home for ten years，我已经离家十年。其实我想说的绝对不只是离家十年这件事本身，而是想说很想家，所以这里现在完成时的含义已经超出了时间区间本身。 生活并不总是平淡如水的，有时你会表达一些强烈的情感。你和别人发生一些争执，你可能会说，我从来就没有见过这个人。I have never met this guy.你想说的是，到现在为止，你都没有见过这个人。言外之意是说，更不可能和这个人有什么交集。现在完成时侧重于一种累积性，其中累积性是到现在为止，或者说是默认到现在为止。什么叫做默认？就要上面那一句话，我从来没有见过这个人。言外之意肯定是说我到现在为止从来没有见过这个人。现在完成时里面通常包含的言外之意，还有一定的情绪。你在公司里连续加班了三天，第四天老板要派你出差。那你可能会说，我都加了三天班了，还没有休息呢。I have worked overtime for three days and haven’t had rest yet.当你说我已经加了三天班了，这里面就已经含有了言外之意，你要表达的意思是说，加了三天班是会产生一定的后果的，这种后果就是很累。所以现在完成时的句子表达的意思当中暗含着对现在或者对现在以后的某一种影响。所以呢，现在完全是一种暗含的情绪和言外之意的时态。而是时态本身就是一种生活状态，一种情感状态，所以能有这样的效果也就不足为奇了。 也可以用一个感性的句子来说一下过去时和完成时，过去时是超然事外，完成时是心有余念。当你用过去时的时候，你已经从过去走出来。当你用完成时的时候，你还有所牵挂。完成时是到某一时刻为止但是后续影响并未结束，过去时是到某一时刻为止就为止了。 再多说几句吧，其实我们这里所探讨的都是中规中矩的语法。而实际当中，懒惰的美国人就很喜欢直接用过去时来表示需要用现在完成时的情况。 每一个人都活在现在，每个人都最关注此时此刻的感受。而此时此刻，你可能在做一件事，也可能在想一件事，也可能在说一件事。而处于正在进行的一件事当中的状态，其实就是现在进行式。所以呢，此时此刻你正在做的事情就叫现在进行时。 当然英语中的现在进行时远远没有这么狭隘，现在进行时还可以用来表示将来的事情，在学校学的是只有一些非延续性动词的现在进行时才可以表示将来，其实那样的理解基本上可以说是错误的，英语当中只要是已经安排好的计划好的事情几乎都可以用现在进行时来表示。比如We’re meeting Susan at 3 o’clock tomorrow afternoon. 同样我也在另一篇文章中引用比较权威的材料论证了这个问题，有空也可以去看看。 在这里问这个问题的人，有很多都是学生，所以我这里就从学生的角度来简单的说明一下什么叫做各种时态。假设你是一个学生，你每天早上6点钟都要起床，每天都要去上学，每天都要学习，每天都要写作业，从来不打游戏，或者你有时候打一会儿游戏，或者你天天藏被窝里打游戏，或者每周打一次游戏。这些情况都","date":"2019-04-17","objectID":"/grammar/:17:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"情景示例 下面通过一些情景来说明时态： 1.汤姆喜欢美女，这一定是一般现在时，因为他一直就喜欢美女，不论过去现在还是将来，终其一生都坚持着这样的对美的追求，所以这个一定是一般现在时。 Tom likes hotties. 2.他正在抖音上看美女，那一定是现在进行时： Tom is watching hotties on Tiktok. 3.如果说，在没有抖音之前，汤姆喜欢看《花花公子》杂志，这一定是一般过去时，因为抖音产生也才是近十年的事情，在那之前，喜欢看美女的人都各自想办法呗： Tom liked reading PLAYBOY before Tiktok came out. 4.你约汤姆今天去图书馆，他一定会打瞌睡的，因为昨晚看了一晚上抖音，所以他去图书馆也只不过是换个地方睡觉而已，这就是一般将来时： Tom will definitely sleep in the library. 5.你昨天打电话他没接电话，那时他在刷抖音。这叫做过去进行时。 He was browsing Tiktok when you called him. 6.他说明天要去看沙滩排球，相信我，你偷偷跟着去，他一定会在看美女而不是记分牌。这叫做将来进行时，说明将来某一个时刻正在发生的事情： He will be surely staring at the hotties but not the scoreboard. 7.他已经向那个美女表白十次了。这肯定是现在完成时，因为是到现在为止表白了十次。这也符合正常人的思维，一般人说已经怎样怎样都是默认的到现在为止，而不是到将来或者说到过去某一个时刻为止。 He has expressed his feelings for her ten times. 8.自从人家拒绝他送的花之后，他就一直站在那个女的门前。这就是现在完成进行时，自从人家拒绝他，一直到现在，他都一直站在人家门口，一直站到现在。 He has been standing in front of the girl’s home since she refused his flowers. 9.到去年年底之前，这样的事情他都干过不下一百次了。在过去某一个时间点之前已经做的事情，并且还和那个时间点之后有一定的联系，这就肯定是过去完成时。 He had done this no less than a hundred times by the end of last year. 10.在你看到他之前，他就一直在那个女孩家周围闲逛。这个肯定是过去完成进行时，因为你看到他肯定是过去的事情，在过去某一时刻之前，一直发生到那个时刻的事情，当然是过去完成进行时： He had been wandering around the girl’s home before you saw him. 11.在上次聚会上，他说他将追求这个女孩。这就是过去将来时： At last party, he said he would chase the girl. 12. 女孩告诉他，如果他能再等六十年就嫁给他。他当时说，六十年后我将已经死去。这句话就是过去将来完成时。不论是谁，估计等个六十年也就挂了。这里的关键在于，那句话是过去说的，说的是当时他认为将来某一个时候已经发生了的事情。 He said at the time that he would have died after sixty years. 13.他说，那个时候，他将正在静静躺在墓穴里。这就是过去将来进行时，是从过去某一时刻说将来某一时刻将正在发生的事 He said that at that time, he would be lying quietly in the tomb. ","date":"2019-04-17","objectID":"/grammar/:18:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":null,"content":"这是一个About页面 ","date":"2018-04-24","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]