[{"categories":[],"content":"语言 对象生命周期 标准库 错误与异常处理 日志分析、断点调试 面向对象的理解 设计模式 gdb使用 ","date":"2022-04-09","objectID":"/learning_route/:1:0","tags":[],"title":"学习路线","uri":"/learning_route/"},{"categories":[],"content":"算法与数据结构 链表、队列、栈 二叉树、红黑树 b树、b+树 dijkstra算法，最小生成树 递归 排序 希尔、归并、快排、堆排序 贪心算法、动态规划 跳表、散列表、Hash、布隆过滤器 ","date":"2022-04-09","objectID":"/learning_route/:2:0","tags":[],"title":"学习路线","uri":"/learning_route/"},{"categories":[],"content":"数据库 MySQL MySQ安装与配置 sql建表，索引，存储过程 存储引擎，myissam/innodb 数据库连接池 异步数据库请求 数据库集群， 分库分表，读写分离 缓存Redis Redis编译安全，配置 Redis命令使用 Redis连接池/异步Redis的做法 Redis集群，数据备份 缓存雪崩，缓存击穿 ","date":"2022-04-09","objectID":"/learning_route/:3:0","tags":[],"title":"学习路线","uri":"/learning_route/"},{"categories":[],"content":"网络原理 ping, telnet,ifconfig 网络体系模型 TCP三次握手，四次挥手，滑动窗口，状态机 UDP的原理 http/https/http2.0/http3.0 Session Cookie application 网络安全，加密，数字签名 wireshark, tcpdump iperf ","date":"2022-04-09","objectID":"/learning_route/:4:0","tags":[],"title":"学习路线","uri":"/learning_route/"},{"categories":[],"content":"操作系统 文件操作，系统操作 程序编译，运行 shell / vi的使用 Linux系统性能监控参数 ps / netstat/ df 进程管理 用户态/内核态 内存管理， 内存池 磁盘文件系统，虚拟文件系统 ","date":"2022-04-09","objectID":"/learning_route/:5:0","tags":[],"title":"学习路线","uri":"/learning_route/"},{"categories":[],"content":"网络编程 socket编程， tcp/udp 网络IO模型，阻塞/非阻塞，同步异步 io多路复用 select/poll/epoll epoll reactor, proactor time_wait/close_wait大量 C10K/C1000K/C10M 网络框架 libevent/libv 协程 ntyco, libco ","date":"2022-04-09","objectID":"/learning_route/:6:0","tags":[],"title":"学习路线","uri":"/learning_route/"},{"categories":["Tools"],"content":"https://vim-adventures.com/ 我的配置文件看这里： https://github.com/MarsWang42/My-Vim-Conf VimAwesome网站： https://vimawesome.com/ Vim Plug Github页面： https://github.com/junegunn/vim-plug ","date":"2022-04-08","objectID":"/vim/:0:0","tags":["Vim"],"title":"Vim","uri":"/vim/"},{"categories":["Computer Network"],"content":"可靠数据传输原理  可靠数据传输(Reliable Data Transfer)是一个很大的概念，在计算机网络的五层模型中，它可以出现在传输层、数据链路层和应用层。简单点说，可靠数据传输服务保证了通信过程中的数据接收方接收到的数据与其从数据发送方发出的数据一致。而提供这种可靠数据传输服务的协议称为可靠数据传输协议，例如传输层的TCP协议。  可靠数据传输为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。在这条信道中传输的数据bit不会受到损坏和或丢失，而且所有的数据都是按其发送顺序交付。其对应的服务框架如下图所示，TCP协议向调用它的因特网应用所提供的服务模型恰恰如此，所以当谈到可靠数据传输时，不可避免地会涉及大量TCP协议的分析。  那么一个网络协议要实现可靠数据传输需要具备哪些特性呢？或者说，协议中需要设定哪些规则来避免数据传输的不可靠？为了数据传输的可靠，我们就要解决数据不可靠的情况，而数据传输的不可靠的情形最基本的有如下几种： 数据在信道中传输时，比特出现了错误，例如本来该bit为0，到了接收端却成为了1 数据在信道中传输时，比特发生了丢失，例如本来按序发送了16个比特，结果到了接收端只收到了8个比特 数据在信道中传输时，比特流的顺序发生了变化，例如发送端按照序号1，2，3，4，5发送的比特流，结果到了接收端收到是1，3，2，5，4 数据在信道中传输时，接收端接收到了重复的数据，例如发送端按照序号1，2，3发送，到了接收端收到是1，2，2，3  先思考一下，针对上面的若干基本情况，我们要怎么处理。首先数据在接收方出现了不一致的情况，我们如何得知呢？这就需要通过差错检测机制，通过差错检测，我们可以检测到何时何处出现了比特差错。然后，出现了差错该怎么办呢？作为接收方，肯定要告诉发送方我收到的数据有问题，所以就要有接收方反馈功能，也就是接收方发送明确的反馈信息给发送方。那么发送方接收了该反馈信息又该怎么做呢？最基本且有效的情况无非就是重新发送一份错误数据对应的原数据，也就是重传。 可靠数据传输特征 差错检测 ​ 差错检测主要的实现方式就是在传输的数据流中添加额外的比特信息以增加冗余度，主要分为两大类：奇偶效验和分组检验。其中分组校验中典型的方法有校验和法（IP数据报）和循环冗余校验法。 接收方反馈 一般是给出肯定确认ACK或否定确认NAK，也可以通过冗余ACK的方式代替否定确认。 重传 在分组传送时，主要有累积重传和选择重传。  通过上述几个功能，我们可以设计出能够工作的协议，但是，仔细想象一下你就会发现，这个步骤中有一个致命缺陷。在接收方给发送方发送反馈信息时，假设这个反馈信息也出了错误，那么发送方就无法知道接收方是否正确接收上一次发送的数据了。 在思考一下，如果我们是协议设计者，会怎么做？可以考虑以下几种方式： 发送方接收到错误的反馈信息表示无法理解时，便又向接收方发送针对该反馈信息的解释请求，即引入了一种新型的从发送方到接收方的分组。就像打电话时一方不理解另一方时会提问“你说啥？”，另一方则会重复回答。要是这个“你说啥”也产生了差错，岂不又是越陷越深了。 增加足够的检验和比特，使得发送方不但可以检测差错还可以恢复差错，对于只产生错误而没有丢失的分组，就可以直接解决问题。 当发送方收到含糊不清的反馈信息后，只需要重传当前数据分组即可。这种方法在信道中引入了冗余分组。而冗余分组所带来一个问题就是，接收方不知道它上次发送的反馈信息是否被发送方正确接收，也就是说接收方无法事先知道接收到的分组时新的还是一次重传，这很重要，因为如果将重传分组当作新的分组，那么数据包就会出错了。 序号 ​ 为了解决上述冗余分组中的问题，我们就又提出一种协议功能，就是给数据分组编号，这也是包括TCP在内所有的数据分组采用的方法。即在数据分组中添加一个新的字段，让发送方对其数据分组编号，将发送数据分组的序号放在该字段。于是，接收方只需要检查序号就可以确定该分组是否是一次重传了。对于停等协议（Stop and Wait，SW）来说，该字段只需要一个比特即可。因为停等协议中，发送方必须等待接收方传回ACK或NAK才能继续发送下一个数据分组。  除了具备差错检测与恢复外，我们还需要考虑当分组丢失分情况，而上面的协议功能不足以解决分组丢失的问题。当发送方发送一个数据后，在信道中丢失，接收方自然没有收到数据从而不会发送反馈，于是发送方迟迟没有收到确认。这时候，我们一般情况下都是会等待一定时间后重新发送该分组。所以我们又引入一个新的协议功能：倒计数定时器，通过设定一个给定的时间量，当时间量过期后，便重传分组。 倒计数定时器 为了容忍数据丢失，我们在发送方引入倒计数定时器。即1. 每次发送一个分组时（包括第一次分组和重传分组），启动一个定时器。2. 响应定时器中断（采取适当动作，比如重传）。3. 终止定时器。  综上，在实现了差错检测，接收方反馈，重传，序号，倒计数定时器这些协议功能后，就可以得到一个可靠数据传输协议了。 具备上述协议功能的协议分为两种，一种是停止-等待协议，一种是流水线协议，后者是前者的加强版，提升了信道的利用率。实际上ARQ协议也是分为了类似的两类。说到ARQ，那么就介绍一下它：  ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。其中，连续ARQ就是一种流水线协议。  我们说到流水线协议相对于停止等待协议增加了信道的利用率，但是也带来了一定程度的局限性。例如： 流水线协议必须增加序号的范围，因为每个传输中的分组必须有一个唯一的序号用来区分分组，而且也许在输送中存在多个未确认的报文。而停止等待协议只需一个比特位来给分组编号（即比特交替协议） 协议的发送方和接收方两端也许必须缓存多个分组。这样做的目的是为了差错恢复，这取决于协议如何处理丢失、损坏以及时延过大的分组所需序号范围i和对缓冲的要求取决于数据传输协议如何 流水线协议中差错恢复的两种方法：回退N步（Go-Back-N,GBN）和选择重传（Selective Repeat,SR）。 回退N步协议(GBN)  回退N步协议允许发送方发送多个分组而不确认，但是其在流水线中未确认的分组的数量不能超过N。这个协议又被称作滑动窗口协议，是因为流水线中已被发送但还未被确认的分组的许可范围构成了一个在序号范围内长度为N的窗口，N就是窗口的大小，随着协议运行，该窗口的序号空间不断向前滑动。思考一下，为什么要设置这么一个窗口呢？其实是为了流量控制和拥塞控制的需要，我们将在后文介绍。 在GBN中，发送方必须响应的三种类型事件是： 上层的调用。 收到一个ACK，该协议对序号为n的分组的确认采取累积确认的方式，表明接收方已经正确接收到序号为n的以前且包括n在内的所有分组。 超时事件，go-back N行为正来自出现丢失或时延过长分组时发送方采取的差错恢复行为。同样也用到了定时器，出现超时的时候，发送方将重传所有已发送但还未被确认的分组，所以在发送方缓存这些分组是十分必要的。如果收到一个ACk,但仍有已发送但未确认的分组，则定时器会被重新启动，如果没有则会终止。 GBN协议中，接收方会丢弃失序的分组，因为GBN采用累积确认，一次交付给上层一个分组，接收方必须按序将数据交付给上层，丢失分组是一种简单的方法之一，另外的一种就是放在接收方缓存起来，等带下一个按序的分组，最后在组装正确的数据交付。 选择重传协议(SR) GBN虽然采用了流水线解决了信道利用率的问题，但是也会存在另外的性能问题，例如当窗口长度很大或者带宽时延积都很大时，在流水线中有更多的分组时更甚。因为在这些情况下，必须重传大量分组，代价太大了，也许只是窗口中诸多分组的一个或几个分组出现错误，便要重传全部已经发送但未确认的分组，未免太浪费了。 而选择重传机制就是让发送方仅仅重传那些它怀疑在接收方出错(丢失或受损)的分组，从而避免了不必要的重传。但是这种方式就不能采用累积确认了，而是要求接收方逐个地确认正确接收的分组。即接收方确认正确的分组不管其是否失序，失序的分组将被缓存直到所有比失序分组序号小的分组都被接收为止，才会将一批分组按序交付。 但是这种方式会带来一个问题，就是接收方和发送方的窗口并不是总是一致的，因为对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不是总能看到一样的结果。这意味着，当序号范围有限时，发送方和接收窗口之间缺乏同步会产生严重的后果。这就要求SR协议中，窗口长度必须小于或等于序号空间大小的一半。后续将证明。 到现在为止，我们介绍了若干可靠传输机制，下表是一个总结。 机制 用途和说明 检验和 用于检测在一个传输分组中的比特错误 定时器 用于超时/重传一个分组,可能因为该分组(或其ACK)在信道中丢失了。由于当一个分组延时但未丢失，或当一个分组已被接收方接收但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本 序号 用于为从发送方流向接收方的数据分组按序号编号。","date":"2022-01-07","objectID":"/reliable_data_transfer/:0:1","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["Computer Network"],"content":"从TCP协议中看可靠数据传输 介绍了可靠数据传输的基本原理之后，我们再来探讨一种典型的可靠数据传输协议——TCP，TCP是因特网运输层的面向连接的可靠的运输协议。 流量控制 拥塞控制 ","date":"2022-01-07","objectID":"/reliable_data_transfer/:0:2","tags":["Reliable Data Transfer","TCP","Computer Network"],"title":"可靠数据传输","uri":"/reliable_data_transfer/"},{"categories":["文学"],"content":"滕王阁序 王勃 【唐代】 　豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。 　时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。 　披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦。 　遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？ 　嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ 　勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？ 　呜呼！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔。 滕王高阁临江渚，佩玉鸣鸾罢歌舞。 画栋朝飞南浦云，珠帘暮卷西山雨。 闲云潭影日悠悠，物换星移几度秋。 阁中帝子今何在？槛外长江空自流。 ","date":"2021-11-04","objectID":"/first/:0:0","tags":null,"title":"滕王阁序","uri":"/first/"},{"categories":["C/C++"],"content":"GCC 编译工具 GCC是一款强大的编译工具，下文在介绍c以及c++程序的编译运行流程中将采用gcc做示例。 GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由 [2] 。 GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言编 译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数 -std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 \u003e 4.8.5） 查看版本 gcc/g++ -v/--version ","date":"2021-05-19","objectID":"/compile_link/:1:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"1.gcc 和 g++ 的关系 gcc 和 g++都是GNU(组织)的一个编译器。 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的 宏__cplusplus只是标志着编译器将会把代码按 C 还是 C++ 语法来解释，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义 编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++ gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价 ","date":"2021-05-19","objectID":"/compile_link/:1:1","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"2.gcc 常用编译参数 -E 预处理指定的源文件，不进行编译 -S 编译指定的源文件，但是不进行汇编 -c 编译、汇编指定的源文件，但是不进行链接 -o [file1] [file2] /[file2] -o [file1] 将文件 file2 编译成可执行文件 file1 -I directory 指定 include 包含文件的搜索目录 -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -On n的取值范围：0~3。编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高 -l 在程序编译的时候，指定使用的库 -L 指定编译的时候，搜索的库的路径。 -fPIC/fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 指定C方言，如:-std=c99，gcc默认的方言是GNU C ","date":"2021-05-19","objectID":"/compile_link/:1:2","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"3.GCC 工作流程 GCC工作流程也就是一个c/c++语言程序从编译到生成可执行程序的过程，如下图所示。 下面分别介绍各个阶段,我们的示例代码如下： . ├── include │ ├── mymath.c │ └── mymath.h └── test.c test.c #include \u003cstdio.h\u003e#include \"mymath.h\" int main(int argc, char **argv) { int a = 2, b = 3; int sum = add(a, b); printf(\"a=%d, b=%d, a+b=%d\", a, b, sum); return 0; } mymath.h #ifndef MYMATH_H #define MYMATH_H int add(int a, int b); int sub(int a, int b); int mul(int a, int b); double div(int a, int b); #endif mymath.c int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } int mul(int a, int b) { return a * b; } double div(int a, int b) { return a * 1.0 / b; } ","date":"2021-05-19","objectID":"/compile_link/:1:3","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"1.预处理（Preprocessing） 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。 预处理器的主要作用就是: 把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有: 文件包含，条件编译、布局控制和宏替换4种。 文件包含: #include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。 条件编译: #if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。 布局控制: #progma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。 宏替换: #define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。 gcc的预处理是预处理器cpp来完成的，你可以通过如下命令对test.c进行预处理 : # -I 指定头文件目录 # -E 指定编译器在预处理后就退出，不再进行后续编译过程 # -o 指定输出的文件名 gcc -E test.c -I ./include -o test.i # 或者直接用cpp命令 cpp test.c -I ./include -o test.i 执行结果为： -rw-r--r-- 1 lwy lwy 106 Apr 6 20:56 test.c -rw-r--r-- 1 lwy lwy 16349 Apr 6 21:14 test.i 看得出来经过预处理后的文件比源文件要大很多，预处理之后的程序还是文本，可以用文本编辑器打开。其内容大致如下： # 1 \"test.c\" # 1 \"\u003cbuilt-in\u003e\" # 1 \"\u003ccommand-line\u003e\" # 31 \"\u003ccommand-line\u003e\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4# 32 \"\u003ccommand-line\u003e\" 2 # 1 \"test.c\" # 1 \"/usr/include/stdio.h\" 1 3 4# 27 \"/usr/include/stdio.h\" 3 4 ... typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; ... # 4 \"test.c\" int main(int argc, char **argv) { printf(\"hello world\"); return 0; } ","date":"2021-05-19","objectID":"/compile_link/:2:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"2.编译（Compilation） 这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。编译的指令如下： gcc -S -I ./include test.c -o test.s 上述命令中-S让编译器在编译之后停止，不进行后续过程。编译过程完成后，将生成程序的汇编代码test.s，内容如下： .file \"test.c\" .text .section .rodata .LC0: .string \"hello world\" .text .globl main .type main, @function main: .LFB0: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl %edi, -4(%rbp) movq %rsi, -16(%rbp) leaq .LC0(%rip), %rdi movl $0, %eax call printf@PLT movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident \"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04) 9.4.0\" .section .note.GNU-stack,\"\",@progbits .section .note.gnu.property,\"a\" .align 8 .long 1f - 0f .long 4f - 1f .long 5 0: .string \"GNU\" 1: .align 8 .long 0xc0000002 .long 3f - 2f 2: .long 0x3 3: .align 8 4: ","date":"2021-05-19","objectID":"/compile_link/:3:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"3.汇编（Assemble） 汇编过程将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。gcc汇编过程通过gcc -c命令完成： gcc -c test.s -o test.o gcc -c ./include/mymath.c -o ./include/mymath.o 这一步会为每一个源文件产生一个目标文件。因此mymath.c也需要产生一个mymath.o文件 . ├── include │ ├── mymath.c │ ├── mymath.h │ └── mymath.o ├── test.c ├── test.i ├── test.o └── test.s ","date":"2021-05-19","objectID":"/compile_link/:4:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["C/C++"],"content":"4.链接（Linking） 链接过程将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(executable file),其命令如下 gcc -o test.out test.o include/mymath.o # 这里用g++也可，当是c++程序时倾向使用g++ . ├── include │ ├── mymath.c │ ├── mymath.h │ └── mymath.o ├── test.c ├── test.i ├── test.o ├── test.out └── test.s ./test.out 结果为： lwy@lwysLaptop:~/workspace/test$ ./test.out hello world 经过以上分析，我们发现编译过程并不像想象的那么简单，而是要经过预处理、编译、汇编、链接。尽管我们平时使用gcc命令的时候没有关心中间结果，但每次程序的编译都少不了这几个步骤。也不用为上述繁琐过程而烦恼，因为你仍然可以： gcc/g++ -c test.c -o test.out ","date":"2021-05-19","objectID":"/compile_link/:5:0","tags":["C/C++","GNU","Compile"],"title":"编译与链接","uri":"/compile_link/"},{"categories":["Computer Network"],"content":"Socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 ","date":"2021-04-17","objectID":"/unix_socket/:1:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序 现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码/译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。 字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 ","date":"2021-04-17","objectID":"/unix_socket/:2:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序举例 ","date":"2021-04-17","objectID":"/unix_socket/:2:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"字节序转换 当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换） 网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。 // h - host 主机，主机字节序 // to - 转换成什么 // n - network 网络字节序 // s - short unsigned short // l - long unsigned in #include \u003carpa/inet.h\u003e// 转换端口 uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序 uint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序 // 转IP uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序 uint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序 ","date":"2021-04-17","objectID":"/unix_socket/:2:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"Socket地址 ","date":"2021-04-17","objectID":"/unix_socket/:3:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"通用Socket地址 socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下： #include \u003cbits/socket.h\u003estruct sockaddr { sa_family_t sa_family; char sa_data[14]; }; typedef unsigned short int sa_family_t; sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示: 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP/IPv4协议族 PF_INET6 AF_INET6 TCP/IPv6协议族 宏 PF_* 和 AF_* 都定义在 bits/socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用 sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示 协议族 地址值的含义和长度 PF_UNIX 文件的路径名，长度可以达到108字节 PF_INET 16bit 端口号和32bit IPv4 地址，共6字节 PF_INET6 16bit 端口号，32bit 流标识，128bit IPv6 地址，32bit范围ID,共26字节 由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的： #include \u003cbits/socket.h\u003estruct sockaddr_storage { sa_family_t sa_family; unsigned long int __ss_align; char __ss_padding[ 128 - sizeof(__ss_align) ]; }; typedef unsigned short int sa_family_t; ","date":"2021-04-17","objectID":"/unix_socket/:3:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"专用Socket地址 很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型 UNIX 本地域协议族使用如下专用的 socket 地址结构体： #include \u003csys/un.h\u003estruct sockaddr_un { sa_family_t sin_family; char sun_path[108]; }; TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6: #include \u003cnetinet/in.h\u003estruct sockaddr_in { sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */ in_port_t sin_port; /* Port number. */ struct in_addr sin_addr; /* Internet address. */ /* Pad to size of `struct sockaddr'. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; }; struct in_addr { in_addr_t s_addr; }; struct sockaddr_in6 { sa_family_t sin6_family; in_port_t sin6_port; /* Transport layer port # */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* IPv6 scope-id */ }; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef uint16_t in_port_t; typedef uint32_t in_addr_t; #define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)) 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。 ","date":"2021-04-17","objectID":"/unix_socket/:3:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"IP地址转换 通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换： #include \u003carpa/inet.h\u003ein_addr_t inet_addr(const char *cp); int inet_aton(const char *cp, struct in_addr *inp); char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址： #include \u003carpa/inet.h\u003e// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 int inet_pton(int af, const char *src, void *dst); af:地址族： AF_INET AF_INET6 src:需要转换的点分十进制的IP字符串 dst:转换后的结果保存在这个里面 // 将网络字节序的整数，转换成点分十进制的IP地址字符串 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); af:地址族： AF_INET AF_INET6 src: 要转换的ip的整数的地址 dst: 转换成IP地址字符串保存的地方 size：第三个参数的大小（数组的大小） 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 ","date":"2021-04-17","objectID":"/unix_socket/:4:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"TCP通信流程 ","date":"2021-04-17","objectID":"/unix_socket/:5:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"服务器端 （被动接受连接的角色） 创建一个用于监听的套接字 （监听：监听有客户端的连接；套接字：这个套接字其实就是一个文件描述符 ） 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）客户端连接服务器的时候使用的就是这个IP和端口 设置监听，监听的fd开始工作 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd） 通信 接收数据、发送数据 通信结束，断开 ","date":"2021-04-17","objectID":"/unix_socket/:5:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"客户端 创建一个用于通信的套接字（fd） 连接服务器，需要指定连接的服务器的 IP 和 端口 连接成功了，客户端可以直接和服务器通信 接收数据 发送数据 通信结束，断开 ","date":"2021-04-17","objectID":"/unix_socket/:5:2","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"套接字函数 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e#include \u003carpa/inet.h\u003e // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol); - 功能：创建一个套接字 - 参数： - domain: 协议族 AF_INET : ipv4 AF_INET6 : ipv6 AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信） - type: 通信过程中使用的协议类型 SOCK_STREAM : 流式协议 SOCK_DGRAM : 报式协议 - protocol : 具体的一个协议。一般写0 - SOCK_STREAM : 流式协议默认使用 TCP - SOCK_DGRAM : 报式协议默认使用 UDP - 返回值： - 成功：返回文件描述符，操作的就是内核缓冲区。 - 失败：-1 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命 名 - 功能：绑定，将fd 和本地的IP + 端口进行绑定 - 参数： - sockfd : 通过socket函数得到的文件描述符 - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息 - addrlen : 第二个参数结构体占的内存大小 int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn - 功能：监听这个socket上的连接 - 参数： - sockfd : 通过socket()函数得到的文件描述符 - backlog : 未连接的和已经连接的和的最大值， 5 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接 - 参数： - sockfd : 用于监听的文件描述符 - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port） - addrlen : 指定第二个参数的对应的内存大小 - 返回值： - 成功 ：用于通信的文件描述符 - -1 ： 失败 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); - 功能： 客户端连接服务器 - 参数： - sockfd : 用于通信的文件描述符 - addr : 客户端要连接的服务器的地址信息 - addrlen : 第二个参数的内存大小 - 返回值：成功 0， 失败 -1 ssize_t write(int fd, const void *buf, size_t count); // 写数据 ssize_t read(int fd, void *buf, size_t count); // 读数 ","date":"2021-04-17","objectID":"/unix_socket/:6:0","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Computer Network"],"content":"示例 服务器端 #include \u003carpa/inet.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e int main() { // 1 创建socket， 用于监听 int lfd = socket(AF_INET, SOCK_STREAM, 0); if (lfd == -1) { perror(\"socket\"); exit(-1); } // 2 绑定端口 struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_pton(AF_INET, \"172.25.93.158\", \u0026sockaddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr *)\u0026saddr, sizeof(saddr)); if (ret == -1) { perror(\"bind\"); exit(-1); } // 3 监听 ret = listen(lfd, 8); if (ret == -1) { perror(\"listen\"); exit(-1); } // 4 接受连接 struct sockaddr_in clientaddr; socklen_t len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr *)\u0026clientaddr, \u0026len); if (cfd == -1) { perror(\"accept\"); exit(-1); } // 输出客户端信息 char clientIP[16]; inet_ntop(AF_INET, \u0026clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(\"client Ip is %s, client port is %d\\n\", clientIP, clientPort); // 5 通信 // 获取客户端数据 char recvBuf[1024] = {0}; while (1) { ret = read(cfd, recvBuf, sizeof(recvBuf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"receive client data : %s\\n\", recvBuf); } else if (ret == 0) { printf(\"client closed...\\n\"); break; } // 给客户端发送数据 char sendBuf[] = \"hello I am server\"; ret = write(cfd, sendBuf, sizeof(sendBuf) - 1); if (ret == -1) { perror(\"write\"); exit(-1); } } // 6 关闭连接 close(cfd); close(lfd); return 0; } 客户端 #include \u003carpa/inet.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e int main() { // 1 创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { perror(\"socket\"); exit(-1); } // 2 连接服务器 struct sockaddr_in serverAddr; serverAddr.sin_family = PF_INET; inet_pton(AF_INET, \"172.25.93.158\", \u0026serverAddr.sin_addr.s_addr); serverAddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr *)\u0026serverAddr, sizeof(serverAddr)); if (ret == -1) { perror(\"connect\"); exit(-1); } // 3 通信 char recvBuf[1024] = {0}; while (1) { char sendBuf[] = \"hello I am client\"; ret = write(fd, sendBuf, sizeof(sendBuf) - 1); if (ret == -1) { perror(\"write\"); exit(-1); } sleep(1); ret = read(fd, recvBuf, sizeof(recvBuf)); if (ret == -1) { perror(\"read\"); exit(-1); } else if (ret \u003e 0) { printf(\"receive server data : %s\\n\", recvBuf); } else if (ret == 0) { printf(\"server closed...\\n\"); break; } } // 4 关闭连接 close(fd); return 0; }  ","date":"2021-04-17","objectID":"/unix_socket/:6:1","tags":["Unix","Socket"],"title":"Unix套接字编程","uri":"/unix_socket/"},{"categories":["Operating System"],"content":"线程概述 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP 号：ps –Lf pi ◼ 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的 一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 ◼ 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始 来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 ◼ NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。 ◼ 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION ","date":"2021-04-12","objectID":"/linux_multi_threads/:1:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"进程与线程之间的区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用 一些进程间通信方式，在进程间进行信息交换。 调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表 ","date":"2021-04-12","objectID":"/linux_multi_threads/:1:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程基本操作 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_t pthread_self(void); int pthread_equal(pthread_t t1, pthread_t t2); void pthread_exit(void *retval); int pthread_join(pthread_t thread, void **retval); int pthread_detach(pthread_t thread); int pthread_cancel(pthread_t thread); ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程创建（create） /* 一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程 称之为子线程。 程序中默认只有一个进程，fork()函数调用，2进行 程序中默认只有一个线程，pthread_create()函数调用，2个线程。 #include \u003cpthread.h\u003e int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); - 功能：创建一个子线程 - 参数： - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。 - attr : 设置线程的属性，一般使用默认值，NULL - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码 - arg : 给第三个参数使用，传参 - 返回值： 成功：0 失败：返回错误号。这个错误号和之前errno不太一样。 获取错误号的信息： char * strerror(int errnum); */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"child thread...\\n\"); printf(\"arg value: %d\\n\", *(int *)arg); return NULL; } int main() { pthread_t tid; int num = 10; // 创建一个子线程 int ret = pthread_create(\u0026tid, NULL, callback, (void *)\u0026num); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } sleep(1); return 0; // exit(0); } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程终止（exit） /* #include \u003cpthread.h\u003e void pthread_exit(void *retval); 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程 参数： retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。 pthread_t pthread_self(void); 功能：获取当前的线程的线程ID int pthread_equal(pthread_t t1, pthread_t t2); 功能：比较两个线程ID是否相等 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的 是使用结构体去实现的。 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e void * callback(void * arg) { printf(\"child thread id : %ld\\n\", pthread_self()); return NULL; // pthread_exit(NULL); } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } // 主线程 for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self()); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); printf(\"main thread exit\\n\"); return 0; // exit(0); } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:2","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程汇合（join） /* #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **retval); - 功能：和一个已经终止的线程进行连接 回收子线程的资源 这个函数是阻塞函数，调用一次只能回收一个子线程 一般在主线程中使用 - 参数： - thread：需要回收的子线程的ID - retval: 接收子线程退出时的返回值 - 返回值： 0 : 成功 非0 : 失败，返回的错误号 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e int value = 10; void * callback(void * arg) { printf(\"child thread id : %ld\\n\", pthread_self()); // sleep(3); // return NULL; // int value = 10; // 局部变量 pthread_exit((void *)\u0026value); // return (void *)\u0026value; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } // 主线程 for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self()); // 主线程调用pthread_join()回收子线程的资源 int * thread_retval; ret = pthread_join(tid, (void **)\u0026thread_retval); if(ret != 0) { char * errstr = strerror(ret); printf(\"error : %s\\n\", errstr); } printf(\"exit data : %d\\n\", *thread_retval); printf(\"回收子线程资源成功！\\n\"); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:3","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程分离（detach） /* #include \u003cpthread.h\u003e int pthread_detach(pthread_t thread); - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 1.不能多次分离，会产生不可预料的行为。 2.不能去连接一个已经分离的线程，会报错。 - 参数：需要分离的线程的ID - 返回值： 成功：0 失败：返回错误号 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); return NULL; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); // 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if(ret != 0) { char * errstr = strerror(ret); printf(\"error2 : %s\\n\", errstr); } // 设置分离后，对分离的子线程进行连接 pthread_join() // ret = pthread_join(tid, NULL); // if(ret != 0) { // char * errstr = strerror(ret); // printf(\"error3 : %s\\n\", errstr); // } pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:4","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程取消（cancel） /* #include \u003cpthread.h\u003e int pthread_cancel(pthread_t thread); - 功能：取消线程（让线程终止） 取消某个线程，可以终止某个线程的运行， 但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); for(int i = 0; i \u003c 5; i++) { printf(\"child : %d\\n\", i); } return NULL; } int main() { // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, NULL, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 取消线程 pthread_cancel(tid); for(int i = 0; i \u003c 5; i++) { printf(\"%d\\n\", i); } // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:5","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程属性（attr） /* int pthread_attr_init(pthread_attr_t *attr); - 初始化线程属性变量 int pthread_attr_destroy(pthread_attr_t *attr); - 释放线程属性的资源 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); - 获取线程分离的状态属性 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); - 设置线程分离的状态属性 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstring.h\u003e#include \u003cunistd.h\u003e void * callback(void * arg) { printf(\"chid thread id : %ld\\n\", pthread_self()); return NULL; } int main() { // 创建一个线程属性变量 pthread_attr_t attr; // 初始化属性变量 pthread_attr_init(\u0026attr); // 设置属性 pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); // 创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid, \u0026attr, callback, NULL); if(ret != 0) { char * errstr = strerror(ret); printf(\"error1 : %s\\n\", errstr); } // 获取线程的栈的大小 size_t size; pthread_attr_getstacksize(\u0026attr, \u0026size); printf(\"thread stack size : %ld\\n\", size); // 输出主线程和子线程的id printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self()); // 释放线程属性资源 pthread_attr_destroy(\u0026attr); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:2:6","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"线程同步（synchronization） ◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 ◼ 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。 ◼ 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:0","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"互斥量（锁） 互斥量基本原理 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 ◼ 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 ◼ 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 ◼ 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示： 互斥量示例 /* 互斥量的类型 pthread_mutex_t int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); - 初始化互斥量 - 参数 ： - mutex ： 需要初始化的互斥量变量 - attr ： 互斥量相关的属性，NULL - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。 pthread_mutex_t *restrict mutex = xxx; pthread_mutex_t * mutex1 = mutex; int pthread_mutex_destroy(pthread_mutex_t *mutex); - 释放互斥量的资源 int pthread_mutex_lock(pthread_mutex_t *mutex); - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待 int pthread_mutex_trylock(pthread_mutex_t *mutex); - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。 int pthread_mutex_unlock(pthread_mutex_t *mutex); - 解锁 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 全局变量，所有的线程都共享这一份资源。 int tickets = 1000; // 创建一个互斥量 pthread_mutex_t mutex; void * sellticket(void * arg) { // 卖票 while(1) { // 加锁 pthread_mutex_lock(\u0026mutex); if(tickets \u003e 0) { usleep(6000); printf(\"%ld 正在卖第 %d 张门票\\n\", pthread_self(), tickets); tickets--; }else { // 解锁 pthread_mutex_unlock(\u0026mutex); break; } // 解锁 pthread_mutex_unlock(\u0026mutex); } return NULL; } int main() { // 初始化互斥量 pthread_mutex_init(\u0026mutex, NULL); // 创建3个子线程 pthread_t tid1, tid2, tid3; pthread_create(\u0026tid1, NULL, sellticket, NULL); pthread_create(\u0026tid2, NULL, sellticket, NULL); pthread_create(\u0026tid3, NULL, sellticket, NULL); // 回收子线程的资源,阻塞 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); pthread_exit(NULL); // 退出主线程 // 释放互斥量资源 pthread_mutex_destroy(\u0026mutex); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:1","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"死锁 ◼ 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 ◼ 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁 死锁的几种场景 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 更多关于死锁的内容将在操作系统的相关理论文章中介绍，本文不再继续讨论。 死锁产生的四个必要条件 虽然进程在运行过程中，可能发生死锁，但死锁的发生必须具备一定的条件，死锁的发生必须具有以下四个必要条件。 （1）互斥条件：指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。 （2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 （3）不剥夺条件：指进程已获得的资源，在未使用之前，不能被剥夺，只能在使用完时由自己释放。 （4）循环等待条件：指在发生死锁时，必然在一个进程 – 资源的环形链，即进程集合{P0， P1， P2 …， Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，….，Pn正在等待已被 P0 占用的资源。 死锁处理方法 在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁 （1）预防死锁 ：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 （2）避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。 （3）检测和解除死锁：先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。 这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。 死锁示例 #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 创建2个互斥量 pthread_mutex_t mutex1, mutex2; void * workA(void * arg) { pthread_mutex_lock(\u0026mutex1); sleep(1); pthread_mutex_lock(\u0026mutex2); printf(\"workA....\\n\"); pthread_mutex_unlock(\u0026mutex2); pthread_mutex_unlock(\u0026mutex1); return NULL; } void * workB(void * arg) { pthread_mutex_lock(\u0026mutex2); sleep(1); pthread_mutex_lock(\u0026mutex1); printf(\"workB....\\n\"); pthread_mutex_unlock(\u0026mutex1); pthread_mutex_unlock(\u0026mutex2); return NULL; } int main() { // 初始化互斥量 pthread_mutex_init(\u0026mutex1, NULL); pthread_mutex_init(\u0026mutex2, NULL); // 创建2个子线程 pthread_t tid1, tid2; pthread_create(\u0026tid1, NULL, workA, NULL); pthread_create(\u0026tid2, NULL, workB, NULL); // 回收子线程资源 pthread_join(tid1, NULL); pthread_join(tid2, NULL); // 释放互斥量资源 pthread_mutex_destroy(\u0026mutex1); pthread_mutex_destroy(\u0026mutex2); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:2","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 ◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 ◼ 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高。 示例 /* 读写锁的类型 pthread_rwlock_t int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 案例：8个线程操作同一个全局变量。 3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e // 创建一个共享数据 int num = 1; // pthread_mutex_t mutex; pthread_rwlock_t rwlock; void * writeNum(void * arg) { while(1) { pthread_rwlock_wrlock(\u0026rwlock); num++; printf(\"++write, tid : %ld, num : %d\\n\", pthread_self(), num); pthread_rwlock_unlock(\u0026rwlock); usleep(100); } return NULL; } void * readNum(void * arg) { while(1) { pthread_rwlock_rdlock(\u0026rwlock); printf(\"===read, tid : %ld, num : %d\\n\", pthread_self(), num); pthread_rwlock_unlock(\u0026rwlock); usleep(100); } return NULL; } int main() { pthread_rwlock_init(\u0026rwlock, NULL); // 创建3个写线程，5个读线程 pthread_t wtids[3], rtids[5]; for(int i = 0; i \u003c 3; i++) { pthread_create(\u0026wtids[i], NULL, writeNum, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026rtids[i], NULL, readNum, NULL); } // 设置线程分离 for(int i = 0; i \u003c 3; i++) { pthread_detach(wtids[i]); } for(int i = 0; i \u003c 5; i++) { pthread_detach(rtids[i]); } pthread_exit(NULL); pthread_rwlock_destroy(\u0026rwlock); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:3","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"条件变量 互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。 条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。 两个线程操作同一临界区时，通过互斥锁保护，若A线程已经加锁，B线程再加锁时候会被阻塞，直到A释放锁，B再获得锁运行，进程B必须不停的主动获得锁、检查条件、释放锁、再获得锁、再检查、再释放，一直到满足运行的条件的时候才可以（而此过程中其他线程一直在等待该线程的结束），这种方式是比较消耗系统的资源的。而条件变量同样是阻塞，还需要通知才能唤醒，线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，该线程就休眠了，应该仍阻塞在这里，等待条件满足后被唤醒，节省了线程不断运行浪费的资源。这个过程一般用while语句实现。当线程B发现被锁定的变量不满足条件时会自动的释放锁并把自身置于等待状态，让出CPU的控制权给其它线程。其它线程 此时就有机会去进行操作，当修改完成后再通知那些由于条件不满足而陷入等待状态的线程。这是一种通知模型的同步方式，大大的节省了CPU的计算资源，减少了线程之间的竞争，而且提高了线程之间的系统工作的效率。这种同步方式就是条件变量。 示例（生产者-消费者模型） /* 条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); - 等待，调用了该函数，线程会阻塞。 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。 int pthread_cond_signal(pthread_cond_t *cond); - 唤醒一个或者多个等待的线程 int pthread_cond_broadcast(pthread_cond_t *cond); - 唤醒所有的等待的线程 */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建条件变量 pthread_cond_t cond; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); // 只要生产了一个，就通知消费者消费 pthread_cond_signal(\u0026cond); pthread_mutex_unlock(\u0026mutex); usleep(100); } return NULL; } void * customer(void * arg) { while(1) { pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; // 判断是否有数据 if(head != NULL) { // 有数据 head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); usleep(100); } else { // 没有数据，需要等待 // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。 pthread_cond_wait(\u0026cond, \u0026mutex); pthread_mutex_unlock(\u0026mutex); } } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); pthread_cond_init(\u0026cond, NULL); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_cond_destroy(\u0026cond); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:4","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"信号量 信号量又称为信号灯（semaphore），其与自旋锁不同的地方是它可以引起调用者休眠，也就是信号量本质上是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放后），处于等待队列中的那个任务将被唤醒，并将获得该信号量。 信号量一个有用的特性是它可以同时允许任意数量的锁持有者，而自旋锁和互斥锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为使用者数量（usage count）或简单的叫做数量（count）。通常情况下，信号量和自旋锁一样，在一个时刻仅允许有一个锁持有者。这时计数等于1，这样的信号量被称为二值信号量或者称为互斥信号量。另一方面，初始化时也可以把数量设置为大于1的非0值。这种情况，信号量被称为计数信号量（counting semaphore），它允许在同一时刻至多有count个锁持有者。 示例（生产者-消费者模型） /* 信号量的类型 sem_t int sem_init(sem_t *sem, int pshared, unsigned int value); - 初始化信号量 - 参数： - sem : 信号量变量的地址 - pshared : 0 用在线程间 ，非0 用在进程间 - value : 信号量中的值 int sem_destroy(sem_t *sem); - 释放资源 int sem_wait(sem_t *sem); - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞 int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); int sem_post(sem_t *sem); - 对信号量解锁，调用一次对信号量的值+1 int sem_getvalue(sem_t *sem, int *sval); sem_t psem; sem_t csem; init(psem, 0, 8); init(csem, 0, 0); producer() { sem_wait(\u0026psem); sem_post(\u0026csem) } customer() { sem_wait(\u0026csem); sem_post(\u0026psem) } */ #include \u003cstdio.h\u003e#include \u003cpthread.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003csemaphore.h\u003e // 创建一个互斥量 pthread_mutex_t mutex; // 创建两个信号量 sem_t psem; sem_t csem; struct Node{ int num; struct Node *next; }; // 头结点 struct Node * head = NULL; void * producer(void * arg) { // 不断的创建新的节点，添加到链表中 while(1) { sem_wait(\u0026psem); pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand() % 1000; printf(\"add node, num : %d, tid : %ld\\n\", newNode-\u003enum, pthread_self()); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026csem); } return NULL; } void * customer(void * arg) { while(1) { sem_wait(\u0026csem); pthread_mutex_lock(\u0026mutex); // 保存头结点的指针 struct Node * tmp = head; head = head-\u003enext; printf(\"del node, num : %d, tid : %ld\\n\", tmp-\u003enum, pthread_self()); free(tmp); pthread_mutex_unlock(\u0026mutex); sem_post(\u0026psem); } return NULL; } int main() { pthread_mutex_init(\u0026mutex, NULL); sem_init(\u0026psem, 0, 8); sem_init(\u0026csem, 0, 0); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i \u003c 5; i++) { pthread_create(\u0026ptids[i], NULL, producer, NULL); pthread_create(\u0026ctids[i], NULL, customer, NULL); } for(int i = 0; i \u003c 5; i++) { pthread_detach(ptids[i]); pthread_detach(ctids[i]); } while(1) { sleep(10); } pthread_mutex_destroy(\u0026mutex); pthread_exit(NULL); return 0; } ","date":"2021-04-12","objectID":"/linux_multi_threads/:3:5","tags":["Unix","MultiThreads"],"title":"Linux下的多线程","uri":"/linux_multi_threads/"},{"categories":["Operating System"],"content":"多进程通信（IPC） 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变 ","date":"2021-04-10","objectID":"/ipc/:1:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"管道（PIPE） 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式， 所有的 UNIX 系统都支持这种通信机制。 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行ls和 wc。 ","date":"2021-04-10","objectID":"/ipc/:2:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用 ","date":"2021-04-10","objectID":"/ipc/:2:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"管道的读写特点 使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作） 所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。 ","date":"2021-04-10","objectID":"/ipc/:2:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* #include \u003cunistd.h\u003e int pipe(int pipefd[2]); 功能：创建一个匿名管道，用来进程间通信。 参数：int pipefd[2] 这个数组是一个传出参数。 pipefd[0] 对应的是管道的读端 pipefd[1] 对应的是管道的写端 返回值： 成功 0 失败 -1 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞 注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程） */ // 子进程发送数据给父进程，父进程读取到数据输出 #include \u003cunistd.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e int main() { // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) { perror(\"pipe\"); exit(0); } // 创建子进程 pid_t pid = fork(); if(pid \u003e 0) { // 父进程 printf(\"i am parent process, pid : %d\\n\", getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = {0}; while(1) { int len = read(pipefd[0], buf, sizeof(buf)); printf(\"parent recv : %s, pid : %d\\n\", buf, getpid()); // 向管道中写入数据 //char * str = \"hello,i am parent\"; //write(pipefd[1], str, strlen(str)); //sleep(1); } } else if(pid == 0){ // 子进程 printf(\"i am child process, pid : %d\\n\", getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = {0}; while(1) { // 向管道中写入数据 char * str = \"hello,i am child\"; write(pipefd[1], str, strlen(str)); //sleep(1); // int len = read(pipefd[0], buf, sizeof(buf)); // printf(\"child recv : %s, pid : %d\\n\", buf, getpid()); // bzero(buf, 1024); } } return 0; } ","date":"2021-04-10","objectID":"/ipc/:2:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"命名管道（Named Pipe） 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件 ","date":"2021-04-10","objectID":"/ipc/:3:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。 FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 文件定位操作。 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 ","date":"2021-04-10","objectID":"/ipc/:3:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* 创建fifo文件 1.通过命令： mkfifo 名字 2.通过函数：int mkfifo(const char *pathname, mode_t mode); #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e int mkfifo(const char *pathname, mode_t mode); 参数： - pathname: 管道名称的路径 - mode: 文件的权限 和 open 的 mode 是一样的 是一个八进制的数 返回值：成功返回0，失败返回-1，并设置错误号 */ #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e int main() { // 判断文件是否存在 int ret = access(\"fifo1\", F_OK); if(ret == -1) { printf(\"管道不存在，创建管道\\n\"); ret = mkfifo(\"fifo1\", 0664); if(ret == -1) { perror(\"mkfifo\"); exit(0); } } return 0; } ","date":"2021-04-10","objectID":"/ipc/:3:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"内存映射（Memory Map） ","date":"2021-04-10","objectID":"/ipc/:4:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"特点 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功? void * ptr = mmap(...); ptr++; 可以对其进行++操作 munmap(ptr, len); // 错误,要保存地址 如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? 错误，返回MAP_FAILED open()函数中的权限建议和prot参数的权限保持一致。 如果文件偏移量为1000会怎样? 偏移量必须是4K的整数倍，返回MAP_FAILED mmap什么情况下会调用失败? 第2个参数：length = 0 第3个参数：prot 只指定了写权限 prot PROT_READ | PROT_WRITE 第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗? 可以的，但是创建的文件的大小如果为0的话，肯定不行 可以对新的文件进行扩展（lseek()，truncate()） mmap后关闭文件描述符，对mmap映射有没有影响？ int fd = open(\"XXX\"); mmap(,,,,fd,0); close(fd); 映射区还存在，创建映射区的fd被关闭，没有任何影响。 对ptr越界操作会怎样？ void * ptr = mmap(NULL, 100,,,,,); 4K 越界操作操作的是非法的内存 -\u003e 段错误 ","date":"2021-04-10","objectID":"/ipc/:4:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 /* #include \u003csys/mman.h\u003e void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); - 功能：将一个文件或者设备的数据映射到内存中 - 参数： - void *addr: NULL, 由内核指定 - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。 获取文件的长度：stat lseek - prot : 对申请的内存映射区的操作权限 -PROT_EXEC ：可执行的权限 -PROT_READ ：读权限 -PROT_WRITE ：写权限 -PROT_NONE ：没有权限 要操作映射内存，必须要有读的权限。 PROT_READ、PROT_READ|PROT_WRITE - flags : - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项 - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write） - fd: 需要映射的那个文件的文件描述符 - 通过open得到，open的是一个磁盘文件 - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。 prot: PROT_READ open:只读/读写 prot: PROT_READ | PROT_WRITE open:读写 - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。 - 返回值：返回创建的内存的首地址 失败返回MAP_FAILED，(void *) -1 int munmap(void *addr, size_t length); - 功能：释放内存映射 - 参数： - addr : 要释放的内存的首地址 - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。 */ /* 使用内存映射实现进程间通信： 1.有关系的进程（父子进程） - 还没有子进程的时候 - 通过唯一的父进程，先创建内存映射区 - 有了内存映射区以后，创建子进程 - 父子进程共享创建的内存映射区 2.没有关系的进程间通信 - 准备一个大小不是0的磁盘文件 - 进程1 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 进程2 通过磁盘文件创建内存映射区 - 得到一个操作这块内存的指针 - 使用内存映射区通信 注意：内存映射区通信，是非阻塞。 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cwait.h\u003e // 作业:使用内存映射实现没有关系的进程间的通信。 int main() { // 1.打开一个文件 int fd = open(\"test.txt\", O_RDWR); int size = lseek(fd, 0, SEEK_END); // 获取文件的大小 // 2.创建内存映射区 void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 3.创建子进程 pid_t pid = fork(); if(pid \u003e 0) { wait(NULL); // 父进程 char buf[64]; strcpy(buf, (char *)ptr); printf(\"read data : %s\\n\", buf); }else if(pid == 0){ // 子进程 strcpy((char *)ptr, \"nihao a, son!!!\"); } // 关闭内存映射区 munmap(ptr, size); return 0; } /* 匿名映射：不需要文件实体进程一个内存映射 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/wait.h\u003e int main() { // 1.创建匿名内存映射区 int len = 4096; void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 父子进程间通信 pid_t pid = fork(); if(pid \u003e 0) { // 父进程 strcpy((char *) ptr, \"hello, world\"); wait(NULL); }else if(pid == 0) { // 子进程 sleep(1); printf(\"%s\\n\", (char *)ptr); } // 释放内存映射区 int ret = munmap(ptr, len); if(ret == -1) { perror(\"munmap\"); exit(0); } return 0; } // 使用内存映射实现文件拷贝的功能 /* 思路： 1.对原始的文件进行内存映射 2.创建一个新文件（拓展该文件） 3.把新文件的数据映射到内存中 4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中 5.释放资源 */ #include \u003cstdio.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e int main() { // 1.对原始的文件进行内存映射 int fd = open(\"english.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); exit(0); } // 获取原始文件的大小 int len = lseek(fd, 0, SEEK_END); // 2.创建一个新文件（拓展该文件） int fd1 = open(\"cpy.txt\", O_RDWR | O_CREAT, 0664); if(fd1 == -1) { perror(\"open\"); exit(0); } // 对新创建的文件进行拓展 truncate(\"cpy.txt\", len); write(fd1, \" \", 1); // 3.分别做内存映射 void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); void * ptr1 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0); if(ptr == MAP_FAILED) { perror(\"mmap\"); exit(0); } if(ptr1 == MAP_FAILED) { perror(\"mmap\"); exit(0); } // 内存拷贝 memcpy(ptr1, ptr, len); // 释放资源 munmap(ptr1, len); munmap(ptr, len); close(fd1); close(fd); return 0; } ","date":"2021-04-10","objectID":"/ipc/:4:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号（Signal） 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也 称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下： 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数 ","date":"2021-04-10","objectID":"/ipc/:5:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"使用信号的目的： 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 ","date":"2021-04-10","objectID":"/ipc/:5:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号的特点 简单 不能携带大量信息 满足某个特定条件才发送 优先级比较高 查看系统定义的信号列表：kill –l ，前 31 个信号为常规信号，其余为实时信号。 查看信号的详细信息：man 7 signal 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。 ","date":"2021-04-10","objectID":"/ipc/:5:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号示例 /* #include \u003csys/types.h\u003e #include \u003csignal.h\u003e int kill(pid_t pid, int sig); - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig - 参数： - pid ： \u003e 0 : 将信号发送给指定的进程 = 0 : 将信号发送给当前的进程组 = -1 : 将信号发送给每一个有权限接收这个信号的进程 \u003c -1 : 这个pid=某个进程组的ID取反 （-12345） - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号 kill(getppid(), 9); kill(getpid(), 9); int raise(int sig); - 功能：给当前进程发送信号 - 参数： - sig : 要发送的信号 - 返回值： - 成功 0 - 失败 非0 kill(getpid(), sig); void abort(void); - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程 kill(getpid(), SIGABRT); */ #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csignal.h\u003e#include \u003cunistd.h\u003e int main() { pid_t pid = fork(); if(pid == 0) { // 子进程 int i = 0; for(i = 0; i \u003c 5; i++) { printf(\"child process\\n\"); sleep(1); } } else if(pid \u003e 0) { // 父进程 printf(\"parent process\\n\"); sleep(2); printf(\"kill child process now\\n\"); kill(pid, SIGINT); } return 0; } /* #include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候， 函数会给当前的进程发送一个信号：SIGALARM - 参数： seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。 取消一个定时器，通过alarm(0)。 - 返回值： - 之前没有定时器，返回0 - 之前有定时器，返回之前的定时器剩余的时间 - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。 alarm(10); -\u003e 返回0 过了1秒 alarm(5); -\u003e 返回9 alarm(100) -\u003e 该函数是不阻塞的 */ #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { int seconds = alarm(5); printf(\"seconds = %d\\n\", seconds); // 0 sleep(2); seconds = alarm(2); // 不阻塞 printf(\"seconds = %d\\n\", seconds); // 3 while(1) { } return 0; } /* #include \u003csys/time.h\u003e int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时 - 参数： - which : 定时器以什么时间计时 ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用 ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF - new_value: 设置定时器的属性 struct itimerval { // 定时器的结构体 struct timeval it_interval; // 每个阶段的时间，间隔时间 struct timeval it_value; // 延迟多长时间执行定时器 }; struct timeval { // 时间的结构体 time_t tv_sec; // 秒数 suseconds_t tv_usec; // 微秒 }; 过10秒后，每个2秒定时一次 - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL - 返回值： 成功 0 失败 -1 并设置错误号 */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e // 过3秒以后，每隔2秒钟定时一次 int main() { struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026new_value, NULL); // 非阻塞的 printf(\"定时器开始了...\\n\"); if(ret == -1) { perror(\"setitimer\"); exit(0); } getchar(); return 0; } /* #include \u003csignal.h\u003e typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); - 功能：设置某个信号的捕捉行为 - 参数： - signum: 要捕捉的信号 - handler: 捕捉到信号要如何处理 - SIG_IGN ： 忽略信号 - SIG_DFL ： 使用信号默认的行为 - 回调函数 : 这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。 回调函数： - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义 - 不是程序员调用，而是当信号产生，由内核调用 - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。 - 返回值： 成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL 失败，返回SIG_ERR，设置错误号 SIGKILL SIGSTOP不能被捕捉，不能被忽略。 */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e void myalarm(int num) { printf(\"捕捉到了信号的编号是：%d\\n\", num); printf(\"xxxxxxx\\n\"); } // 过3秒以后，每隔2秒钟定时一次 int main() { // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。 signal(SIGALRM, myalarm); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026new_value, NULL); // 非阻塞的 printf(\"定时器开始了...\\n\"); if(ret == -1) { perror(\"setitimer\"); exit(0); } getchar(); return 0; } ","date":"2021-04-10","objectID":"/ipc/:5:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号集 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 ","date":"2021-04-10","objectID":"/ipc/:5:4","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号集示例 场景： 用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）\r- SIGINT信号状态被存储在第二个标志位上\r- 这个标志位的值为0， 说明信号不是未决状态\r- 这个标志位的值为1， 说明信号处于未决状态\r 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号\r- 如果想要阻塞某些信号需要用户调用系统的API\r 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 - 如果没有阻塞，这个信号就被处理\r- 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理\r /* 以下信号集相关的函数都是对自定义的信号集进行操作。 int sigemptyset(sigset_t *set); - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigfillset(sigset_t *set); - 功能：将信号集中的所有的标志位置为1 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigaddset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigdelset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置不阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigismember(const sigset_t *set, int signum); - 功能：判断某个信号是否阻塞 - 参数： - set：需要操作的信号集 - signum：需要判断的那个信号 - 返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 */ #include \u003csignal.h\u003e#include \u003cstdio.h\u003e int main() { // 创建一个信号集 sigset_t set; // 清空信号集的内容 sigemptyset(\u0026set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(\u0026set, SIGINT); if(ret == 0) { printf(\"SIGINT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGINT 阻塞\\n\"); } // 添加几个信号到信号集中 sigaddset(\u0026set, SIGINT); sigaddset(\u0026set, SIGQUIT); // 判断SIGINT是否在信号集中 ret = sigismember(\u0026set, SIGINT); if(ret == 0) { printf(\"SIGINT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGINT 阻塞\\n\"); } // 判断SIGQUIT是否在信号集中 ret = sigismember(\u0026set, SIGQUIT); if(ret == 0) { printf(\"SIGQUIT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGQUIT 阻塞\\n\"); } // 从信号集中删除一个信号 sigdelset(\u0026set, SIGQUIT); // 判断SIGQUIT是否在信号集中 ret = sigismember(\u0026set, SIGQUIT); if(ret == 0) { printf(\"SIGQUIT 不阻塞\\n\"); } else if(ret == 1) { printf(\"SIGQUIT 阻塞\\n\"); } return 0; } /* int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换） - 参数： - how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， mask | set SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞 mask \u0026= ~set SIG_SETMASK:覆盖内核中原来的值 - set ：已经初始化好的用户自定义的信号集 - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL - 返回值： 成功：0 失败：-1 设置错误号：EFAULT、EINVAL int sigpending(sigset_t *set); - 功能：获取内核中的未决信号集 - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。 */ // 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕 // 设置某些信号是阻塞的，通过键盘产生这些信号 #include \u003cstdio.h\u003e#include \u003csignal.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e int main() { // 设置2、3号信号阻塞 sigset_t set; sigemptyset(\u0026set); // 将2号和3号信号添加到信号集中 sigaddset(\u0026set, SIGINT); sigaddset(\u0026set, SIGQUIT); // 修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, \u0026set, NULL); int num = 0; while(1) { num++; // 获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(\u0026pendingset); sigpending(\u0026pendingset); // 遍历前32位 for(int i = 1; i \u003c= 31; i++) { if(sigismember(\u0026pendingset, i) == 1) { printf(\"1\"); }else if(sigismember(\u0026pendingset, i) == 0) { printf(\"0\"); }else { perror(\"sigismember\"); exit(0); } } printf(\"\\n\"); sleep(1); if(num == 10) { // 解除阻塞 sigprocmask(SIG_UNBLOCK, \u0026set, NULL); } } return 0; } /* #include \u003csignal.h\u003e int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); - 功能：检查或者改变信号的处理。信号捕捉 - 参数： - signum : 需要捕捉的信号的编号或者宏值（信号的名称） - act ：捕捉到信号之后的处理动作 - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL - 返回值： 成功 0 失败 -1 struct sigaction { // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void); }; */ #include \u003csys/time.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e void myalarm(int num) { printf(\"捕捉到了信号的编号是：%d\\n\", num); printf(\"xxxxxxx\\n\"); } // 过3秒以后，每隔2秒钟定时一次 int main() { struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; sigemptyset(\u0026act.sa_mask); // 清空临时阻塞信号集 // 注册信号捕捉 sigaction(SIGALRM, \u0026act, NULL); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_i","date":"2021-04-10","objectID":"/ipc/:5:5","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"共享内存（Shared Memory） 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 ◼ 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 ◼ 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 ◼ 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 ◼ 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步 ipcs 用法 ipcs -a // 打印当前系统中所有的进程间通信方式的信息 ipcs -m // 打印出使用共享内存进行进程间通信的信息 ipcs -q // 打印出使用消息队列进行进程间通信的信息 ipcs -s // 打印出使用信号进行进程间通信的信息 ipcrm 用法 ipcrm -M shmkey // 移除用shmkey创建的共享内存段 ipcrm -m shmid // 移除用shmid标识的共享内存段 ipcrm -Q msgkey // 移除用msqkey创建的消息队列 ipcrm -q msqid // 移除用msqid标识的消息队列 ipcrm -S semkey // 移除用semkey创建的信号 ipcrm -s semid // 移除用semid标识的信号 ","date":"2021-04-10","objectID":"/ipc/:6:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"问题 操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch，shm_nattach 记录了关联的进程个数 可不可以对共享内存进行多次删除 shmctl 可以的，因为shmctl 标记删除共享内存，不是直接删除，当和共享内存关联的进程数为0的时候，就真正被删除，当共享内存的key为0的时候，表示共享内存被标记删除了，如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 ","date":"2021-04-10","objectID":"/ipc/:6:1","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效率更高 共享内存方式所有的进程操作的是同一块共享内存。而内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全：当进程突然退出，共享内存还存在，而内存映射区消失；当运行进程的电脑死机，宕机了，数据存在在共享内存中，没有了，而内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期：内存映射区：进程退出，内存映射区销毁；共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机，如果一个进程退出，会自动和共享内存进行取消关联。 ","date":"2021-04-10","objectID":"/ipc/:6:2","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"示例 共享内存相关的函数 #include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e int shmget(key_t key, size_t size, int shmflg); - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 新创建的内存段中的数据都会被初始化为0 - 参数： - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 一般使用16进制表示，非0值 - size: 共享内存的大小 - shmflg: 属性 - 访问权限 - 附加属性：创建/判断共享内存是不是存在 - 创建：IPC_CREAT - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值： 失败：-1 并设置错误号 成功：\u003e0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。 void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能：和当前的进程进行关联 - 参数： - shmid : 共享内存的标识（ID）,由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 - shmflg : 对共享内存的操作 - 读 ： SHM_RDONLY, 必须要有读权限 - 读写： 0 - 返回值： 成功：返回共享内存的首（起始）地址。 失败(void *) -1 int shmdt(const void *shmaddr); - 功能：解除当前进程和共享内存的关联 - 参数： shmaddr：共享内存的首地址 - 返回值：成功 0， 失败 -1 int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。 - 参数： - shmid: 共享内存的ID - cmd : 要做的操作 - IPC_STAT : 获取共享内存的当前的状态 - IPC_SET : 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf：需要设置或者获取的共享内存的属性信息 - IPC_STAT : buf存储数据 - IPC_SET : buf中需要初始化数据，设置到内核中 - IPC_RMID : 没有用，NULL key_t ftok(const char *pathname, int proj_id); - 功能：根据指定的路径名，和int值，生成一个共享内存的key - 参数： - pathname:指定一个存在的路径 /home/nowcoder/Linux/a.txt / - proj_id: int类型的值，但是这系统调区销毁 - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 #include \u003cstdio.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e#include \u003cstring.h\u003e int main() { // 1.获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(\"shmid : %d\\n\", shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); // 3.读数据 printf(\"%s\\n\", (char *)ptr); printf(\"按任意键继续\\n\"); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0; } #include \u003cstdio.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/shm.h\u003e#include \u003cstring.h\u003e int main() { // 1.创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT|0664); printf(\"shmid : %d\\n\", shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); char * str = \"helloworld\"; // 3.写数据 memcpy(ptr, str, strlen(str) + 1); printf(\"按任意键继续\\n\"); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0; } ","date":"2021-04-10","objectID":"/ipc/:6:3","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"信号量（Semaphore Array） ","date":"2021-04-10","objectID":"/ipc/:7:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["Operating System"],"content":"套接字（Socke） 未完待续 ","date":"2021-04-10","objectID":"/ipc/:8:0","tags":["IPC","Linux"],"title":"Linux多进程通信","uri":"/ipc/"},{"categories":["C/C++"],"content":" 本文介绍文件IO与标准IO的相关概念，以及一些常用的文件IO函数 ","date":"2021-04-08","objectID":"/fileio/:0:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"基本概念 文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。 标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。 （1）全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 （2）行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 （3）不带缓存：stderr就是了。 ","date":"2021-04-08","objectID":"/fileio/:1:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"原理 文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。（Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。  ","date":"2021-04-08","objectID":"/fileio/:2:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"栈与堆的扩展方向 早期的微弱优势 早期的系统需要考虑有限内存下的内存布局问题。具体来说，内存的一端放置了静态代码和静态数据之后，剩余的区域，既需要动态数据，又需要可增长的栈，那么合理的方案就是各放一端向中间生长。现在的问题就是两个选项：静态内存放在哪端；栈是在静态内存的同端还是对端。 考虑下面的一些条件： 早期的部分机器，从0地址启动[1]。想象一下磁带机的编址。 动态数据从概念上来说，和静态数据比较像 所以从内存布局来说，一个自然的方案是，从0地址依次放置代码、静态数据、动态数据，高地址放置栈。 但是，从安全性来说，向低地址扩展也有微弱劣势： 数组、字符串越界时会覆盖过去栈帧的数据，黑客更容易找到缓冲区溢出攻击的漏洞 历史的实际情况 大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。 主流1：向低地址扩展：x86，MIPS 主流2：自由选择：Arm（但个别指令仅支持向低） 罕见：向高地址扩展：PA-RISC，操作系统Multics 非主流：System z，栈是个链表[2] 如果CPU同时支持向上和向下，例如arm，那么编译器需要指定程序的调用方向，一般还是选择向下。比较罕见的极端的案例是Multics操作系统，这是Unix的巨无霸前身，设计者刻意选用向高地址扩展，因为该架构有助于防御缓冲区溢出攻击[3]。 现代的情况 现代程序的下列特征，导致内存布局问题中的单个栈增长方向无所谓。 使用线性虚拟地址，进程空间为4G或者更高 现代程序写法，栈的大小1M左右已经足够使用。编译器一般都直接限制栈的大小 多线程导致有多个栈，所以堆-栈的两端分割模式是不合适的，每个栈应当有界 引用 作者：刘源 链接：https://www.zhihu.com/question/29520755/answer/373320074 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-04-08","objectID":"/fileio/:2:1","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"open /* #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e // 打开一个已经存在的文件 int open(const char *pathname, int flags); 参数： - pathname：要打开的文件路径 - flags：对文件的操作权限设置还有其他的设置 O_RDONLY, O_WRONLY, O_RDWR 这三个设置是互斥的 返回值：返回一个新的文件描述符，如果调用失败，返回-1 errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。 #include \u003cstdio.h\u003e void perror(const char *s);作用：打印errno对应的错误描述 s参数：用户描述，比如hello,最终输出的内容是 hello:xxx(实际的错误描述) // 创建一个新的文件 int open(const char *pathname, int flags, mode_t mode); 参数： - pathname：要创建的文件的路径 - flags：对文件的操作权限和其他的设置 - 必选项：O_RDONLY, O_WRONLY, O_RDWR 这三个之间是互斥的 - 可选项：O_CREAT 文件不存在，创建新文件 - mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775 最终的权限是：mode \u0026 ~umask 0777 -\u003e 111111111 \u0026 0775 -\u003e 111111101 ---------------------------- 111111101 按位与：0和任何数都为0 umask的作用就是抹去某些权限。 flags参数是一个int类型的数据，占4个字节，32位。 flags 32个位，每一位就是一个标志位。 */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { // 打开一个文件 int fd = open(\"a.txt\", O_RDONLY); if(fd == -1) { perror(\"open\"); } // 读写操作 // 关闭 close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:3:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"read \u0026 write /* #include \u003cunistd.h\u003e ssize_t read(int fd, void *buf, size_t count); 参数： - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件 - buf：需要读取数据存放的地方，数组的地址（传出参数） - count：指定的数组的大小 返回值： - 成功： \u003e0: 返回实际的读取到的字节数 =0：文件已经读取完了 - 失败：-1 ，并且设置errno #include \u003cunistd.h\u003e ssize_t write(int fd, const void *buf, size_t count); 参数： - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件 - buf：要往磁盘写入的数据，数据 - count：要写的数据的实际的大小 返回值： 成功：实际写入的字节数 失败：返回-1，并设置errno */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e int main() { // 1.通过open打开english.txt文件 int srcfd = open(\"english.txt\", O_RDONLY); if(srcfd == -1) { perror(\"open\"); return -1; } // 2.创建一个新的文件（拷贝文件） int destfd = open(\"cpy.txt\", O_WRONLY | O_CREAT, 0664); if(destfd == -1) { perror(\"open\"); return -1; } // 3.频繁的读写操作 char buf[1024] = {0}; int len = 0; while((len = read(srcfd, buf, sizeof(buf))) \u003e 0) { write(destfd, buf, len); } // 4.关闭文件 close(destfd); close(srcfd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:4:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"lseek /* 标准C库的函数 #include \u003cstdio.h\u003e int fseek(FILE *stream, long offset, int whence); Linux系统函数 #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e off_t lseek(int fd, off_t offset, int whence); 参数： - fd：文件描述符，通过open得到的，通过这个fd操作某个文件 - offset：偏移量 - whence: SEEK_SET 设置文件指针的偏移量 SEEK_CUR 设置偏移量：当前位置 + 第二个参数offset的值 SEEK_END 设置偏移量：文件大小 + 第二个参数offset的值 返回值：返回文件指针的位置 作用： 1.移动文件指针到文件头 lseek(fd, 0, SEEK_SET); 2.获取当前文件指针的位置 lseek(fd, 0, SEEK_CUR); 3.获取文件长度 lseek(fd, 0, SEEK_END); 4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节 lseek(fd, 100, SEEK_END) 注意：需要写一次数据 */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int fd = open(\"hello.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); return -1; } // 扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if(ret == -1) { perror(\"lseek\"); return -1; } // 写入一个空数据 write(fd, \" \", 1); // 关闭文件 close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:5:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"stat /* #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cunistd.h\u003e int stat(const char *pathname, struct stat *statbuf); 作用：获取一个文件相关的一些信息 参数: - pathname：操作的文件的路径 - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息 返回值： 成功：返回0 失败：返回-1 设置errno int lstat(const char *pathname, struct stat *statbuf); 参数: - pathname：操作的文件的路径 - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息 返回值： 成功：返回0 失败：返回-1 设置errno */ #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { struct stat statbuf; int ret = stat(\"a.txt\", \u0026statbuf); if(ret == -1) { perror(\"stat\"); return -1; } printf(\"size: %ld\\n\", statbuf.st_size); return 0; }access ","date":"2021-04-08","objectID":"/fileio/:6:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"access /* #include \u003cunistd.h\u003e int access(const char *pathname, int mode); 作用：判断某个文件是否有某个权限，或者判断文件是否存在 参数： - pathname: 判断的文件路径 - mode: R_OK: 判断是否有读权限 W_OK: 判断是否有写权限 X_OK: 判断是否有执行权限 F_OK: 判断文件是否存在 返回值：成功返回0， 失败返回-1 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int ret = access(\"a.txt\", F_OK); if(ret == -1) { perror(\"access\"); } printf(\"文件存在！！!\\n\"); return 0; } ","date":"2021-04-08","objectID":"/fileio/:7:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"chmod /* #include \u003csys/stat.h\u003e int chmod(const char *pathname, mode_t mode); 修改文件的权限 参数： - pathname: 需要修改的文件的路径 - mode:需要修改的权限值，八进制的数 返回值：成功返回0，失败返回-1 */ #include \u003csys/stat.h\u003e#include \u003cstdio.h\u003eint main() { int ret = chmod(\"a.txt\", 0777); if(ret == -1) { perror(\"chmod\"); return -1; } return 0; } ","date":"2021-04-08","objectID":"/fileio/:8:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"truncate /* #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int truncate(const char *path, off_t length); 作用：缩减或者扩展文件的尺寸至指定的大小 参数： - path: 需要修改的文件的路径 - length: 需要最终文件变成的大小 返回值： 成功返回0， 失败返回-1 */ #include \u003cunistd.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e int main() { int ret = truncate(\"b.txt\", 5); if(ret == -1) { perror(\"truncate\"); return -1; } return 0; }  ","date":"2021-04-08","objectID":"/fileio/:9:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"chdir \u0026 getcwd /* #include \u003cunistd.h\u003e int chdir(const char *path); 作用：修改进程的工作目录 比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder 参数： path : 需要修改的工作目录 #include \u003cunistd.h\u003e char *getcwd(char *buf, size_t size); 作用：获取当前工作目录 参数： - buf : 存储的路径，指向的是一个数组（传出参数） - size: 数组的大小 返回值： 返回的指向的一块内存，这个数据就是第一个参数 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cfcntl.h\u003e int main() { // 获取当前的工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(\"当前的工作目录是：%s\\n\", buf); // 修改工作目录 int ret = chdir(\"/home/nowcoder/Linux/lesson13\"); if(ret == -1) { perror(\"chdir\"); return -1; } // 创建一个新的文件 int fd = open(\"chdir.txt\", O_CREAT | O_RDWR, 0664); if(fd == -1) { perror(\"open\"); return -1; } close(fd); // 获取当前的工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(\"当前的工作目录是：%s\\n\", buf1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:10:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"mkdir /* #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e int mkdir(const char *pathname, mode_t mode); 作用：创建一个目录 参数： pathname: 创建的目录的路径 mode: 权限，八进制的数 返回值： 成功返回0， 失败返回-1 */ #include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cstdio.h\u003e int main() { int ret = mkdir(\"aaa\", 0777); if(ret == -1) { perror(\"mkdir\"); return -1; } return 0; } ","date":"2021-04-08","objectID":"/fileio/:11:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"opendir \u0026 readdir \u0026 closedir /* // 打开一个目录 #include \u003csys/types.h\u003e #include \u003cdirent.h\u003e DIR *opendir(const char *name); 参数： - name: 需要打开的目录的名称 返回值： DIR * 类型，理解为目录流 错误返回NULL // 读取目录中的数据 #include \u003cdirent.h\u003e struct dirent *readdir(DIR *dirp); - 参数：dirp是opendir返回的结果 - 返回值： struct dirent，代表读取到的文件的信息 读取到了末尾或者失败了，返回NULL // 关闭目录 #include \u003csys/types.h\u003e #include \u003cdirent.h\u003e int closedir(DIR *dirp); */ #include \u003csys/types.h\u003e#include \u003cdirent.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e int getFileNum(const char * path); // 读取某个目录下所有的普通文件的个数 int main(int argc, char * argv[]) { if(argc \u003c 2) { printf(\"%s path\\n\", argv[0]); return -1; } int num = getFileNum(argv[1]); printf(\"普通文件的个数为：%d\\n\", num); return 0; } // 用于获取目录下所有普通文件的个数 int getFileNum(const char * path) { // 1.打开目录 DIR * dir = opendir(path); if(dir == NULL) { perror(\"opendir\"); exit(0); } struct dirent *ptr; // 记录普通文件的个数 int total = 0; while((ptr = readdir(dir)) != NULL) { // 获取名称 char * dname = ptr-\u003ed_name; // 忽略掉. 和.. if(strcmp(dname, \".\") == 0 || strcmp(dname, \"..\") == 0) { continue; } // 判断是否是普通文件还是目录 if(ptr-\u003ed_type == DT_DIR) { // 目录,需要继续读取这个目录 char newpath[256]; sprintf(newpath, \"%s/%s\", path, dname); total += getFileNum(newpath); } if(ptr-\u003ed_type == DT_REG) { // 普通文件 total++; } } // 关闭目录 closedir(dir); return total; } ","date":"2021-04-08","objectID":"/fileio/:12:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"dup /* #include \u003cunistd.h\u003e int dup(int oldfd); 作用：复制一个新的文件描述符 fd=3, int fd1 = dup(fd), fd指向的是a.txt, fd1也是指向a.txt 从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstring.h\u003e int main() { int fd = open(\"a.txt\", O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if(fd1 == -1) { perror(\"dup\"); return -1; } printf(\"fd : %d , fd1 : %d\\n\", fd, fd1); close(fd); char * str = \"hello,world\"; int ret = write(fd1, str, strlen(str)); if(ret == -1) { perror(\"write\"); return -1; } close(fd1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:13:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"dup2 /* #include \u003cunistd.h\u003e int dup2(int oldfd, int newfd); 作用：重定向文件描述符 oldfd 指向 a.txt, newfd 指向 b.txt 调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt oldfd 必须是一个有效的文件描述符 oldfd和newfd值相同，相当于什么都没有做 */ #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cfcntl.h\u003e int main() { int fd = open(\"1.txt\", O_RDWR | O_CREAT, 0664); if(fd == -1) { perror(\"open\"); return -1; } int fd1 = open(\"2.txt\", O_RDWR | O_CREAT, 0664); if(fd1 == -1) { perror(\"open\"); return -1; } printf(\"fd : %d, fd1 : %d\\n\", fd, fd1); int fd2 = dup2(fd, fd1); if(fd2 == -1) { perror(\"dup2\"); return -1; } // 通过fd1去写数据，实际操作的是1.txt，而不是2.txt char * str = \"hello, dup2\"; int len = write(fd1, str, strlen(str)); if(len == -1) { perror(\"write\"); return -1; } printf(\"fd : %d, fd1 : %d, fd2 : %d\\n\", fd, fd1, fd2); close(fd); close(fd1); return 0; } ","date":"2021-04-08","objectID":"/fileio/:14:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["C/C++"],"content":"fcntl /* #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, ...); 参数： fd : 表示需要操作的文件描述符 cmd: 表示对文件描述符进行如何操作 - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值） int ret = fcntl(fd, F_DUPFD); - F_GETFL : 获取指定的文件描述符文件状态flag 获取的flag和我们通过open函数传递的flag是一个东西。 - F_SETFL : 设置文件描述符文件状态flag 必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改 可选性：O_APPEND, O)NONBLOCK O_APPEND 表示追加数据 NONBLOK 设置成非阻塞 阻塞和非阻塞：描述的是函数调用的行为。 */ #include \u003cunistd.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e int main() { // 1.复制文件描述符 // int fd = open(\"1.txt\", O_RDONLY); // int ret = fcntl(fd, F_DUPFD); // 2.修改或者获取文件状态flag int fd = open(\"1.txt\", O_RDWR); if(fd == -1) { perror(\"open\"); return -1; } // 获取文件描述符状态flag int flag = fcntl(fd, F_GETFL); if(flag == -1) { perror(\"fcntl\"); return -1; } flag |= O_APPEND; // flag = flag | O_APPEND // 修改文件描述符状态的flag，给flag加入O_APPEND这个标记 int ret = fcntl(fd, F_SETFL, flag); if(ret == -1) { perror(\"fcntl\"); return -1; } char * str = \"nihao\"; write(fd, str, strlen(str)); close(fd); return 0; } ","date":"2021-04-08","objectID":"/fileio/:15:0","tags":["C/C++","Unix"],"title":"Unix文件IO","uri":"/fileio/"},{"categories":["Tools"],"content":" GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境 GDB调试的三种方式： 目标板直接使用GDB进行调试。 目标板使用gdbserver，主机使用xxx-linux-gdb作为客户端。 目标板使用ulimit -c unlimited，生成core文件；然后主机使用xxx-linux-gdb ./test ./core。 ","date":"2021-04-07","objectID":"/gdb/:0:0","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"GDB 调试 构造测试程序如下main.c和sum.c如下: // main.c: #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e extern int sum(int value); struct inout { int value; int result; }; int main(int argc, char * argv[]) { struct inout * io = (struct inout * ) malloc(sizeof(struct inout)); if (NULL == io) { printf(\"Malloc failed.\\n\"); return -1; } if (argc != 2) { printf(\"Wrong para!\\n\"); return -1; } io -\u003e value = *argv[1] - '0'; io -\u003e result = sum(io -\u003e value); printf(\"Your enter: %d, result:%d\\n\", io -\u003e value, io -\u003e result); return 0; } // sum.c: int sum(int value) { int result = 0; int i = 0; for (i = 0; i \u003c value; i++) result += (i + 1); return result; } 然后gcc main.c sum.c -o main -g, 得到main可执行文件， 输入gdb main可进入调试. 下面介绍了gdb大部分功能，1.1 设置断点以及 1.3显示栈帧是常用功能；调试过程中可以需要1.6 单步执行，并且1.4 显示变量、1.5显示寄存器、1.8 监视点、1.9 改变变量的值。 如果进程已经运行中，需要1.11 attach到进程，或者1.10 生成转储文件进行分析。当然为了提高效率可以自定义1.13 初始化文件。 ","date":"2021-04-07","objectID":"/gdb/:1:0","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"设置断点* 设置断点可以通过b或者break设置断点，断点的设置可以通过函数名、行号、文件名+函数名、文件名+行号以及偏移量、地址等进行设置。 格式为： break 函数名 break 行号 break 文件名:函数名 break 文件名:行号 break +偏移量 break -偏移量 break *地址 查看断点，通过info break查看断点列表。 (gdb) b 13 Breakpoint 1 at 0x11aa: file main.c, line 13. (gdb) b sum.c:2 Breakpoint 2 at 0x123d: file sum.c, line 2. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000000011aa in main at main.c:13 2 breakpoint keep y 0x000000000000123d in sum at sum.c:2 删除断点通过命令包括： delete \u003c断点id\u003e：删除指定断点 delete：删除所有断点 clear clear 函数名 clear 行号 clear 文件名：行号 clear 文件名：函数名 断点还可以条件断住 break 断点 if 条件；比如break sum if value==9，当输入的value为9的时候才会断住。 condition 断点编号：给指定断点删除触发条件 condition 断点编号 条件：给指定断点添加触发条件 断点还可以通过disable/enable临时停用启用。 disable disable 断点编号 disable display 显示编号 disable mem 内存区域 enable enable 断点编号 enable once 断点编号：该断点只启用一次，程序运行到该断点并暂停后，该断点即被禁用。 enable delete 断点编号 enable display 显示编号 enable mem 内存区域 断点commands高级功能 大多数时候需要在断点处执行一系列动作，gdb提供了在断点处执行命令的高级功能commands。 #include \u003cstdio.h\u003e int total = 0; int square(int i) { int result=0; result = i*i; return result; } int main(int argc, char **argv) { int i; for(i=0; i\u003c10; i++) { total += square(i); } return 0; } 比如需要对如上程序square参数i为5的时候断点，并在此时打印栈、局部变量以及total的值 编写gdb.init如下： set logging on gdb.log b square if i == 5 commands bt full i locals p total print \"Hit break when i == 5\" end 在gdb shell中source gdb.init，然后r执行命令，结果如下： (gdb) source gdb.init Breakpoint 1 at 0x1129: file commands.c, line 6. (gdb) r Starting program: /home/lwy/workspace/gdbtest/commands Breakpoint 1, square (i=5) at commands.c:6 6 { #0 square (i=5) at commands.c:6 result = 25 #1 0x000055555555516f in main (argc=1, argv=0x7fffffffe048) at commands.c:20 i = 6 result = 25 $1 = 55 $2 = \"Hit break when i == 5\" 可以看出断点在i==5的时候断住了，并且此时打印了正确的值。 ","date":"2021-04-07","objectID":"/gdb/:1:1","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"运行 “gdb 命令”之后，run可以在gdb下运行命令；如果命令需要参数则跟在run之后。 (gdb) run 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Your enter: 9, result:45 [Inferior 1 (process 12362) exited normally] 如果需要断点在main()处，直接执行start就可以。 (gdb) start Temporary breakpoint 1 at 0x555555555189: file main.c, line 11. Starting program: /home/lwy/workspace/gdbtest/main 9 Temporary breakpoint 1, main (argc=21845, argv=0x0) at main.c:11 ","date":"2021-04-07","objectID":"/gdb/:1:2","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示栈帧* 如果遇到断点而暂停执行，或者coredump可以显示栈帧。 通过bt可以显示栈帧，bt full可以显示局部变量。 (gdb) r 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Breakpoint 2, sum (value=9) at sum.c:3 3 int i = 0; (gdb) bt #0 sum (value=9) at sum.c:3 #1 0x0000555555555204 in main (argc=2, argv=0x7fffffffe048) at main.c:24 (gdb) bt full #0 sum (value=9) at sum.c:3 result = 0 i = 32767 #1 0x0000555555555204 in main (argc=2, argv=0x7fffffffe048) at main.c:24 io = 0x5555555592a0 命令格式如下： bt bt full：不仅显示backtrace，还显示局部变量 bt N：显示开头N个栈帧 bt full N ","date":"2021-04-07","objectID":"/gdb/:1:3","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示变量* print 变量名可以显示变量内容。 ptype 变量名 可以打印变量类型 如果需要一行监控多个变量，可以通过p {var1, var2, var3}。 如果要跟踪自动显示，可以使用display {var1, var2, var3} 取消跟踪用 undisplay 编号 查看文件代码：list/l [文件名:][行号/函数名] 设置显示的行数：show list/listsize , set list/listsize 行数 ","date":"2021-04-07","objectID":"/gdb/:1:4","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"显示寄存器* info reg可以显示寄存器内容。 (gdb) i r rax 0x9 9 rbx 0x555555555270 93824992236144 rcx 0x5555555592b0 93824992252592 rdx 0x9 9 rsi 0x0 0 rdi 0x9 9 rbp 0x7fffffffdf20 0x7fffffffdf20 rsp 0x7fffffffdf20 0x7fffffffdf20 r8 0x5555555592a0 93824992252576 r9 0x7ffff7dd1070 140737351848048 r10 0x7ffff7fb9be0 140737353849824 r11 0x7ffff7fb9be0 140737353849824 r12 0x5555555550a0 93824992235680 r13 0x7fffffffe040 140737488347200 r14 0x0 0 r15 0x0 0 rip 0x55555555524b 0x55555555524b \u003csum+25\u003e eflags 0x216 [ PF AF IF ] cs 0x33 51 ss 0x2b 43 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 在寄存器名之前加$可以显示寄存器内容， p $寄存器：显示寄存器内容 p/x $寄存器：十六进制显示寄存器内容。 (gdb) p $ss $2 = 43 (gdb) p/x $pc $3 = 0x55555555524b 用x命令可以显示内容内容，x/格式 地址。 x $pc：显示程序指针内容 x/i $pc：显示程序指针汇编。 x/10i $pc：显示程序指针之后10条指令。 x/128wx 0xfc207000：从0xfc20700开始以16进制打印128个word。 (gdb) x $pc 0x55555555524b \u003csum+25\u003e: 0x00fc45c7 (gdb) x/i $pc =\u003e 0x55555555524b \u003csum+25\u003e: movl $0x0,-0x4(%rbp) (gdb) x/10i $pc =\u003e 0x55555555524b \u003csum+25\u003e: movl $0x0,-0x4(%rbp) 0x555555555252 \u003csum+32\u003e: jmp 0x555555555261 \u003csum+47\u003e 0x555555555254 \u003csum+34\u003e: mov -0x4(%rbp),%eax 0x555555555257 \u003csum+37\u003e: add $0x1,%eax 0x55555555525a \u003csum+40\u003e: add %eax,-0x8(%rbp) 0x55555555525d \u003csum+43\u003e: addl $0x1,-0x4(%rbp) 0x555555555261 \u003csum+47\u003e: mov -0x4(%rbp),%eax 0x555555555264 \u003csum+50\u003e: cmp -0x14(%rbp),%eax 0x555555555267 \u003csum+53\u003e: jl 0x555555555254 \u003csum+34\u003e 0x555555555269 \u003csum+55\u003e: mov -0x8(%rbp),%eax 还可以通过disassemble指令来反汇编。 disassemble disassemble 程序计数器 ：反汇编pc所在函数的整个函数。 disassemble addr-0x40,addr+0x40：反汇编addr前后0x40大小。 ","date":"2021-04-07","objectID":"/gdb/:1:5","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"单步执行* 单步执行有两个命令next和step，缩写为n和s，两者的区别是next遇到函数不会进入函数内部，step会执行到函数内部。 finish （跳出函数体） 如果需要逐条汇编指令执行，可以分别使用nexti和stepi。 ","date":"2021-04-07","objectID":"/gdb/:1:6","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"继续执行*  调试时，使用continue命令(缩写：c)继续执行程序。程序遇到断电后再次暂停执行；如果没有断点，就会一直执行到结束。 continue：继续执行 continue 次数：继续执行一定次数。 ","date":"2021-04-07","objectID":"/gdb/:1:7","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"监视点* 要想找到变量在何处被改变，可以使用watch命令设置监视点watchpoint。 watch \u003c表达式\u003e：表达式发生变化时暂停运行 awatch \u003c表达式\u003e：表达式被访问、改变是暂停执行 rwatch \u003c表达式\u003e：表达式被访问时暂停执行 (gdb) watch i Hardware watchpoint 3: i (gdb) i b Num Type Disp Enb Address What 2 breakpoint keep y 0x0000555555555244 in sum at sum.c:3 stop only if value==9 breakpoint already hit 1 time 3 hw watchpoint keep y ","date":"2021-04-07","objectID":"/gdb/:1:8","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"改变变量的值* 通过set variable \u003c变量\u003e=\u003c表达式\u003e来修改变量的值。 简写set var 变量名=变量值 （循环中用的多） until (跳出循环) (gdb) b main Breakpoint 4 at 0x555555555189: file main.c, line 11. (gdb) r 9 Starting program: /home/lwy/workspace/gdbtest/main 9 Breakpoint 4, main (argc=21845, argv=0x0) at main.c:11 11 { (gdb) n 12 struct inout * io = (struct inout * ) malloc(sizeof(struct inout)); (gdb) n 13 if (NULL == io) { (gdb) n 18 if (argc != 2) { (gdb) n 23 io -\u003e value = *argv[1] - '0'; (gdb) n 24 io -\u003e result = sum(io -\u003e value); (gdb) print io-\u003evalue $4 = 9 (gdb) set variable io-\u003evalue=10 (gdb) n 25 printf(\"Your enter: %d, result:%d\\n\", io -\u003e value, io -\u003e result); (gdb) n Your enter: 10, result:55 26 return 0; set $r0=xxx：设置r0寄存器的值为xxx。 ","date":"2021-04-07","objectID":"/gdb/:1:9","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"生成内核转储文件* 通过generate-core-file生成core.xxxx转储文件。 然后gdb ./main ./core.xxxx查看恢复的现场。 (gdb) generate-core-file warning: target file /proc/14188/cmdline contained unexpected null characters Saved corefile core.14188 lwy@lwysLaptop:~/workspace/gdbtest$ gdb ./main ./core.14188 Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from ./main... [New LWP 14188] Core was generated by `/home/lwy/workspace/gdbtest/main 9'. Program terminated with signal SIGTRAP, Trace/breakpoint trap. #0 main (argc=2, argv=0x7fffffffe048) at main.c:26 26 return 0; 另一命令gcore可以从命令行直接生成内核转储文件。 gcore pidof 命令：无需停止正在执行的程序以获得转储文件。 ","date":"2021-04-07","objectID":"/gdb/:1:10","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"attach到进程* 如果程序已经运行，或者是调试陷入死循环而无法返回控制台进程，可以使用attach命令。 attach pid 通过ps aux可以查看进程的pid，然后使用bt查看栈帧。 以top为例操作步骤为： ps -aux查看进程pid，为16974. sudo gdb attach 16974，使用gdb 附着到top命令。 使用bt full查看，当前栈帧。此时使用print等查看信息。 还可以通过info proc查看进程信息。 ","date":"2021-04-07","objectID":"/gdb/:1:11","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"反复执行 continue、step、stepi、next、nexti都可以指定重复执行的次数。 ignore 断点编号 次数：可以忽略指定次数断点。 ","date":"2021-04-07","objectID":"/gdb/:1:12","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"dump内存到指定文件 在gdb调试中可能需要将一段内存导出到文件中，可以借助dump命令。 命令格式： dump binary memory FILE START STOP 比如dump binary memory ./dump.bin 0x0 0x008000000，将内存区间从0x0到0x00800000导出到dump.bin中。 ","date":"2021-04-07","objectID":"/gdb/:1:13","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Tools"],"content":"多进程调试 使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child] 设置调试模式：set detach-on-fork [on | off] 默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。 查看调试的进程：info inferiors 切换当前调试的进程：inferior id 使进程脱离 GDB 调试：detach inferiors id ","date":"2021-04-07","objectID":"/gdb/:1:14","tags":["GDB","Compile"],"title":"GDB调试基础","uri":"/gdb/"},{"categories":["Operating System"],"content":"进程的概念 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。  一个进程在CPU上运行可以有两种运行模式（进程状态）：用户模式和内核模式。如果当前运行的是用户程序（用户代码），那么对应进程就处于用户模式（用户态），如果出现系统调用或者发生中断，那么对应进程就处于内核模式（核心态） ","date":"2021-04-06","objectID":"/process/:1:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程的状态模型 下图为进程的7状态模型，常用的5状态模型在该图的基础上去掉了挂起状态。其中包括如下状态： New State：New state is the state when the process is under creation Ready State: When the process is created new state comes, which is called ready state. After creation process comes under ready state. In ready state more than one process can also come. For example: One process is created at the same time second process is created then both the process will come under ready state. Running State: From ready state we have to select a process, and then have to allot CPU to that process for run. When CPU is allotted to process in ready state that process comes in running state. In running state only one process can stay at a time. Because CPU can be allotted to single process at a time. Wait State: When a process request for input/output than that process will left the running state, and will join new state known as wait state. In wait state more than one process can stay. After completion of I/O request process will go to ready state. Termination State: When process comes in running state, there is no more input output request by the process, because it’s already get completed. So process will go to termination state. Suspend Ready State: When ready state is not able to occupy more states in it, than some states are suspended in suspended state. Suspend ready state will be in secondary memory not in primary memory. When ready state get space for new processes than, processes from suspended ready state gets switch back to ready state. Such transaction is known as resume. Suspend Wait State: Similarly suspend wait state is also reside in process state diagram. ","date":"2021-04-06","objectID":"/process/:2:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"Linux进程组织 Linux进程通过一个task_struct结构体描述，在linux/sched.h中定义，通过理解该结构，可更清楚的理解linux进程模型。包含进程所有信息的task_struct数据结构是比较庞大的，但是该数据结构本身并不复杂，我们将它的所有域按其功能可做如下划分：  进程状态（State）  进程调度信息（Scheduling Information）  各种标识符（Identifiers）  进程通信有关信息（IPC：Inter_Process Communication）  时间和定时器信息（Times and Timers）  进程链接信息（Links）  文件系统信息（File System）  虚拟内存信息（Virtual Memory）  页面管理信息（page）  对称多处理器（SMP）信息  和处理器相关的环境（上下文）信息（Processor Specific Context）  其他信息 ","date":"2021-04-06","objectID":"/process/:3:0","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程状态 为了对进程从产生到消亡的整个过程进行跟踪和描述，就需要定义各种进程的各种状态并制定相应的状态转换策略，以此来控制进程的运行。 Linux系统中，进程状态在 task_struct 中定义如下： volatile long state; /* -1 unrunnable, 0 runnable, \u003e0 stopped */ 其状态取值如下： #define TASK_RUNNING 0 #define TASK_INTERRUPTIBLE 1 #define TASK_UNINTERRUPTIBLE 2 #define __TASK_STOPPED 4 #define __TASK_TRACED 8 /* in tsk-\u003eexit_state */ #define EXIT_ZOMBIE 16 #define EXIT_DEAD 32 /* in tsk-\u003estate again */ #define TASK_DEAD 64 #define TASK_WAKEKILL 128 #define TASK_WAKING 256 #define TASK_STATE_MAX 512 对进程每个状态简析如下： TASK_RUNNING （可运行状态）：处于这种状态的进程，要么正在运行、要么正准备运行。正在运行的进程就是当前进程（由current所指向的进程），而准备运行的进程只要得到CPU就可以立即投入运行，CPU是这些进程唯一等待的系统资源。 TASK_INTERRUPTIBLE（可中断的等待状态）：表示进程被阻塞（睡眠），直到某个条件达成，进程的状态就被设置为TASK_RUNNING。处于该状态的进程正在等待某个事件（event）或某个资源，而被挂起。对应的task_struct结构被放入对应事件的等待队列中。处于可中断等待态的进程可以被信号（外部中断触发或者其他进程触发）唤醒，如果收到信号，该进程就从等待状态进入可运行状态，并且加入到运行队列中，等待被调度。 TASK_UNINTERRUPTIBLE（不可中断的等待状态）：该状态与 TASK_INTERRUPTIBLE 状态类似，也表示进程被阻塞，处于睡眠状态。当进程等待的某些条件被满足了之后，内核也会将该进程的状态设置为 TASK_RUNNING。但是，处于这个状态下的进程不能在接收到某个信号之后立即被唤醒。这时该状态与 TASK_INTERRUPTIBLE 状态唯一的区别。 __TASK_STOPPED（暂停状态）：此时的进程暂时停止运行来接受某种特殊处理。通常当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后就处于这种状态。例如，正接受调试的进程就处于这种状态。 __TASK_TRACED（跟踪状态）：当前进程正在被另一个进程所监视。 EXIT_ZOMBIE（僵死状态）：进程虽然已经终止，但由于某种原因，父进程还没有执行wait()系统调用，终止进程的信息也还没有回收。顾名思义，处于该状态的进程就是死进程，这种进程实际上是系统中的垃圾，必须进行相应处理以释放其占用的资源。 EXIT_DEAD：一个进程的最终状态。 以下是LINUX进程间状态转换和内核调用图解 ","date":"2021-04-06","objectID":"/process/:3:1","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程内存布局 每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”： 文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。 初始化数据段：包含显示初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。 未初始化数据段：包含了未进行显示初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。出于历史原因，此段常被称为BSS段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配空间。 栈（stack）：是一个动态增长和收缩的段，有栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。 堆（heap）：是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称为program break。 对于初始化和未初始化的数据段而言，不太常用、但表达更清晰的称为分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。 在大多数Unix（包括Linux）中的C语言编程环境提供了3个全局符号（symbol）：etext、edata、end，可以在程序中使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。 使用这些符号，必须显式声明如下： // For example, \u0026etext gives the address of the end of the program text / start of initialized data extern char etext, edata, end; 图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。 ","date":"2021-04-06","objectID":"/process/:3:2","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"孤儿进程（orphan） 我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main () { /*fpid表示fork函数返回的值,fork会返回两次， 一次是父进程，返回值是子进程的Pid，在子进程会返回0*/ pid_t fpid; fpid=fork();//fork后会出现两个分支执行下面的代码，一个父进程，一个新的子进程 if (fpid \u003c 0) printf(\"fork error!\"); else if (fpid == 0) { // printf(\"child id is %dn\",getpid()); sleep(100); } else { //父进程 printf(\"parent id is %dn\",getpid()); sleep(30);//睡眠30s，在子进程之前退出 printf(\"parend finally...\"); } } ","date":"2021-04-06","objectID":"/process/:3:3","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"僵尸进程（zombie） 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。 unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。 任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。 僵尸进程危害场景： 例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main () { /*fpid表示fork函数返回的值,fork会返回两次， 一次是父进程，返回值是子进程的Pid，在子进程会返回0*/ pid_t fpid; fpid=fork();//fork后会出现两个分支执行下面的代码，一个父进程，一个新的子进程 if (fpid \u003c 0) printf(\"fork error!\"); else if (fpid == 0) { // printf(\"child id is %dn\",getpid()); sleep(30);//睡眠30s，在父进程之前退出 printf(\"child finally...\"); } else { //父进程 printf(\"parent id is %dn\",getpid()); sleep(60); printf(\"parend finally...\"); } } 僵尸进程解决办法 通过信号机制 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示： #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e static void sig_child(int signo); int main() { pid_t pid; //创建捕捉子进程退出信号 signal(SIGCHLD,sig_child); pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } else if (pid == 0) { printf(\"I am child process,pid id %d.I am exiting.\\n\",getpid()); exit(0); } printf(\"I am father process.I will sleep two seconds\\n\"); //等待子进程先退出 sleep(2); //输出进程信息 system(\"ps -o pid,ppid,state,tty,command\"); printf(\"father process is exiting.\\n\"); return 0; } static void sig_child(int signo) { pid_t pid; int stat; //处理僵尸进程 while ((pid = waitpid(-1, \u0026stat, WNOHANG)) \u003e0) printf(\"child %d terminated.\\n\", pid); } fork两次 《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。测试程序如下所示 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e int main() { pid_t pid; //创建第一个子进程 pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } //第一个子进程 else if (pid == 0) { //子进程再创建子进程 printf(\"I am the first child process.pid:%d\\tppid:%d\\n\",getpid(),getppid()); pid = fork(); if (pid \u003c 0) { perror(\"fork error:\"); exit(1); } //第一个子进程退出 else if (pid \u003e0) { printf(\"first procee is exited.\\n\"); exit(0); } //第二个子进程 //睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里 sleep(3); printf(\"I am the second child process.pid: %d\\tppid:%d\\n\",getpid(),getppid()); exit(0); } //父进程处理第一个子进程退出 if (waitpid(pid, NULL, 0) != pid) { perror(\"waitepid error:\"); exit(1); } exit(0); return 0; } ","date":"2021-04-06","objectID":"/process/:3:4","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"守护进程 控制终端 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl + C会产生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 进程组 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员 会话 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程 守护进程 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程特征 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事： 该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID 该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断 如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID是重新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。我认为创建新会话的进程不能是组长进程的原因：在新创建的会话中，创建会话的进程成为了会话首进程，同时，该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID，如果其已经是一个组长进程，那么就会产生矛盾。 一般守护进程创建步骤 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。 执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（/）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。 核心业务逻辑 示例 /* 写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。 */ #include \u003cstdio.h\u003e#include \u003csys/stat.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/time.h\u003e#include \u003csignal.h\u003e#include \u003ctime.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e void work(int num) { // 捕捉到信号之后，获取系统时间，写入磁盘文件 time_t tm = time(NULL); struct tm * loc = localtime(\u0026tm); // char buf[1024]; // sprintf(buf, \"%d-%d-%d %d:%d:%d\\n\",loc-\u003etm_year,loc-\u003etm_mon // ,loc-\u003etm_mday, loc-\u003etm_hour, loc-\u003etm_min, loc-\u003etm_sec); // printf(\"%s\\n\", buf); char * str = asctime(loc); int fd = open(\"time.txt\", O_RDWR | O_CREAT | O_APPEND, 0664); write(fd ,str, strlen(str)); close(fd); } int main() { // 1.创建子进程，退出父进程 pid_t pid = fork(); if(pid \u003e 0) { exit(0); } // 2.将子进程重新创建一个会话 setsid(); // 3.设置掩码 umask(022); // 4.更改工作目录 chdir(\"/home/nowcoder/\"); // 5. 关闭、重定向文件描述符 int fd = open(\"/dev/null\", O_RDWR); dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); // 6.业务逻辑 // 捕捉定时信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(\u0026act.sa_mask); sigaction(SIGALRM, \u0026act, NULL); struct itimerval val; val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // 创建定时器 setitimer(ITIMER_REAL, \u0026val, NULL); // 不让进程结束 while(1) { sleep(10); } return 0; } ","date":"2021-04-06","objectID":"/process/:3:5","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Operating System"],"content":"进程管理命令 ps ps命令（Processes Statistic）时Linux系统中最为常用的进程查看工具，主要用于显示包含当前运行的各进程完整信息的静态快照。通过不同的命令选项，可以有选择性地查看进程信息。 ■ a：显示当前终端下的所有进程信息，包括其他用户的进程。与“x”选项结合时将显示系统中所有的进程信息。 ■ u：使用以用户为主的格式输出进程信息。 ■ x：显示当前用户在所有终端下的进程信息。 ■ –e：显示系统内的所有进程信息。 ■ –l：使用长格式显示进程信息。 ■ –f：使用完整的格式显示进程信息。 以上是ps命令中几个常用的选项，需要注意的是，有一部分选项时不带“-”前缀的。习惯上将上述选项组合在一起使用，如执行“ps aux”或“ps -elf” 上述输出信息中，第一行为列表标题，其各字段的含义描述如下。 ■ USER：启动该进程的户账号的名称。 ■ PID：该进程在系统中的数字ID号，在当前系统中是唯一的。 ■ TTY：表明该进程在哪个终端上运行。“？”表示未知或不需要终端。 ■ STAT:显示了进程当前的状态，如S（休眠）、R（运行）、Z（僵死）、\u003c（高优先级）、N（低优先级）、s（父进程）、+（前台进程）。 ■ START：启动该进程的时间。 ■ TIME：该进程占用的CPU时间。 ■ COMMAND：启动该进程的命令的名称。 ■ %CPU：CPU占用的百分比。 ■ %MEM：内存占用的百分比。 ■ VSZ：占用虚拟内存（swap空间）的大小。 ■ RSS：占用常驻内存（物理内存）的大小。 top top命令将会在当前终端以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次。作用类似Windows系统中的“任务管理器”。 上述输出信息中，开头的部分显示了系统任务（Tasks）、CPU占用、内存占用（Mem）、交换空间（Swap）等汇总信息；汇总信息下方依次显示当前进程的排名情况。相关信息的含义表述如下。 系统任务（Tasks）信息：total，总进程数; running,正在运行的进程数；sleeping，休眠的进程数；stopped，终止的进程数；zombie，僵死无响应的进程数。 CPU占用信息：us，用户占用；sy，内核占用；ni，优先级调度占用；id，空闲CPU；wa，1/0等占用； hi，硬件中断占用，si，软件中断占用；st，虚拟化占用。 内存占用（Mem）信息：total，总内存空间；used，已用内存；free，空闲内存；buffers，缓冲区域。 交换空间（Swap）占用：total，总内存空间；used，已用内存；free，空闲内存； buffers，缓冲区域。 在top命令的全屏操作界面中：可以按P键根据CPU占用情况对进程列表进行排序。 按M键根据内存占用情况进行排序。 按N键根据启动时间进行排序。 按h键可以获得top程序的在线帮助。 按q键可以正常的退出top程序。 按k键在列表上方会出现“PID to kill：”的提示信息，根据提示输入指定进程的PID并按Enter键确认即可终止对应的进程。 pgrep 使用pgrep命令可以根据进程的名称、运行该进程的用户、进程所在的终端等多种属性查询特定进程的PID号。 通过pgrep命令，可以只指定进程的一部分名称进行查询，结合“-l”选项可同时输出对应的进程名（否则只输PID号，不便于理解）。例如，查询进程中包含“log”的进程及其PID号，可以执行以下操作。 [root@lwy~]# pgrep -l “log” 2538 rsyslog 2113 mcelog 还可以结合“-U”选项查询特定用户的进程、“-t”选项查询在特定终端运行的进程。例如，若要查询用户zhangsan在tty3终端上运行的进程及PID号，可以执行以下操作。 [root@lwy~]# pgrep -l -U zhangsan-t tty3 2105 bash 2122 vim pstree pstree命令可以输出Linux系统中各进程的树形结构，以更加直观地判断出各进程之间的相互关系（父、子进程）。 pstree命令默认情况下只显示个进程的名称，结合“-p”选项使用时可以同时列出对应的PID号，结合“-u”选项可以列出对应的用户名，结合“-a”选项可以列出完整的命令信息。例如，执行“pstree -aup”命令可以查看当前系统的进程树，包括个进程对应的PID号、用户名、完整命令等信息。从出输出结果中可以看出，init进程确实是Linux系统中所有进程的“始祖” 改变进程的运行方式 挂起当前的进程  当Linux系统中的命令正在前台执行时（运行尚未结束），按Ctrl+Z组合键可以将当前进程挂起（调入后台并停止执行），这种操作在需要暂停当前进程并进行其他操作时特别有用。 [root@lwy~]# cp /dev/cdrom/mnt/Redhat6.0.iso [1]+ Stopped cp -i/dev/cdrom /mnt/Redhat6.0.iso 查看后台的进程 查看当前终端中在后台运行的进程任务时，可以使用jobs命令，结合“-l”选项可以同时显示出该进程对应的PID号。 [root@lwy~]# jobs -l [1]+ 2193 Stopped cp -i /dev/cdrom /mnt/Redhat6.0.iso 将后台的进程恢复运行 ■ 使用bg（BackGround，后台）命令，可以将后台中暂定执行（如按Ctrl+Z组合键挂起）的任务恢复运行，继续在后台执行操作、 ■ 使用fg命令（ForeGround，前台）命令，可以将后台任务重新恢复到前台运行。 除非后台中的任务只有一个，否则bg和fg命令都需要指定后台进程的任务编号作为参数。 例如，执行“fg 1”命令可以将之前挂起至后台的cp进程重新调入前台执行。 [root@lwy/]# jobs [1]+ Stopped cp -i/dev/cdrom /mnt/Redhat6.0.iso [root@lwy/]# fg 1 cp -i /dev/cdrom /mnt/Redhat6.0.iso 用pkill命令终止进程 使用pkill命令可以根据进程的名称、运行该进程的用户、进程所在的终端等多种属性终止特定的进程，大部分选项与pgrep命令基本类似，如“-U”（指定用户）、“-t”（指定终端）等选项。 例如，若要终止由用户zhangsan启动的进程（包括登陆Shell），可以执行以下操作。 [root@lwy/]# pgrep -l -U\"zhangsan\" 2105 bash [root@lwy/]# pkill -9 -U\"zhangsan\" [root@lwy/]# pgrep -l -U\"zhangsan\" ","date":"2021-04-06","objectID":"/process/:3:6","tags":["Unix"],"title":"Unix进程模型","uri":"/process/"},{"categories":["Tools"],"content":"静态库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。 库的好处：1.代码保密 2.方便部署和分发 ","date":"2021-04-04","objectID":"/make_lib/:1:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"静态库的使用 通过gcc的-L命令指定库的路径，通过-l命令指定库的名字，注意这里库的名字不加lib,例如库的文件名为libxxx.lib那么库名就是xxx。 ","date":"2021-04-04","objectID":"/make_lib/:1:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"动态库 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic dependencies）命令检查动态库依赖关系 如何定位共享库文件呢？ 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——\u003e 环境变量LD_LIBRARY_PATH ——\u003e /etc/ld.so.cache文件列表 ——\u003e /lib/，/usr/lib 目录找到库文件后将其载入内存。 ","date":"2021-04-04","objectID":"/make_lib/:2:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"动态库的使用 程序在执行的时候是如何定位共享库文件的呢？ 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—\u003e环境变量LD_LIBRARY_PATH—\u003e/etc/ld.so.cache文件列表—\u003e/lib/,/usr/lib 目录找到库文件后将其载入内存。 如何让系统能够找到它： 如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。 如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下： 编辑/etc/ld.so.conf文件，加入库文件所在目录的路径 运行ldconfig ，该命令会重建/etc/ld.so.cache文件 ","date":"2021-04-04","objectID":"/make_lib/:2:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"静态库与动态库对比 静态库特点总结： 静态库对函数库的链接是放在编译时期完成的。 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件 动态库特点总结： 动态库把对一些库函数的链接载入推迟到程序运行的时期。 可以实现进程之间的资源共享。（因此动态库也称为共享库） 将一些程序升级变得简单。 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。 静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。 ","date":"2021-04-04","objectID":"/make_lib/:3:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"Makefile 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编 译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就 像一个 Shell 脚本一样，也可以执行操作系统的命令。 Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整 个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个 解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如 Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。 ","date":"2021-04-04","objectID":"/make_lib/:4:0","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"Makefile规则 一个 Makefile 文件中可以有一个或者多个规则 目标 ...: 依赖 ... 命令（Shell 命令） ... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或是目标 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进） Makefile 中的其它规则一般都是为第一条规则服务的 ","date":"2021-04-04","objectID":"/make_lib/:4:1","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"依赖检查与更新检测 命令在执行之前，需要先检查规则中的依赖是否存在 ，如果存在，执行命令 ，如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的， 如果找到了，则执行该规则中的命令 在执行规则中的命令时，会比较目标和依赖文件的时间 。如果依赖的时间比目标的时间晚，需要重新生成目标 ，如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 ","date":"2021-04-04","objectID":"/make_lib/:4:2","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"变量 自定义变量 变量名=变量值 var=hello 预定义变量 AR : 归档维护程序的名称，默认值为 ar CC : C 编译器的名称，默认值为 cc CXX : C++ 编译器的名称，默认值为 g++ @ : 目标的完整名称 \u003c : 第一个依赖文件的名称 ^ : 所有的依赖文件 特殊命令 $(wildcard PATTERN...) 功能：获取指定目录下指定类型的文件列表 参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔 示例： $(wildcard *.c ./sub/*.c) 返回值格式: a.c b.c c.c d.c e.c f.c $(patsubst ,,) 功能：查找中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式，如果匹配的话，则以替换。 可以包括通配符%，表示任意长度的字串。如果 中也包含%，那么，中的这个%将是中的那个% 所代表的字串。(可以用\\来转义，以\\%来表示真实含义的%字符) 返回：函数返回被替换过后的字符串 示例：$(patsubst %.c, %.o, x.c bar.c) 返回值格式: x.o bar.o ","date":"2021-04-04","objectID":"/make_lib/:4:3","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Tools"],"content":"简单示例 #定义变量 src=sub.o add.o mult.o div.o main.o target=app $(target):$(src) $(CC) $(src) -o $(target) %.o:%.c $(CC) -c $\u003c -o $@ ","date":"2021-04-04","objectID":"/make_lib/:4:4","tags":["Unix","Makefile"],"title":"Makefile与库的制作","uri":"/make_lib/"},{"categories":["Operating System"],"content":"POSIX简介 ","date":"2021-03-29","objectID":"/posix/:1:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1. 概念 POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ） ","date":"2021-03-29","objectID":"/posix/:1:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.发布者-IEEE 发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。 IEEE，总部位于美国纽约，是一个国际性的电子技术与信息科学工程师的协会，也是目前全球最大的非营利性专业技术学会。IEEE致力于电气、电子、计算机工程和与科学有关的领域的开发和研究，在太空、计算机、电信、生物医学、电力及消费性电子产品等领域已制定了1300多个行业标准，现已发展成为具有较大影响力的国际学术组织 POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。 POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。 ","date":"2021-03-29","objectID":"/posix/:1:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.POSIX标准相关文件 Single UNIX Specification V3，IEEE Std 1003.1,2004 Edition 标准线上地址： The UNIX System 注册后可以在线阅读或者下载。 IEEE和Open Group 的POSIX认证： POSIX Certified by IEEE and The Open Group 相关页面： IEEE Std 1003.1, 2004 Edition ","date":"2021-03-29","objectID":"/posix/:1:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"POSIX历史 ","date":"2021-03-29","objectID":"/posix/:2:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1.起源 POSIX是Unix的标准。 1974年，贝尔实验室正式对外发布Unix。因为涉及到反垄断等各种原因，加上早期的Unix不够完善，于是贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。 于是出现了好些独立开发的与Unix基本兼容但又不完全兼容的OS，通称Unix-like OS。 包括： 美国加州大学伯克利分校的Unix4.xBSD(Berkeley Software Distribution)。 贝尔实验室发布的自己的版本，称为System V Unix。 其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。 20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同。 局面非常混乱，麻烦也就随之而来了。 为了提高兼容性和应用程序的可移植性，阻止这种趋势， IEEE(电气和电子工程师协会)开始努力标准化Unix的开发，后来由 Richard Stallman命名为“Posix”。 这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。 ","date":"2021-03-29","objectID":"/posix/:2:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.标准覆盖 市面上绝大多数操作系统厂家都支持该标准，首先就是大名鼎鼎的Unix和Linux了，除此之外还有苹果的操作系统也是Unix-based的。有了这个规范，你就可以调用通用的API了，Linux提供的POSIX系统调用在Unix上也能执行，因此学习Linux的底层接口最好就是理解POSIX标准。Windows从WinNT开始就有兼容POSIX的考虑。这是因为当年在要求严格的领域，Unix地位比Windows高。为了把Unix用户拉到Windows阵营，被迫支持POSIX。 现在Win10对 Linux/POSIX 支持好，则是因为Linux已经统治了廉价服务器市场。为了提高Windows的竞争力搞的。所以一切都是以市场为主导。 ","date":"2021-03-29","objectID":"/posix/:2:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.支持POSIX-Linux成功的最重要一个因素 Linux之所以能够成功，有很多因素，但是支持POSIX标准无疑是它能够快速发展的最重要的一个因素。 POSIX 标准的制定最后投票敲定阶段大概是 1991~1993 年间，而此时正是Linux 刚刚起步的时候，这个 UNIX 标准为 Linux 提供了极为重要的信息，使得 Linux 能够在标准的指导下进行开发，并能够与绝大多数 UNIX 操作系统兼容。 在最初的 Linux 内核源码（0.01版、0.11版）中就已经为 Linux 系统与 POSIX 标准的兼容做好了准备工作。 在 Linux 0.01 版内核 /include/unistd.h 文件中就已经定义了几个有关 POSIX 标准要求的符号常数，而且 Linus 在注释中已写道：“OK，这也许是个玩笑，但我正在着手研究它呢”。 正是由于Linux支持POSIX标准，无数可以在unix上运行的程序都陆续的移植到Linux上，而此时unix因为版权问题，官司打的不可开交，使得Linux后来者居上。 而Linus也在《知识为了好玩》中讲述了POSIX的重要性： POSIX标准是一个可以适用于数以百计的UNIX系统调用中的任意一个的一套冗长规则， 计算机要执行任务（从读、 写、 开机和关机开始） 就需要这个标准。 POSIX则是指一个UNIX的标准体系， 或一个由来自不同公司的代表所组成的一个组织， 希望按照一个共同的标准进行运作。 对于程序员开发的在该操作系统下的新应用软件或开发应用软件的新版本而言， 标准是极其重要的。 从POSIX这样的系统调用（system call） ， 尤其是重要的调用（call） 中， 我可以获得一个操作系统应该具有哪些功能的一个单子； 然后我就可以通过自己的方式在自己的系统中实现每一个功能。 通过编写出这些标准， 我的系统软件的源代码将可以被别人使用， 以开发新的应用软件。 当时我并不知道我本可以直接从POSIX公司买到这些规则的软盘， 但这无所谓。 哪怕我能买得起， 什么东西运到芬兰， 往往会需要很长的时间。 我不愿等上那么久， 因此我四处搜求一个能从FTP地址上直接下载的版本。 没有人给我提供能找到POSI标准的来源。 于是我开始了计划B。 我从学校找到运行sun器(sun server)的sun微系统版的UNIX手册。 该手册中有一个完全可以凑合使用的系统呼叫的基本版本。 从用户手册中能看出系统呼叫的主要功能， 以及为完成这些功能所需要完成的步骤。 但是， 从中看不出具体的方法， 而只是标明了最终的结果。 于是我便着手从安德鲁·塔南鲍姆的书中和别的材料中收集一些系统呼叫。 最终有人给我寄来了那几卷厚厚的POSIX标准。 ","date":"2021-03-29","objectID":"/posix/:2:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"可移植性 聊到POSIX，那我们就不得不说说到底什么是可移植性，在讲可移植性之前，我们先来了解库函数和系统调用的区别。 Linux下对文件操作有两种方式：系统调用（system call）和库函数调用（Library functions）。 ","date":"2021-03-29","objectID":"/posix/:3:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"1.系统调用 系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。 ","date":"2021-03-29","objectID":"/posix/:3:1","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"2.库函数 库函数（Library function）是把函数放到库里，供别人使用的一种方式。 方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。 库函数调用则是面向应用开发的，库函数可分为两类， 一类是C语言标准规定的库函数， 一类是编译器特定的库函数。 (由于版权原因，库函数的源代码一般是不可见的，但在头文件中你可以看到它对外的接口)。 glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的。 glibc 为程序员提供丰富的 API（Application Programming Interface），这些API都是遵循POSIX标准的，API的函数名，返回值，参数类型等都必须按照POSIX标准来定义。 POSIX兼容也就指定这些接口函数兼容，但是并不管API具体如何实现。 ","date":"2021-03-29","objectID":"/posix/:3:2","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"3.库函数API和系统调用的区别 如上图所示： (1) 库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分 (2) 库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大 (3) 系统调用依赖于平台，库函数并不依赖 系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。 库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性好。 ","date":"2021-03-29","objectID":"/posix/:3:3","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"4.程序的可移植性及其本质 程序在不同的机器上会生成不同的目标代码，那么目标代码和启动代码是怎么生成的呢？ 答案是编译器。 编程语言编写的程序首先要被编译器编译成目标代码（0、1代码），然后在目标代码的前面插入启动代码，最终生成了一个完整的程序。 要注意的是，程序中为访问特定设备（如显示器）或者操作系统（如windows xp 的API)的特殊功能而专门编写的部分通常是不能移植的。 综上所述，一个编程语言的可移植性取决于 不同平台编译器的数量 对特殊硬件或操作系统的依赖性 移植是基于操作系统的。但是这个时候，我们需要注意一点：基于各种操作系统平台不同，应用程序在二级制级别是不能直接移植的。 我们只能在代码层去思考可移植问题，在API层面上由于各个操作系统的命名规范、系统调用等自身原因，在API层面上实现可移植也是不大可能的。 在各个平台下，我们默认C标准库中的函数都是一样的，这样基本可以实现可移植。但是对于C库本身而言，在各种操作系统平台下其内部实现是完全不同的，也就是说C库封装了操作系统API在其内部的实现细节。 因此，C语言提供了我们在代码级的可移植性，即这种可移植是通过C语言这个中间层来完成的。 例如在我们的代码中下功夫。以下代码可以帮助我们实现各平台之间的可移植： #ifdef _WINDOWS_ CreateThread(); //windows下线程的创建 #else Pthread_create(); //Linux下线程的创建 #endif 对于头文件，也使用同样的预编译宏来实现。如： #ifndef _WINDOWS_ #include \u003cwindows.h\u003e#else #include \u003cthread.h\u003e#endif 这样就可以实现代码的可移植了。在编译的时候只要通过#define就可以选择在那个平台下完成程序的编译。 综上所述，我们都是将C，C++等各种语言当作中间层，以实现其一定程度上的可移植。如今，语言的跨平台的程序都是以这样的方式实现的。但是在不同的平台下，仍需要重新编译。 ","date":"2021-03-29","objectID":"/posix/:3:4","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"5.系统开销 使用系统调用会影响系统的性能，在执行调用时的从用户态切换到内核态，再返回用户态会有系统开销。 为了减少开销，因此需要减少系统调用的次数，并且让每次系统调用尽可能的完成多的任务。 硬件也会限制对底层系统调用一次所能写的数据块的大小。 为了给设备和文件提供更高层的接口，Linux系统提供了一系列的标准函数库。 使用标准库函数，可以高效的写任意长度的数据块，库函数在数据满足数据块长度要求时安排执行底层系统调用。 一般地，操作系统为了考虑实现的难度和管理的方便，它只提供一少部分的系统调用，这些系统调用一般都是由C和汇编混合编写实现的，其接口用C来定义，而具体的实现则是汇编，这样的好处就是执行效率高，而且，极大的方便了上层调用。 随着系统提供的这些库函数把系统调用进行封装或者组合，可以实现更多的功能，这样的库函数能够实现一些对内核来说比较复杂的操作。 比如，read()函数根据参数，直接就能读文件，而背后隐藏的比如文件在硬盘的哪个磁道，哪个扇区，加载到内存的哪个位置等等这些操作，程序员是不必关心的，这些操作里面自然也包含了系统调用。 而对于第三方的库，它其实和系统库一样，只是它直接利用系统调用的可能性要小一些，而是利用系统提供的API接口来实现功能(API的接口是开放的)。 ","date":"2021-03-29","objectID":"/posix/:3:5","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["Operating System"],"content":"例子 如下图是Linux系统调用的大概流程。 当应用程序调用printf()函数时，printf函数会调用C库中的printf，继而调用C库中的write，C库最后调用内核的write()。 而另一些则不会使用系统调用，比如strlen, strcat, memcpy等。 printf函数执行过程中，程序运行状态切换如下： 用户态–\u003e系统调用–\u003e内核态–\u003e返回用户态 printf函数、glibc库和系统调用在系统中关系图如下 实例代码如下： #include \u003cstdio.h\u003e int main(int argc, char **argv) { printf(\"hello world\"); return 0; } 编译执行 lwy@lwysLaptop:~/workspace$ gcc test.c -o test \u0026\u0026 strace ./test 运行程序前加上strace，可以追踪到函数库调用过程 如执行结果可知： 我们的程序虽然只有一个printf函数，但是在执行过程中，我们前后调用了execve、access、open、fstat、mmap、brk、write等系统调用。 其中write系统调用会把字符串：hello world通过设备文件1，发送到驱动，该设备节点对应终端stdout。 ","date":"2021-03-29","objectID":"/posix/:4:0","tags":["Unix","GNU"],"title":"POSIX是什么","uri":"/posix/"},{"categories":["C/C++"],"content":"IFNDEF ifndef的含义是If not define, 其搭配使用如下 // xxx.h #ifndef __INCxxx.h #define __INCxxx.h #ifndef __cpluscplus extern \"C\" { #endif /*...*/ #ifndef } #endif #endif ","date":"2021-03-19","objectID":"/ifndef/:1:0","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"1.多次包含的情况 include xxx 就是将xxx的内容原地展开 假设有： a.h， 内容是 A b.h， 内容是： #include \"a.h\" B c.h， 内容是： #include \"a.h\" C 如果有一个文件x.c， 内容是： #include \"b.h\" #include \"c.h\" X b.h和c.h的内容就会被插入到X之前， 也就是这个样子： A B A C X A的内容就出现了2次。 在更复杂的环境中， A的内容还可能出现多次。 ","date":"2021-03-19","objectID":"/ifndef/:1:1","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"2.多次出现是有问题的 一般来说， 重复声明没什么问题。 所以， 如果A.h中止包含一些声明， 那重复了也没什么关系。 比如： int f(int); int f(int); int f(int); extern int i; extern int i; extern int i; struct x; struct x; struct x; 重复写N次也没关系。 但头文件中会出现一类\"定义\"， 在同一翻译单元中是不能重复的。 比如： struct x { ... }; struct x { ... }; // 重复定义 #define M ... #define M ... // 重复定义 ","date":"2021-03-19","objectID":"/ifndef/:1:2","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"3.头文件保护符 有时候必须将这些定义放在头文件中， 所以就要用头文件保护符。 另外还有一类\"定义\"， 会产生外部符号。 这类\"定义\"在一个链接过程中只能有唯一一份。 是不可以加入到头文件中的。 这种定义依然有例外…… 就是inline、模板和匿名名字空间， 就不扯远了…… 假设A的内容是： #ifndef A_H #define A_H AA #endif 如果A被展开多次，例如上面的X， 就会变成这个样子 // A_H是a.h的保护符， 必须是一个不冲突的名字。 那么，这里就不会有A_H的定义 // 然后紧接这下一行中的条件编译就会选中#ifndef 和#endif之间的部分， // 也就是#define A_H 和AA #ifndef A_H #define A_H AA #endif B // 在a.h被第一次包含后， A_H就获得定义 // 所以下一行的条件编译部分就被取消， AA就不会重复出现多次 #ifndef A_H #define A_H AA #endif C X 最终交给编译器看到的代码就是： AA B C X 只要A_H是唯一的， AA就不会重复出现。 就解决了这个问题， 一般情况就是这么用的， 是为惯例。 ","date":"2021-03-19","objectID":"/ifndef/:1:3","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"4.外部头文件保护符 上面的用法是\"内部头文件保护符\"。 a.h的保护符是使用在a.h里。 另外一种用法是\"外部头文件保护符\"， 如： ------ a.h ------ AA ------ b.h ------ #ifndef A_H #define A_H #include \"a.h\" #endif B ------ c.h ------ #ifndef A_H #define A_H #include \"a.h\" #endif C 当X同时包含b.h和c.h时， 最终效果和内部头文件保护符差不多。 两者对比， 外部的优势是可以减少打开a.h的次数。 而内部保护符可以降低a.h和b.h, c.h之间的耦合。 ","date":"2021-03-19","objectID":"/ifndef/:1:4","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"5.定义保护符 马上就要到主题了…… 将头文件保护符的用法扩展一下， 就变成了定义保护符（这个名字是我捏造的）。 保护的不是某个\"头文件\" 而是某个\"定义\"， 如： ------ a.h ------ #ifndef A_X #define A_X struct x { ... }; #endif #ifndef A_M #define A_M #define M ... #endif ... b.h和c.h直接包含a.h， 最终效果也是一样。 ","date":"2021-03-19","objectID":"/ifndef/:1:5","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["C/C++"],"content":"6.重复的定义保护符 到主题了…… 同样是一个捏造的词。 假设： b.h包含a.h是为了获得struct x的定义。 而c.h包含a.h是为了获得宏M的定义。 除了上面作法， 还有另一种做法： a.h和上面差不多 #ifndef X #define X struct x { ... }; #endif #ifndef M #define M ... #endif 而b.h和c.h并不包含a.h， 而是直接将需要的定义写在b.h和c.h中 ------ b.h ------ #ifndef X #define X struct x { ... }; #endif B ------ c.h ------ #ifndef M #define M ... #endif C 这样做其实耦合比外部头文件保护符还要高， 所以一般是不会采用的。 但C的标准头文件必须这样做。 因为C89有一个要求， 具体我不记得了。 要么是要求标准头文件不能包含其他标准头文件。 要么是要求标准头文件不能包含任何其他文件。 （C++和C99取消了这个要求） stdio.h是C89的标准头文件。 例如， 它需要定义一个size_t， 作为一些函数的参数类型。 而另外有一些标准头文件也会有size_t。 所以这些头文件中的size_t都是这样提供的： #ifndef _SIZE_T_DEFINED #define _SIZE_T_DEFINED typedef unsigned xxx size_t; #endif 或者也可能将若干定义分组， 共用一个保护符。 ","date":"2021-03-19","objectID":"/ifndef/:1:6","tags":null,"title":"关于C语言中的IFNDEF宏","uri":"/ifndef/"},{"categories":["English"],"content":"作者：若愚英塾 链接：https://www.zhihu.com/question/294752032/answer/2141847794 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2019-04-17","objectID":"/grammar/:0:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"主语谓语 我自己是主语，我做出的动作是谓语，我的动作碰到了某一个物体，它是宾语，我的动作让这个物体发生了什么样的运动状态变化叫宾补。 比如歌曲《Yesterday Once More》里有一句，It made me smile. 它使得我笑了起来。这句话就是这样的情况。（当然，这样的表述其实没能涵盖所有的宾补情况，这里为了让人便于理解就先采取了能涵盖大多数情况的表述形式，且看后面）。 宾补，就像补丁一样，裤子上的补丁是为了弥补裤子上的漏洞，衣服上的补丁是为了遮住衣服上的漏洞，软件的补丁就是为了补充软件在设计上的漏洞。同样地，宾补就肯定是宾语上的补丁，是为了弥补上宾语意思上的漏洞，也就是说宾补是为了为宾语补充一些信息，它补充的信息是为了更好地说明宾语。举个例子，如果你说I find English….那这句话就不完整，你发现了英语？英语是你发现的么？所以 我们一般说I find English easy. 这里的easy 就是一个补丁，它补充的是宾语English的意思上的不足，这也是宾补的一种形式。 ","date":"2019-04-17","objectID":"/grammar/:1:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"宾语 宾即客，我们经常说，客随主便，客总是接受和顺从主人的安排，总是处于一个被支配被限制的地位。 正因为如此，所以英语里把接受动作的东西叫宾语。客，永远是暗含着受牵制的意思，比如游客要遵守旅游地的规矩，乘客要听从交通工具运营方的安排，所以客不是一个会单独出现的概念，一谈到客，就必然会提到主。英语中宾语是OBJECT，它又有物体、对象、目标的意思，这是西方人的思维方式，OBJECT是被外力作用的物体，是一个动作作用的对象，是一个动作所要到达的目标物。但是中文就博大精神了，一个宾语就涵盖了所有。 ","date":"2019-04-17","objectID":"/grammar/:2:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"表语 我所表现出来的各种属性就是表语，比如我是什么样子，我是什么职业，我是在哪里，我看起来怎么样。这些是表现在其他人眼里的我的样子，所以只能称作是一种表象，所以我们把这样的成分叫做表语。而我和这个表象之间需要用一个东西联系起来，这个东西在英语里面叫做联系动词，有的时候也简称为系动词。 这里所说的属性有好几层意思： 第一，事物本身的属性，比如形状、大小、气味、年龄、动作状态等； 第二，事物的社会属性，比如身份、地位、职业等等； 第三，事物的时空维度属性，比如事物所处的位置，所对应的时间。 这里的所说的属性就没有我们通常所想的那么狭隘，相反非常宽泛。表语不是一个单独出现的概念，就如同舅舅和外甥，丈夫和妻子必然是同时存在的一对概念一样，不可能孤立地出现一个人就是舅舅，或者就是老公。 表语也不会单独出现，有表语那么必然就会有主语。因为表语表达的是主语的属性，主语和表语拿一根线连接起来，这根线就是联系动词。 汉语中你可以说我很好, 但是英语当中你就不可以直接说 I fine, 这两个单词中间需要用一个东西把它们联系起来，这就是我们所说的连系动词。联系动词就像一条纽带，把一个事物和它的属性联系起来。联系动词又像是一个渠道，把一个事物的属性散发出来。比如She sounds sweet. 她声音听起来很甜美，可能她看起来很粗犷。她很甜美这个属性是通过听觉的渠道传达出来的。 ","date":"2019-04-17","objectID":"/grammar/:3:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"状语 我一定是在特定的时间特定的地点特定的条件下因为特定的原因带着特定的目的以特定的方式做出的某个事情，这个事情造成了一定的结果，这些就都是状语。（有人说看不懂这句话，我在后面更新了点内容作为补充）也就是说，你做任何事情都有目的，做任何事情都是在某一时间做的，都是在某一地点做的，都是以某一种方式做的，都是在一定条件下做的，都是一定原因导致的，都会造成一定的结果，这些东西其实都是状语。 一言以蔽之，对于一个动作（事情）本身，你心中所泛起的所有疑问，都是状语。 比如，你说，走。那么，走到哪里，为啥走，怎么走，什么时候走，从哪走，和谁走，这些问题的答案都是状语。记住，是围绕动作本身所泛起的所有疑问。（等完全理解这一点以后，我可以再拓展状语的外延） 再比如，一个美女走到你面前，对你说“到我家来吧”。你脑海中一定会想，为啥到你家去？怎么去？什么时候去？她在什么条件下说出这样的话的？她让我到她家是什么目的？这些疑问的答案都是状语。 这个美女是如此热情地邀请你，以至于你一天上班心神不宁。 这个美女比电影明星网红还要好看十倍百倍。 最后你决定，无论今天有多少工作要做，你都要推掉一切去那个美女家中。 这里加黑体字的部分如果用英语表达出来依然是状语，具体是啥状语，你自己想想吧。 状语的门类很大，其中还有用句子来做状语，那么这个句子也就变成了所谓的状语从句。 那这里就来简单的说一说什么叫做状语从句。既然是简单说说，那么这就不是深入探讨，这里只是为了把本质的东西说明白。 什么叫做时间状语从句呢？时间状语从句，其实很简单，它就是用一个句子来表示一个特定的时间点。你可能觉得很奇怪，为什么他不直接说几点几分发生了什么样的事情，而非要用一个句子来表达一个时间点呢？那就是因为，并不是所有时候他都在看表的，并不是所有时刻都有条件来精确计量时间的。 比如如果我们要表达一个句子，我们想说，当你昨天给我打电话的时候，我正在看电视。When you rang me up yesterday, I was watching TV. 其实我并不知道你给我打电话的时候是几点几分，所以我只能用这样一个句子来表达那个时间点。那么这个表达时间点的句子，在英语当中就是时间状语从句。 同样的什么叫做地点状语从句呢？地点状语从句就是用一个句子来表达一个事件发生的地点。因为在日常生活中，不可能像专业的人士一样，随时随地记录这个地点的具体地址，或它的经纬度以及坐标。所以人们在说话的时候，经常会用一句话，来描述一个事情发生的地点，那么这样的一句话，实际上就是一个地点状语从句。 比如我们要表达这样一个意思，在我们昨天买衣服的地方，我又遇到了那个人。I came across that guy again where we bought our sportswear. 那么这里的“在我们昨天买衣服的地方”实际上就是一个地点状语从句，它只是为了描述一个地点。之所以把它叫做一个从句，是因为它只是一个从属的部分，而并不是说话的人想要表达的主要意思。 那么什么叫做原因状语从句呢？可以同样地来理解，任何事情发生都是有一个原因的。美国人总喜欢说一句话，God does make everything happen for a reason。当你用一句话，来表达一件事情发生的原因，那么这句话就只是一个原因状语从句而已。比如你想说这样的话，你们家的小宝贝不喜欢吃猪肉，因为他觉得那是佩奇的肉My little toddler doesn’t like pork, because he believes it’s Peppa’s meat. 那么这里的“因为他觉得那是佩奇的肉”实际上就是一个原因状语从句。这一部分并不是说话的人想要说的主要部分，而只是为了做一个铺垫，说明原因，所以它只是一个从属的部分，因为它表达了原因，所以是原因状语从句。 再举一个我经常会举的例子，你走进老板办公室，你对他说，因为我病了，所以我今天想请一天假。这里的这句“因为我病了”，并不是你想要表达的主要的意思，你想要表达的主要的意思，实际上是后半句，是你想请假，所以前面那半句，只能是原因状语从句。 我一定是在特定的时间特定的地点特定的条件下因为特定的原因带着特定的目的以特定的方式做出的某个事情，这个事情造成了一定的结果，这些就都是状语**。 你做任何事情肯定是在某一个时间去做的吧，你做任何事情也肯定是在某一个特定的地点做的吧，你不可能在一个不存在的时间和不存在的地点做了某一件事。所以时间和地点经常是用来描述某一个动作的，如果你单单说一个时间，单单提到一个地点，而这里没有任何事情发生，那么这个时间和地点就没有任何意义。 你做任何事情都是在一定的条件下去做的吧？比如你在考试之前，可能会跟你的父母提条件，你说如果我考到第一名，你就给我买个新的电话。这里你就是在和你的父母提条件，你的父母不可能平白无故就给你买个电话的，只有在你考到第一名的前提下才会给你买这个电话。 同样地，你做任何事情都有一定的目的。比如，你穿得十分帅气，从你的美女同学面前一遍一遍走过，你的目的就是为了引起她的注意。 你这一辈子做任何事情都是通过某一种方式去做的。比如，你上学你可以坐车去，可以骑车去。比如，你说话你可以高谈阔论，你可以细声细语，这些都是你说话的方式。 你做任何事情都会造成一定的结果，这里多多少少有了一点禅意。因为佛教认为，你的言语，行为，动念都会产生一定的结果，这些东西都叫做你的业，这些业终究会造成某一种结果，这叫做报。当然，我们不是在这里探讨宗教，我们就是探讨世界上任何的行为都会产生一定的结果。比如他们一心向佛，以至于终成正果。这样的例子好像不明显，那再来一个，他的声音很大，以至于墙角的蜘蛛网都在微微颤动。蜘蛛网微微颤动其实就是在修饰他的声音之大，也是其声音造成的一种结果，所以体现在英文句子当中，后句就只能是前句的结果状语。 所以，所谓的一件事情发生的时间地点原因条件目的结果等等皆可归入状语之中。我这里只是尽量通俗地去说明状语这个概念。但是英语里的状语概念实在太大，所以这里的说法也只涵盖了对于动词的修饰，而对于形容词和副词的修饰的状语，那就比较容易理解了。 ","date":"2019-04-17","objectID":"/grammar/:4:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"定语 把一个东西的某些属性确定下来的成份就叫定语，说白了就是把一个东西是什么样子限定出来的那些语言就叫做定语。 **我在生活中如果不用定语的话，这会给我带来很多麻烦，**我去买衣服，我如果仅仅告诉导购“我要买衣服”，然后就缄口不语，我估计导购可能会骂娘。因为衣服这个概念太宽泛了，其实帽子鞋子袜子文胸裤腰带也都是衣服的范畴，你直接来一句要买衣服，而不说买什么样的衣服，这就是找打的节奏啊。 你一定要说你是要买什么样子的衣服，比如红色的衣服，比如裘皮的衣服，上身穿的衣服，外面穿的衣服，里面穿的衣服，这些把某个东西限定下来的成分就叫定语。否则你光说你要衣服，那么对方就无法确定，也正是因此，所以顾名思义定语在中文中被翻译成定语。英语中定语叫做attribute modifier，attribute 是属性的意思，modifier是修饰语的意思。是不是这样就很容易理解定语为啥叫定语了？ ","date":"2019-04-17","objectID":"/grammar/:5:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"同位语 当孙悟空说出那句：俺老孙乃五百年前大闹天宫的齐天大圣。你要知道，这句话里面“老孙”就是指“俺”，“俺”就是指“老孙”。在英语里面，这样位置一样成分一样的两个东西，后面的叫做前面的同位语。虽然前后成分所指的东西都是一样的，但是在研究英语的过程中，我们只说后面的是前面的同位语，而不说前面的是后面的同位语。 单纯的同位语都好理解，比如我们中国人是一个不畏强暴的民族。这句话翻译成英文的话，“中国人”就是“我们”的同位语。 但是英语中有一种用一个句子来做同位语的，那就叫同位语从句了，同位语从句就是先说一个词，然后用一个句子来解释这个词，记住哦，我说的是用一个句子来解释这个词，这个句子的意义必须等于前面这个词。 化学中有个概念叫做同位素，英语中有个东西叫做同位语。同位素是指在元素周期表当中占据相同位置的物质，质子数相同中子数不一样，但是他们属于同一种元素。同样，同位语也指的是在句子中占据位置相同，担任成分相同的东西。唯一不同的是，同位素可以互称同位素，比如氕（¹H）、氘（²H）、氚（³H）可以互称同位素，而英语中的同位语一般是说后面成分担任前面成分的同位语。 ","date":"2019-04-17","objectID":"/grammar/:6:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"虚拟语气 虚拟语气就是某一种情感的抒发，要么后悔过去做了某事，要么庆幸过去没做某事；要么期望现在拥有某物，要么希望现在做成某事；要么期望将来永远不要发生某事，要么幻想将来能有某事发生。但无论如何，他们都知道这些事情发生的几率很小，或者根本不希望这些事发生。 早知如此绊人心，何如当初莫相识。这是后悔，与过去相反，早知道感情如此牵绊，又何苦坠入这温柔乡里？但是一切已经发生了。 如果不曾遇见你，我将会是在哪里？这是庆幸，也是与过去相反。如果今生不曾相遇，有需要经过几世轮回才能积攒到遇见的缘分？ 假如你不曾保护我，我的命运将会是什么？这是庆幸，与过去相反，说话的人一定是被保护得很好。 如果大海能够唤回曾经的爱，就让我用一生等待。这是与现在事实相反，大海是换唤不回你的爱的。 好吧下辈子，如果我还记得你，你的誓言可别忘记。这是与将来相反，希望即便是走过奈何桥，喝过孟婆汤，依然可以彼此记得前生的缘分，依然在茫茫人海当中可以再次遇见，而说话的人自己也知道，这样的几率太小。 他年我若为青帝，报与桃花一处开。这是对将来的美好憧憬，当时黄巢意气风发，畅想着有一天可以坐拥江山，但是无论如何他也成不了青帝之神。所以这也只能是对将来的美好憧憬而已。 山无陵，江水为竭，冬雷震震，夏雨雪，天地合，乃敢与君绝。对未来的虚拟，这是表达对未来的憧憬，无论如何也不愿分离，因为她列举的这些情况基本不可能发生，至少在他们的年代是认为不可能发生的，这里就不要谈什么地质运动了。 若非一番寒彻骨，哪得梅花扑鼻香？ 这是与过去事实相反，正是因为经历了彻骨之寒，才修炼成香气四溢的梅花。 当陈胜，辍耕之垄上说出：苟富贵“无相忘“的时候，他一定用的不是虚拟语气，因为他相信自己一定能做成大事，而一边听这句话的人，绝对是按照虚拟语气来理解的，因为他说”若为佣耕，何富贵也？“。所以一句话是不是虚拟语气也要看谁说出来，如果比尔盖茨说，如果我现在有一个亿的话，……和一个普通人说出来这句话，感觉就是不一样，比尔盖茨说这句话，那就不是虚拟语气，而你说这句话，很大程度上就是虚拟语气。 在日常生活中还有一种情况总是需要用虚拟语气的，比如在合同中约定，如果甲方未能履约，…… 这种情况是我们不希望未来会发生的，所以我们要用与未来相反的虚拟语气。If Party A should not fulfill the conditions，…。很多时候在合同文本当中会采取一种省略形式，Should Party A not fulfill the conditions,…，还是要适应这种虚拟语气的。 ","date":"2019-04-17","objectID":"/grammar/:7:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"主从关系 主句和从句之间的关系就像主人和随从一样。 主人往往可以做重要的决定，而随从只是辅助主人。同样的，主句往往是表达说话的人想要表达的主要意思，而从句所表达的含义就不是说话人所要表达的主要意思。不信的话，这里来举一个简单的例子，比如你和你的老板说， Because I feel sick， I want to ask for a leave.那么你觉得哪半句是说话的人想表达的主要意思呢？你是只想告诉你的老板你病了，还是真正想说你要请假？这里的答案是显而易见的，如果你只是告诉你的老板你病了，那么你的老板很大概率会跟你说，注意身体，回去工作吧。 再打一个不太合适的比喻，主句就像电脑，而从句则是像鼠标、优盘、音箱、耳机等外设，你使用电脑一定是主要为了使用电脑，绝对不是为了使用你的鼠标，而去再配一个电脑。电脑绝对是主体，其他的都是附属，所以都是外设。 ","date":"2019-04-17","objectID":"/grammar/:8:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"冠词 冠就是帽子，冠词就是像帽子一样的词，戴在名词的前面。 定冠词就是能确定那个戴帽子的名词的身份的冠词，比如一个厨师戴着帽子，一个警察戴着帽子，你都能认出他们的职业；而如果随便带一个棒球帽，你是认不出他的职业的，所以当你不确定是哪一个东西的时候就要用不定冠词，而你知道你想说的是哪一个东西的话，就用定冠词。所以最高级前面一般加the，因为最怎么样的是一眼就能看出来的，大家都能知道的 所以用定冠词了。 序数词为啥要加定冠词？举个例子，某一次考试之后，你们班第一名第二名一直到最后一名是不是都确定了？所以呀，每次考完只有一个第一名，也只有一个第二名，在不考虑并列的特殊情况下，所有的名次的归属都是确定的，所以序数词前面要加定冠词。 最高级为啥要加定冠词？举个例子，如果我问你们班最高的人叫啥名字，你一定会直接说出来名字，因为个子最高的那个人肯定是确定的，不可能一个班里的人的身高还随着气温的变化而热胀冷缩。 为啥比较级就不能加定冠词，如果我问你班上比较高的是谁，你可能一下说出一大堆，这些名字是完全不确定的，因为啥叫比较高就很难界定，所以比较级前面一般不用定冠词。 ","date":"2019-04-17","objectID":"/grammar/:9:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"情态动词 表示一个人主观意愿状态的动词，之所以叫做情态，是因为说的是感性和主观。 所以 任何情态动词其实都暗含着“我觉得”的意思。如果你对你妈说，I must have a new phone or I will die. 你妈是绝对不会搭理你的，因为没新手机绝对不会死的，只是你自己觉得不拿到新手机心里会很不爽。但是你如果说I have to breathe, otherwise I will die. 那么这就是说 你必须呼吸，否则就会死，这是就不是主观意愿了，这是客观要求。 ","date":"2019-04-17","objectID":"/grammar/:10:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"复合句 复合维生素就是一个药片里含有了好几种维生素，那么复合句就是一个句子里含有了好几个完整的句子。 ","date":"2019-04-17","objectID":"/grammar/:11:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"音节 音节就是声音分成一节一节的，节就是相对独立的发音的单位。很多东西都是一节一节的，比如竹子，一节一节的；再比如时间也是可以分为一节一节的，一年分为了24节，就是24个节气；上课也是一节一节的，火车也是一节一节的，包括我们人体也是一个个关节组成的。 汉语都是单音节词（除了个别硬造出“瓩”“兙”这样的字以外），英语的音节和汉语的音节不同在于它有辅音构成的音节尾（coda），比如dog这个词中有g这个音作为音节尾，而这在汉语普通话里是不存在的，音节开始的部分也会有辅音从（st，tr等），也就是两个辅音形成的音节头，这在汉语中是不存在的，汉语中的音节头都是单纯的辅音，所以在英语当中dog 这是一个音节，因为g只是一个音节尾，它是一个辅音，非常短促，并不构成完整的发音单位。而English这个词，也只有两个音节，Eng——lish，第一个音节中的g 和第二个音节中的sh都是音节尾，它们并不构成完整的发音单位。值得一提的是，很多中国的学习者，通常会把音节尾巴延长成另一个音节，比如dog 读成了 类似道哥的音，其实就相当于在音节尾后面又悄悄加了一个元音。 ","date":"2019-04-17","objectID":"/grammar/:12:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"元音 就是最简单最基本最省力就能发出来的声音，只需要用嗓子就能发出的声音，而不需要动用嘴唇舌头牙齿等等。 你看一些词语，元素、元帅、元凶、单元，只要带“元”字的单词都是为了表示最基本最简单最重要的意思。辅音顾名思义就是起辅助作用的音，只是为辅佐元音的，所以辅音都很短暂，你听到的语言的大部分响亮的声音其实都是元音。 ","date":"2019-04-17","objectID":"/grammar/:13:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"副词 正如有县长就有副县长，有村长就有副村长，所有副职的人都是为正职人当帮手的，副词也是为了一个比它更重要的词当帮手。 之所以把它叫做副词，因为它永远也改变不了千年老二的地位，它永远只能补充信息，而不能表达主要信息。就像任何组织当中的老二一样，永远只能干一些琐碎的活，做一些辅助的工作，重要的决定还是需要老大去做。就像领导和司机的关系，司机永远不能代替领导去开会，更别说在会上发言了。在句子当中也是一样的，副词作为副词永远也无法表达重要的意义，它永远也无法替代它为之服务的那个词，比如说He runs fast.这句话里fast就是副词，我们可以说它是run的副词。如果我们说He runs，那么还是可以表达一个比较清晰的意思，但是如果我们把run去掉，说He fast.那么我们就不知道他到底是什么快，fast 永远也不能代替run,它只能为这个词服务。所以副词在这句话里它的地位就是比不上run，所以它只能是副词，是一个相对不重要的地位。副词也有它的业务范围，它的业务范围就是为动词、形容词以及副词提供服务，是的你没看错，副词还可以修饰副词。比如我们可以说He runs very fast.这里的very就是一个副词，而它是修饰fast的，这就是所谓的副词为副词服务，或者说副词修饰副词。 一提到副词，好像就应该存在一个东西叫做“主词”的，其实英语当中还真的存在主词这样的说法，但是主词并不是对应于副词而言的，而是主语的另外一种叫法。但是我们这里为了更好地理解副词，我们可以假设另外一个与副词相对应的东西叫做主词。而这个主词永远要比副词更重要，之所以说它比副词更重要，是因为它在表达意义上，比副词传达更重要的信息。比如 She is very attractive. 这里面attractive 就是要比very更重要，你可以去掉very，句子变成She is attractive. 依然是表意完整的，但是如果去掉attractive，She is very. 这个句子就是个残缺不全的。所以very只能是个副词而已。 ","date":"2019-04-17","objectID":"/grammar/:14:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"介词 介就是指中介，就像结婚的介绍人一样，有介绍人才能将两人撮合到一起。所以介词就是把两个东西的关系确定下来的词。比如桌子上有本书，桌子和书需要用一个on来确定两者关系。 不定式的英文是infinitive ，维基百科说这个词源于拉丁词汇：The word is derived fromLate Latin[modus] infinitivus, a derivative ofinfinitusmeaning “unlimited”.也就是说“不限定，无限制”的意思，那么有infinitive 就会有finite，有不定式好像就应该有一个叫做“定式”的东西，虽然这叫法在英语里不存在。但是为了便于理解，作为对比我们暂且这样叫着。啥叫动词的“定式”呢？这样解释下吧，动词的“定式”就是主语直接发出那个动作，或者说是句子的谓语，那个动词把句子的时态人称单复数都确定下来了，我们就因此把它暂时叫做动词的定式吧。动词的“定式”定的是句子的时态人称单复数等主要信息，所以不定式于此相反，体现不出任何时态人称单复数，故称之为不定式。 ","date":"2019-04-17","objectID":"/grammar/:15:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"形容词 形，原来指人的体形和身材，容，原来指人的容貌，形容这个词原来是指人的身材和长相。屈原就写道：“颜色憔悴；形容枯槁”，这里的形容就是指人的身形和面容，当然，这里颜色指的也是脸的色泽，颜指的是脸，色才是颜色。 现在在语言学当中，形容词就是指一切用来说事物的属性的词了，好像世界上的任何一个事物都像人一样有了容貌和身形一样，这万事万物的容貌和身形其实就是它们各自的属性。 ","date":"2019-04-17","objectID":"/grammar/:16:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"时态 就是用看得见的动作或者状态，来体现看不见的时间。任何事情的发生都伴随着时间的流逝，只不过你看不见而已。 时间你是看不见的，这一点很容易理解。你衰老时你也感觉不到时间在你的额头刻下皱纹，你患病时你也看不见时间在吞噬你的健康。也许你会觉得你是一个被时间遗忘的人，一天闲的蛋疼，但是无论你做什么事情依然是在你的生命里扣除不再回回来的些许瞬间。 时态是由看不见的时间和看得见的动作状态组成的。或者说它是把一个动作拆成了时间和动作状态两部分。因为任何一个动作实际上都伴随着一定的时间，而任何一个时间点实际都伴随着一个动作状态，抛开动作谈时间就是空谈。 时间概念分为过去，现在，将来，而这三者加在一起就成了永远。至于永远有多远，没有谁知道。 动作状态分为正在进行，已经完成，规律性发生三种。 下面从生活体验的角度说下时态。 动作状态和时间相互组合就成了英语中的各种时态。比如正在进行的动作，放在过去就叫做过去进行时，放在现在就叫做现在进行时放在将来就叫做将来进行时。 从通俗的角度讲，时态就是每个人的生活状态，也是每个人的情感状态。人的一生会经历很多事情，有的事情过去了就过去了，没有任何留恋，你渐渐地会淡忘。只是在很久以后，和人谈起。你可能会告诉别人你在青春年华所做的那些事情，只是提起而已，这些事情和你现在几乎没有什么关联，而这些事情一般就可以使用一般过去式。 去年今日此门中，人面桃花相映红，这是过去；想当年，金戈铁马，气吞万里如虎，这是过去；遥想公瑾当年，小乔初嫁了，雄姿英发。 羽扇纶巾，谈笑间，樯橹灰飞烟灭，这是过去；晋太元中，武陵人捕鱼为业，这是过去；庆历四年春，滕子京谪守巴陵郡，这是过去；窗外疏梅筛月影，依稀掩映，吾与汝并肩携手，低低切切，何事不语，何情不诉！这还是过去。无论是哪一种心境，都已湮没于岁月的长流之中。如古人云：濯足长流，抽足再入，已非前水。 当过去的一切和现在毫无瓜葛的时候，那就是一般过去时。 过去事情就过去了，往者不可谏，来者犹可追。每一个人都应该是立足现在而期待将来的，过去的事情可作为镜鉴，但不能让过去的事情久久萦绕心间，不能为了一杯洒掉的牛奶，哭出一盆的眼泪。当你可以超然地回望着过去的时候，当过去和现在不再牵绊的时候，**你基本上用的就是一般过去时。**因为当你说起这些事情的时候，就好像在说起另一个毫不相干的人，发生在那个人身上的事情已经无法拨动你的今日的心弦。你令人心碎的初恋，当初花前月下成双入对，而最后天各一方，这都已经是过去，你现在过得开心，回头看的时候，你心中用的是一般过去时。 漫步在人生的数轴之上，蓦然回首，透过岁月的风尘，一般过去时是一个遥远的孤岛，你可以超然地看那时发生的一切，因为现在的你已经不是那时的你。那时的一切已经不能影响到现在的你。过去的痛苦是快乐，虽然当时有百般不堪万般无奈，现在你心中却有一种俱往矣的超然，这就叫做一般过去时。一般过去时之所以叫一般过去时是因为已经过去了，而现在完成时之所以叫现在完成时是因为还藕断丝连。现在完成时说是“完成”，其实并未“完成”。为什么这样说呢？现在完成时虽然说的是到此时此刻为止发生的事情，但是很多时候到此时此刻为止的事情并不会戛然而止。比如，在此时此刻，你和某个相恋数年的女孩已分手，你能否真正慧剑斩情丝，抛却过往走向新生呢？如果你依然心存留恋，那么这里现在完成时就出现了，I have broken up with her. 你嘴上说分手了，但心里还在回味一起度过的美好瞬间，这就是现在完成时所说的“此刻之前的动作对此刻以后的影响”。 完成时的宿命就是永远是有言外之意，也就是说永远话里有话。虽然叫做“完成时”，其实并没有“完成”。 当你说一句现在完成时的句子的时候，其实你肯定是后面还有话要说的。比如你说，I have worked so long.你下一句肯定是想说，我已经太累了。比如你说，He has waited for her for ten years.你下一句肯定想说“人生能有几个十年啊”之类的话。当你说I haven’t finished my homework. 你后面一定会说“现在我没时间和你唠嗑”之类的话。所以这就叫做完成时永远是有言外之意。 而人生又充满了情感的起起伏伏，有时候你会回想起过去的一些事情。无数个现在终究会变成曾经，而无数的过往构成了此时此刻的开始。佛教说：欲知前生事，今生受者是。你现在所遭遇的一切都是从前做的事情的结果，你此刻的遭遇，此刻的获得，此刻的失去，此刻的感受，都是之前某一些事情的结果。所以现在完成时就是这么产生的，这是一种有着言外之意的时态。 革命尚未成功，同志仍需努力，是现在完成时； 自李唐来，世人甚爱牡丹。是现在完成时； 后值倾覆，受任于败军之际，奉命于危难之间：尔来二十有一年矣。也是现在完成。 靖康耻，犹未雪。臣子恨，何时灭。是现在完成时。 商女不知亡国恨， 隔江犹唱《后庭花》。是现在完成时。 这几句话都暗暗包含着到现在为止的意思，革命到现在还没成功，自唐朝到现在人们都喜欢牡丹，自从孔明随刘备出山直到现在已经21年了。靖康之耻，尚未消除。歌女不知道什么是亡国之恨，还在唱着前朝亡国之曲。 现在完成时的时间截止点是到现在为止，而每一句现在完成时的句子都是有着自己的潜台词，比如当我说：“我已经喝了八瓶了”，我的意思可能是我不想再喝了；当我说“我还没准备好”，我的意思可能是我还需要一点时间；当我说：“我已经等了三小时了”，我的意思可能是我快没耐心了。所以现在完成时都是有着言外之意的，而这种言外之意又来自从过去某一时刻到现在为止发生的事情。听明白我的话，不要机械理解，现在完成时的时间区间是从过去某一时刻到现在为止，但是现在完成时所涉及的动作未必是到现在为止，它可能是到现在为止，也可能是现在之前就已经发生完了。 当现状不如人意的时候，人们就会怀念过往。你可能会对自己说，我曾经经历过那么多闪亮的日子。I have ever experienced so many shining days. 你说这个话的时候，你的意思不止于此。你想表达对过去的美好日子回忆，其实也想表达对未来的期许。也可能想说而现在却这么落寞。无论是哪一种含义，这样一个现在完成时的句子说出来的时候，它其实就已经暗示了一定程度的接下来要说的话。所以这里使用了现在完成时，表示到现在为止，你曾经经历过那些光辉的日子，那些美好的事情发生在过去的某一个时刻和此时此刻这个区间之内。一定要记住，现在完成时覆盖的时间是一个区间，而这个区间的截止点是现在，是此时此刻。但是，现在完成时所指的动作的影响已经远远超出了这个时间区间。比如我说：I have been away from home for ten years，我已经离家十年。其实我想说的绝对不只是离家十年这件事本身，而是想说很想家，所以这里现在完成时的含义已经超出了时间区间本身。 生活并不总是平淡如水的，有时你会表达一些强烈的情感。你和别人发生一些争执，你可能会说，我从来就没有见过这个人。I have never met this guy.你想说的是，到现在为止，你都没有见过这个人。言外之意是说，更不可能和这个人有什么交集。现在完成时侧重于一种累积性，其中累积性是到现在为止，或者说是默认到现在为止。什么叫做默认？就要上面那一句话，我从来没有见过这个人。言外之意肯定是说我到现在为止从来没有见过这个人。现在完成时里面通常包含的言外之意，还有一定的情绪。你在公司里连续加班了三天，第四天老板要派你出差。那你可能会说，我都加了三天班了，还没有休息呢。I have worked overtime for three days and haven’t had rest yet.当你说我已经加了三天班了，这里面就已经含有了言外之意，你要表达的意思是说，加了三天班是会产生一定的后果的，这种后果就是很累。所以现在完成时的句子表达的意思当中暗含着对现在或者对现在以后的某一种影响。所以呢，现在完全是一种暗含的情绪和言外之意的时态。而是时态本身就是一种生活状态，一种情感状态，所以能有这样的效果也就不足为奇了。 也可以用一个感性的句子来说一下过去时和完成时，过去时是超然事外，完成时是心有余念。当你用过去时的时候，你已经从过去走出来。当你用完成时的时候，你还有所牵挂。完成时是到某一时刻为止但是后续影响并未结束，过去时是到某一时刻为止就为止了。 再多说几句吧，其实我们这里所探讨的都是中规中矩的语法。而实际当中，懒惰的美国人就很喜欢直接用过去时来表示需要用现在完成时的情况。 每一个人都活在现在，每个人都最关注此时此刻的感受。而此时此刻，你可能在做一件事，也可能在想一件事，也可能在说一件事。而处于正在进行的一件事当中的状态，其实就是现在进行式。所以呢，此时此刻你正在做的事情就叫现在进行时。 当然英语中的现在进行时远远没有这么狭隘，现在进行时还可以用来表示将来的事情，在学校学的是只有一些非延续性动词的现在进行时才可以表示将来，其实那样的理解基本上可以说是错误的，英语当中只要是已经安排好的计划好的事情几乎都可以用现在进行时来表示。比如We’re meeting Susan at 3 o’clock tomorrow afternoon. 同样我也在另一篇文章中引用比较权威的材料论证了这个问题，有空也可以去看看。 在这里问这个问题的人，有很多都是学生，所以我这里就从学生的角度来简单的说明一下什么叫做各种时态。假设你是一个学生，你每天早上6点钟都要起床，每天都要去上学，每天都要学习，每天都要写作业，从来不打游戏，或者你有时候打一会儿游戏，或者你天天藏被窝里打游戏，或者每周打一次游戏。这些情况都","date":"2019-04-17","objectID":"/grammar/:17:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"},{"categories":["English"],"content":"情景示例 下面通过一些情景来说明时态： 1.汤姆喜欢美女，这一定是一般现在时，因为他一直就喜欢美女，不论过去现在还是将来，终其一生都坚持着这样的对美的追求，所以这个一定是一般现在时。 Tom likes hotties. 2.他正在抖音上看美女，那一定是现在进行时： Tom is watching hotties on Tiktok. 3.如果说，在没有抖音之前，汤姆喜欢看《花花公子》杂志，这一定是一般过去时，因为抖音产生也才是近十年的事情，在那之前，喜欢看美女的人都各自想办法呗： Tom liked reading PLAYBOY before Tiktok came out. 4.你约汤姆今天去图书馆，他一定会打瞌睡的，因为昨晚看了一晚上抖音，所以他去图书馆也只不过是换个地方睡觉而已，这就是一般将来时： Tom will definitely sleep in the library. 5.你昨天打电话他没接电话，那时他在刷抖音。这叫做过去进行时。 He was browsing Tiktok when you called him. 6.他说明天要去看沙滩排球，相信我，你偷偷跟着去，他一定会在看美女而不是记分牌。这叫做将来进行时，说明将来某一个时刻正在发生的事情： He will be surely staring at the hotties but not the scoreboard. 7.他已经向那个美女表白十次了。这肯定是现在完成时，因为是到现在为止表白了十次。这也符合正常人的思维，一般人说已经怎样怎样都是默认的到现在为止，而不是到将来或者说到过去某一个时刻为止。 He has expressed his feelings for her ten times. 8.自从人家拒绝他送的花之后，他就一直站在那个女的门前。这就是现在完成进行时，自从人家拒绝他，一直到现在，他都一直站在人家门口，一直站到现在。 He has been standing in front of the girl’s home since she refused his flowers. 9.到去年年底之前，这样的事情他都干过不下一百次了。在过去某一个时间点之前已经做的事情，并且还和那个时间点之后有一定的联系，这就肯定是过去完成时。 He had done this no less than a hundred times by the end of last year. 10.在你看到他之前，他就一直在那个女孩家周围闲逛。这个肯定是过去完成进行时，因为你看到他肯定是过去的事情，在过去某一时刻之前，一直发生到那个时刻的事情，当然是过去完成进行时： He had been wandering around the girl’s home before you saw him. 11.在上次聚会上，他说他将追求这个女孩。这就是过去将来时： At last party, he said he would chase the girl. 12. 女孩告诉他，如果他能再等六十年就嫁给他。他当时说，六十年后我将已经死去。这句话就是过去将来完成时。不论是谁，估计等个六十年也就挂了。这里的关键在于，那句话是过去说的，说的是当时他认为将来某一个时候已经发生了的事情。 He said at the time that he would have died after sixty years. 13.他说，那个时候，他将正在静静躺在墓穴里。这就是过去将来进行时，是从过去某一时刻说将来某一时刻将正在发生的事 He said that at that time, he would be lying quietly in the tomb. ","date":"2019-04-17","objectID":"/grammar/:18:0","tags":null,"title":"英语语法浅析","uri":"/grammar/"}]