<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <meta name="referrer" content="no-referrer">
        <title>Linux下的多线程 - Weiyee&#39;s Blog</title><meta name="Description" content="记录个人学习的博客"><meta property="og:title" content="Linux下的多线程" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/linux_multi_threads/" /><meta property="og:image" content="https://example.com/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-12T16:18:55+08:00" />
<meta property="article:modified_time" content="2021-04-12T16:18:55+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com/logo.png"/>

<meta name="twitter:title" content="Linux下的多线程"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://example.com/linux_multi_threads/" /><link rel="prev" href="https://example.com/ipc/" /><link rel="next" href="https://example.com/cmake_tutorial/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Linux下的多线程",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/linux_multi_threads\/"
        },"image": ["https:\/\/example.com\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "Unix, MultiThreads","wordcount":  8355 ,
        "url": "https:\/\/example.com\/linux_multi_threads\/","datePublished": "2021-04-12T16:18:55+08:00","dateModified": "2021-04-12T16:18:55+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/example.com\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Weiyee"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Weiyee&#39;s Blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Weiyee&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 📔 所有文章 </a><a class="menu-item" href="/tags/"> 🏷️ 标签 </a><a class="menu-item" href="/categories/"> 🗂️ 分类 </a><a class="menu-item" href="/mypage/"> 👨‍💻 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Weiyee&#39;s Blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Weiyee&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">📔 所有文章</a><a class="menu-item" href="/tags/" title="">🏷️ 标签</a><a class="menu-item" href="/categories/" title="">🗂️ 分类</a><a class="menu-item" href="/mypage/" title="">👨‍💻 关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Linux下的多线程</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Weiyee</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/operating-system/"><i class="far fa-folder fa-fw"></i>Operating System</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-04-12">2021-04-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8355 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp"
        data-srcset="https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp, https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp 1.5x, https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp 2x"
        data-sizes="auto"
        alt="https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp"
        title="https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp" /></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#线程概述">线程概述</a>
      <ul>
        <li><a href="#进程与线程之间的区别">进程与线程之间的区别</a></li>
      </ul>
    </li>
    <li><a href="#线程基本操作">线程基本操作</a>
      <ul>
        <li><a href="#线程创建create">线程创建（create）</a></li>
        <li><a href="#线程终止exit">线程终止（exit）</a></li>
        <li><a href="#线程汇合join">线程汇合（join）</a></li>
        <li><a href="#线程分离detach">线程分离（detach）</a></li>
        <li><a href="#线程取消cancel">线程取消（cancel）</a></li>
        <li><a href="#线程属性attr">线程属性（attr）</a></li>
      </ul>
    </li>
    <li><a href="#线程同步synchronization">线程同步（synchronization）</a>
      <ul>
        <li><a href="#互斥量锁">互斥量（锁）</a>
          <ul>
            <li><a href="#互斥量基本原理">互斥量基本原理</a></li>
            <li><a href="#互斥量示例">互斥量示例</a></li>
          </ul>
        </li>
        <li><a href="#死锁">死锁</a>
          <ul>
            <li><a href="#死锁的几种场景">死锁的几种场景</a></li>
            <li><a href="#死锁产生的四个必要条件">死锁产生的四个必要条件</a></li>
            <li><a href="#死锁处理方法">死锁处理方法</a></li>
            <li><a href="#死锁示例">死锁示例</a></li>
          </ul>
        </li>
        <li><a href="#读写锁">读写锁</a></li>
        <li><a href="#条件变量">条件变量</a></li>
        <li><a href="#信号量">信号量</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="线程概述">线程概述</h2>
<p>与进程（<code>process</code>）类似，线程（<code>thread</code>）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p>
<p>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</p>
<p>线程是轻量级的进程（<code>LWP：Light Weight Process</code>），在 Linux 环境下线程的本质仍是进程。</p>
<p>查看指定进程的 LWP 号：<code>ps –Lf pi</code></p>
<p>◼ 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone()  系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的 一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。</p>
<p>◼ 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始 
来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 <strong>NPTL</strong>。</p>
<p>◼ NPTL，或称为 <strong>Native POSIX Thread Library</strong>，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。</p>
<p>◼ 查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
<h3 id="进程与线程之间的区别">进程与线程之间的区别</h3>
<p>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用
一些进程间通信方式，在进程间进行信息交换。</p>
<p>调用<code>fork()</code>来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 <code>fork()</code> 调用在时间上的开销依然不菲。</p>
<p>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</p>
<p>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</p>
<img src="https://i0.hdslb.com/bfs/album/9c205712fa159a31956020d9892976988a945541.png" title="" alt="" data-align="center">
<h2 id="线程基本操作">线程基本操作</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> 
<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="n">pthread_t</span> <span class="nf">pthread_self</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_equal</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">t1</span><span class="p">,</span> <span class="n">pthread_t</span> <span class="n">t2</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">retval</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_detach</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程创建create">线程创建（create）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程
</span><span class="cm">    称之为子线程。
</span><span class="cm">    程序中默认只有一个进程，fork()函数调用，2进行
</span><span class="cm">    程序中默认只有一个线程，pthread_create()函数调用，2个线程。
</span><span class="cm">
</span><span class="cm">    #include &lt;pthread.h&gt;
</span><span class="cm">    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
</span><span class="cm">    void *(*start_routine) (void *), void *arg);
</span><span class="cm">
</span><span class="cm">        - 功能：创建一个子线程
</span><span class="cm">        - 参数：
</span><span class="cm">            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。
</span><span class="cm">            - attr : 设置线程的属性，一般使用默认值，NULL
</span><span class="cm">            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码
</span><span class="cm">            - arg : 给第三个参数使用，传参
</span><span class="cm">        - 返回值：
</span><span class="cm">            成功：0
</span><span class="cm">            失败：返回错误号。这个错误号和之前errno不太一样。
</span><span class="cm">            获取错误号的信息：  char * strerror(int errnum);
</span><span class="cm">
</span><span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child thread...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;arg value: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// 创建一个子线程
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span> 
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// exit(0);
</span><span class="c1"></span><span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h3 id="线程终止exit">线程终止（exit）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">
</span><span class="cm">    #include &lt;pthread.h&gt;
</span><span class="cm">    void pthread_exit(void *retval);
</span><span class="cm">        功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程
</span><span class="cm">        参数：
</span><span class="cm">            retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。
</span><span class="cm">
</span><span class="cm">    pthread_t pthread_self(void);
</span><span class="cm">        功能：获取当前的线程的线程ID
</span><span class="cm">
</span><span class="cm">    int pthread_equal(pthread_t t1, pthread_t t2);
</span><span class="cm">        功能：比较两个线程ID是否相等
</span><span class="cm">        不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的
</span><span class="cm">        是使用结构体去实现的。
</span><span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">// pthread_exit(NULL);
</span><span class="c1"></span><span class="p">}</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 创建一个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 主线程
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;tid : %ld, main thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tid</span> <span class="p">,</span><span class="n">pthread_self</span><span class="p">());</span>
    <span class="c1">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。
</span><span class="c1"></span>    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main thread exit</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// exit(0);
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程汇合join">线程汇合（join）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    #include &lt;pthread.h&gt;
</span><span class="cm">    int pthread_join(pthread_t thread, void **retval);
</span><span class="cm">        - 功能：和一个已经终止的线程进行连接
</span><span class="cm">                回收子线程的资源
</span><span class="cm">                这个函数是阻塞函数，调用一次只能回收一个子线程
</span><span class="cm">                一般在主线程中使用
</span><span class="cm">        - 参数：
</span><span class="cm">            - thread：需要回收的子线程的ID
</span><span class="cm">            - retval: 接收子线程退出时的返回值
</span><span class="cm">        - 返回值：
</span><span class="cm">            0 : 成功
</span><span class="cm">            非0 : 失败，返回的错误号
</span><span class="cm">*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="c1">// sleep(3);
</span><span class="c1"></span>    <span class="c1">// return NULL; 
</span><span class="c1"></span>    <span class="c1">// int value = 10; // 局部变量
</span><span class="c1"></span>    <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>   <span class="c1">// return (void *)&amp;value;
</span><span class="c1"></span><span class="p">}</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// 创建一个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 主线程
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;tid : %ld, main thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tid</span> <span class="p">,</span><span class="n">pthread_self</span><span class="p">());</span>

    <span class="c1">// 主线程调用pthread_join()回收子线程的资源
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span> <span class="n">thread_retval</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">thread_retval</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;exit data : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">thread_retval</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;回收子线程资源成功！</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="c1">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。
</span><span class="c1"></span>    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程分离detach">线程分离（detach）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    #include &lt;pthread.h&gt;
</span><span class="cm">    int pthread_detach(pthread_t thread);
</span><span class="cm">        - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。
</span><span class="cm">          1.不能多次分离，会产生不可预料的行为。
</span><span class="cm">          2.不能去连接一个已经分离的线程，会报错。
</span><span class="cm">        - 参数：需要分离的线程的ID
</span><span class="cm">        - 返回值：
</span><span class="cm">            成功：0
</span><span class="cm">            失败：返回错误号
</span><span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;chid thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// 创建一个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error1 : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 输出主线程和子线程的id
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;tid : %ld, main thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

    <span class="c1">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放
</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_detach</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error2 : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 设置分离后，对分离的子线程进行连接 pthread_join()
</span><span class="c1"></span>    <span class="c1">// ret = pthread_join(tid, NULL);
</span><span class="c1"></span>    <span class="c1">// if(ret != 0) {
</span><span class="c1"></span>    <span class="c1">//     char * errstr = strerror(ret);
</span><span class="c1"></span>    <span class="c1">//     printf(&#34;error3 : %s\n&#34;, errstr);
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程取消cancel">线程取消（cancel）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    #include &lt;pthread.h&gt;
</span><span class="cm">    int pthread_cancel(pthread_t thread);
</span><span class="cm">        - 功能：取消线程（让线程终止）
</span><span class="cm">            取消某个线程，可以终止某个线程的运行，
</span><span class="cm">            但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。
</span><span class="cm">            取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。
</span><span class="cm">*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;chid thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// 创建一个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error1 : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 取消线程
</span><span class="c1"></span>    <span class="n">pthread_cancel</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 输出主线程和子线程的id
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;tid : %ld, main thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>


    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程属性attr">线程属性（attr）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    int pthread_attr_init(pthread_attr_t *attr);
</span><span class="cm">        - 初始化线程属性变量
</span><span class="cm">
</span><span class="cm">    int pthread_attr_destroy(pthread_attr_t *attr);
</span><span class="cm">        - 释放线程属性的资源
</span><span class="cm">
</span><span class="cm">    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
</span><span class="cm">        - 获取线程分离的状态属性
</span><span class="cm">
</span><span class="cm">    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
</span><span class="cm">        - 设置线程分离的状态属性
</span><span class="cm">*/</span>     

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;chid thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// 创建一个线程属性变量
</span><span class="c1"></span>    <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
    <span class="c1">// 初始化属性变量
</span><span class="c1"></span>    <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

    <span class="c1">// 设置属性
</span><span class="c1"></span>    <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_DETACHED</span><span class="p">);</span>

    <span class="c1">// 创建一个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">errstr</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error1 : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 获取线程的栈的大小
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">pthread_attr_getstacksize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;thread stack size : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="c1">// 输出主线程和子线程的id
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;tid : %ld, main thread id : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

    <span class="c1">// 释放线程属性资源
</span><span class="c1"></span>    <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="线程同步synchronization">线程同步（synchronization）</h2>
<p>◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</p>
<p>◼ <mark>临界区</mark>是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</p>
<p>◼ 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</p>
<h3 id="互斥量锁">互斥量（锁）</h3>
<h4 id="互斥量基本原理">互斥量基本原理</h4>
<p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 <strong>mutual exclusion</strong> 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</p>
<p>◼ 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。</p>
<p>◼ 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用<strong>不同的互斥量</strong>，每一线程在访问同一资源时将采用如下协议：</p>
<ol>
<li>
<p>针对共享资源锁定互斥量</p>
</li>
<li>
<p>访问共享资源</p>
</li>
<li>
<p>对互斥量解锁</p>
</li>
</ol>
<p>◼ 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示：</p>
<img title="" src="https://i0.hdslb.com/bfs/album/7e02471c53c2b07e42322c73de653fa9c52b2746.png" alt="" data-align="center">
<h4 id="互斥量示例">互斥量示例</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    互斥量的类型 pthread_mutex_t
</span><span class="cm">    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
</span><span class="cm">        - 初始化互斥量
</span><span class="cm">        - 参数 ：
</span><span class="cm">            - mutex ： 需要初始化的互斥量变量
</span><span class="cm">            - attr ： 互斥量相关的属性，NULL
</span><span class="cm">        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。
</span><span class="cm">            pthread_mutex_t *restrict mutex = xxx;
</span><span class="cm">            pthread_mutex_t * mutex1 = mutex;
</span><span class="cm">
</span><span class="cm">    int pthread_mutex_destroy(pthread_mutex_t *mutex);
</span><span class="cm">        - 释放互斥量的资源
</span><span class="cm">
</span><span class="cm">    int pthread_mutex_lock(pthread_mutex_t *mutex);
</span><span class="cm">        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待
</span><span class="cm">
</span><span class="cm">    int pthread_mutex_trylock(pthread_mutex_t *mutex);
</span><span class="cm">        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。
</span><span class="cm">
</span><span class="cm">    int pthread_mutex_unlock(pthread_mutex_t *mutex);
</span><span class="cm">        - 解锁
</span><span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 全局变量，所有的线程都共享这一份资源。
</span><span class="c1"></span><span class="kt">int</span> <span class="n">tickets</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="c1">// 创建一个互斥量
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">sellticket</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 卖票
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 加锁
</span><span class="c1"></span>        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">tickets</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">usleep</span><span class="p">(</span><span class="mi">6000</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%ld 正在卖第 %d 张门票</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">(),</span> <span class="n">tickets</span><span class="p">);</span>
            <span class="n">tickets</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 解锁
</span><span class="c1"></span>            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 解锁
</span><span class="c1"></span>        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>



    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// 初始化互斥量
</span><span class="c1"></span>    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建3个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">,</span> <span class="n">tid3</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sellticket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sellticket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sellticket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 回收子线程的资源,阻塞
</span><span class="c1"></span>    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">// 退出主线程
</span><span class="c1"></span>
    <span class="c1">// 释放互斥量资源
</span><span class="c1"></span>    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="死锁">死锁</h3>
<p>◼ 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。</p>
<p>◼ 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁</p>
<h4 id="死锁的几种场景">死锁的几种场景</h4>
<ul>
<li>
<p>忘记释放锁</p>
</li>
<li>
<p>重复加锁</p>
</li>
<li>
<p>多线程多锁，抢占锁资源</p>
</li>
</ul>
<p>更多关于死锁的内容将在操作系统的相关理论文章中介绍，本文不再继续讨论。</p>
<h4 id="死锁产生的四个必要条件">死锁产生的四个必要条件</h4>
<p>虽然进程在运行过程中，可能发生死锁，但死锁的发生必须具备一定的条件，死锁的发生必须具有以下四个必要条件。</p>
<p>（1）<strong>互斥条件</strong>：指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。</p>
<p>（2）<strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p>（3）<strong>不剥夺条件</strong>：指进程已获得的资源，在未使用之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p>（4）<strong>循环等待条件</strong>：指在发生死锁时，必然在一个进程 &ndash; 资源的环形链，即进程集合{P0， P1， P2 &hellip;， Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，&hellip;.，Pn正在等待已被 P0 占用的资源。</p>
<h4 id="死锁处理方法">死锁处理方法</h4>
<p>在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁</p>
<p>（1）<strong>预防死锁</strong> ：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</p>
<p>（2）<strong>避免死锁</strong>：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</p>
<p>（3）<strong>检测和解除死锁</strong>：先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。</p>
<p>这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p>
<h4 id="死锁示例">死锁示例</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 创建2个互斥量
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mutex1</span><span class="p">,</span> <span class="n">mutex2</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">workA</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex1</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex2</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;workA....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex2</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex1</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span> <span class="nf">workB</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex2</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex1</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;workB....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex1</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex2</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// 初始化互斥量
</span><span class="c1"></span>    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建2个子线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">workA</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">workB</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 回收子线程资源
</span><span class="c1"></span>    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 释放互斥量资源
</span><span class="c1"></span>    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex1</span><span class="p">);</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex2</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读写锁">读写锁</h3>
<p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p>
<p>◼ 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</p>
<p>◼ 读写锁的特点：</p>
<ul>
<li>
<p>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</p>
</li>
<li>
<p>如果有其它线程写数据，则其它线程都不允许读、写操作。</p>
</li>
<li>
<p>写是独占的，写的<strong>优先级高</strong>。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    读写锁的类型 pthread_rwlock_t
</span><span class="cm">    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
</span><span class="cm">    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
</span><span class="cm">    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
</span><span class="cm">    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
</span><span class="cm">    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
</span><span class="cm">    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
</span><span class="cm">    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
</span><span class="cm">
</span><span class="cm">    案例：8个线程操作同一个全局变量。
</span><span class="cm">    3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量
</span><span class="cm">*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 创建一个共享数据
</span><span class="c1"></span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// pthread_mutex_t mutex;
</span><span class="c1"></span><span class="n">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">writeNum</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
        <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;++write, tid : %ld, num : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">(),</span> <span class="n">num</span><span class="p">);</span>
        <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">readNum</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;===read, tid : %ld, num : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">(),</span> <span class="n">num</span><span class="p">);</span>
        <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

   <span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建3个写线程，5个读线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">wtids</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">rtids</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wtids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">writeNum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">readNum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 设置线程分离
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">pthread_detach</span><span class="p">(</span><span class="n">wtids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">pthread_detach</span><span class="p">(</span><span class="n">rtids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="条件变量">条件变量</h3>
<p>互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过<strong>允许线程阻塞和等待另一个线程发送信号</strong>的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行<strong>线程间的同步</strong>。</p>
<p><strong>条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。</strong></p>
<p>两个线程操作同一临界区时，通过互斥锁保护，若A线程已经加锁，B线程再加锁时候会被阻塞，直到A释放锁，B再获得锁运行，进程B必须不停的主动获得锁、检查条件、释放锁、再获得锁、再检查、再释放，一直到满足运行的条件的时候才可以（而此过程中其他线程一直在等待该线程的结束），这种方式是比较消耗系统的资源的。而条件变量同样是阻塞，还需要通知才能唤醒，线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，该线程就休眠了，应该仍阻塞在这里，等待条件满足后被唤醒，节省了线程不断运行浪费的资源。这个过程一般用<code>while</code>语句实现。当线程B发现被锁定的变量不满足条件时会自动的释放锁并把自身置于等待状态，让出CPU的控制权给其它线程。其它线程 此时就有机会去进行操作，当修改完成后再通知那些由于条件不满足而陷入等待状态的线程。这是一种通知模型的同步方式，大大的节省了CPU的计算资源，减少了线程之间的竞争，而且提高了线程之间的系统工作的效率。这种同步方式就是条件变量。</p>
<p><strong>示例（生产者-消费者模型）</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    条件变量的类型 pthread_cond_t
</span><span class="cm">    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);
</span><span class="cm">    int pthread_cond_destroy(pthread_cond_t *cond);
</span><span class="cm">    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
</span><span class="cm">        - 等待，调用了该函数，线程会阻塞。
</span><span class="cm">    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
</span><span class="cm">        - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。
</span><span class="cm">    int pthread_cond_signal(pthread_cond_t *cond);
</span><span class="cm">        - 唤醒一个或者多个等待的线程
</span><span class="cm">    int pthread_cond_broadcast(pthread_cond_t *cond);
</span><span class="cm">        - 唤醒所有的等待的线程
</span><span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 创建一个互斥量
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="c1">// 创建条件变量
</span><span class="c1"></span><span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 头结点
</span><span class="c1"></span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 不断的创建新的节点，添加到链表中
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;add node, num : %d, tid : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

        <span class="c1">// 只要生产了一个，就通知消费者消费
</span><span class="c1"></span>        <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>

        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">customer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="c1">// 保存头结点的指针
</span><span class="c1"></span>        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="c1">// 判断是否有数据
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 有数据
</span><span class="c1"></span>            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;del node, num : %d, tid : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
            <span class="n">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
            <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 没有数据，需要等待
</span><span class="c1"></span>            <span class="c1">// 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。
</span><span class="c1"></span>            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>  <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建5个生产者线程，和5个消费者线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">ptids</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">ctids</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">customer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_detach</span><span class="p">(</span><span class="n">ptids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">pthread_detach</span><span class="p">(</span><span class="n">ctids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>

    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="信号量">信号量</h3>
<p>信号量又称为信号灯（semaphore），其与自旋锁不同的地方是它可以引起调用者休眠，也就是信号量本质上是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，<strong>信号量会将其推进一个等待队列，然后让其睡眠</strong>。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放后），处于等待队列中的那个任务将被唤醒，并将获得该信号量。 信号量一个有用的特性是它<strong>可以同时允许任意数量的锁持有者</strong>，而自旋锁和互斥锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为使用者数量（usage count）或简单的叫做数量（count）。通常情况下，信号量和自旋锁一样，在一个时刻仅允许有一个锁持有者。这时计数等于1，这样的信号量被称为二值信号量或者称为互斥信号量。另一方面，初始化时也可以把数量设置为大于1的非0值。这种情况，信号量被称为计数信号量（counting semaphore），它允许在同一时刻至多有count个锁持有者。</p>
<p><strong>示例（生产者-消费者模型）</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">    信号量的类型 sem_t
</span><span class="cm">    int sem_init(sem_t *sem, int pshared, unsigned int value);
</span><span class="cm">        - 初始化信号量
</span><span class="cm">        - 参数：
</span><span class="cm">            - sem : 信号量变量的地址
</span><span class="cm">            - pshared : 0 用在线程间 ，非0 用在进程间
</span><span class="cm">            - value : 信号量中的值
</span><span class="cm">
</span><span class="cm">    int sem_destroy(sem_t *sem);
</span><span class="cm">        - 释放资源
</span><span class="cm">
</span><span class="cm">    int sem_wait(sem_t *sem);
</span><span class="cm">        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞
</span><span class="cm">
</span><span class="cm">    int sem_trywait(sem_t *sem);
</span><span class="cm">
</span><span class="cm">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
</span><span class="cm">    int sem_post(sem_t *sem);
</span><span class="cm">        - 对信号量解锁，调用一次对信号量的值+1
</span><span class="cm">
</span><span class="cm">    int sem_getvalue(sem_t *sem, int *sval);
</span><span class="cm">
</span><span class="cm">    sem_t psem;
</span><span class="cm">    sem_t csem;
</span><span class="cm">    init(psem, 0, 8);
</span><span class="cm">    init(csem, 0, 0);
</span><span class="cm">
</span><span class="cm">    producer() {
</span><span class="cm">        sem_wait(&amp;psem);
</span><span class="cm">        sem_post(&amp;csem)
</span><span class="cm">    }
</span><span class="cm">
</span><span class="cm">    customer() {
</span><span class="cm">        sem_wait(&amp;csem);
</span><span class="cm">        sem_post(&amp;psem)
</span><span class="cm">    }
</span><span class="cm">
</span><span class="cm">*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 创建一个互斥量
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="c1">// 创建两个信号量
</span><span class="c1"></span><span class="n">sem_t</span> <span class="n">psem</span><span class="p">;</span>
<span class="n">sem_t</span> <span class="n">csem</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 头结点
</span><span class="c1"></span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 不断的创建新的节点，添加到链表中
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psem</span><span class="p">);</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;add node, num : %d, tid : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csem</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">customer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csem</span><span class="p">);</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="c1">// 保存头结点的指针
</span><span class="c1"></span>        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;del node, num : %d, tid : %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
        <span class="n">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psem</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span>  <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// 创建5个生产者线程，和5个消费者线程
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">ptids</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">ctids</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">customer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_detach</span><span class="p">(</span><span class="n">ptids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">pthread_detach</span><span class="p">(</span><span class="n">ctids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-04-12</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/linux_multi_threads/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://example.com/linux_multi_threads/" data-title="Linux下的多线程" data-hashtags="Unix,MultiThreads"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://example.com/linux_multi_threads/" data-title="Linux下的多线程" data-image="https://i0.hdslb.com/bfs/album/233aa1a553ddf86da52e30838d8b82e69bc4fdba.webp" data-ralateuid="xxxx"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/unix/">Unix</a>,&nbsp;<a href="/tags/multithreads/">MultiThreads</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/ipc/" class="prev" rel="prev" title="Linux多进程通信"><i class="fas fa-angle-left fa-fw"></i>Linux多进程通信</a>
            <a href="/cmake_tutorial/" class="next" rel="next" title="CMake使用方法">CMake使用方法<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.91.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Weiyee</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":30},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
